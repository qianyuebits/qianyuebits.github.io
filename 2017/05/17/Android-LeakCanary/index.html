<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="千越">





<title>Android LeakCanary | 千越</title>



    <link rel="icon" href="/image/icon.jpeg">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">千越的博客</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">千越的博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Android LeakCanary</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">千越</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">2017-05-17&nbsp;&nbsp;22:23:45</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p><strong>【参考文章】</strong></p>
<ol>
<li><a target="_blank" rel="noopener" href="https://github.com/leavesCZY/AndroidGuide/blob/master/android_opensource/5-LeakCanary%E6%BA%90%E7%A0%81%E8%AF%A6%E8%A7%A3.md">LeakCanary 源码详解</a> —— 下面整文摘抄</li>
</ol>
<blockquote>
<p>公众号：<a target="_blank" rel="noopener" href="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/adbc507fc3704fd8955aae739a433db2~tplv-k3u1fbpfcp-zoom-1.image">字节数组</a></p>
<p>希望对你有所帮助 🤣🤣</p>
</blockquote>
<blockquote>
<p>对于 Android Developer 来说，很多开源库都是属于<strong>开发必备</strong>的知识点，从使用方式到实现原理再到源码解析，这些都需要我们有一定程度的了解和运用能力。所以我打算来写一系列关于开源库<strong>源码解析</strong>和<strong>实战演练</strong>的文章，初定的目标是 <strong>EventBus、ARouter、LeakCanary、Retrofit、Glide、OkHttp、Coil</strong> 等七个知名开源库，希望对你有所帮助 🤣🤣</p>
</blockquote>
<p><a target="_blank" rel="noopener" href="https://github.com/square/leakcanary/">LeakCanary</a> 是由 <a target="_blank" rel="noopener" href="https://github.com/square">Square</a> 公司开源的用于 Android 的内存泄漏检测工具，可以帮助开发者发现内存泄露情况并且找出泄露源头，有助于减少 <code>OutOfMemoryError</code> 情况的发生。在目前的应用开发中也算作是性能优化的一个重要实现途径，很多面试官在考察性能优化时都会问到 LeakCanary 的实现原理</p>
<p>本文就来对其实现原理进行分析，具体的 Git 版本节点是：<strong>9f62126e</strong>，来了解 LeakCanary 的整体运行流程和实现原理 😂😂</p>
<h1 id="一、支持的内存泄露类型"><a href="#一、支持的内存泄露类型" class="headerlink" title="一、支持的内存泄露类型"></a>一、支持的内存泄露类型</h1><p>我们经常说 LeakCanary 能检测到应用内发生的内存泄露，那么它到底具体支持什么类型的内存泄露情况呢？LeakCanary   官网有对此进行介绍：</p>
<p>LeakCanary automatically detects leaks of the following objects:</p>
<ul>
<li>destroyed <code>Activity</code> instances</li>
<li>destroyed <code>Fragment</code> instances</li>
<li>destroyed fragment <code>View</code> instances</li>
<li>cleared <code>ViewModel</code> instances</li>
</ul>
<p>我们也可以从 LeakCanary 的 <code>AppWatcher.Config</code> 这个类找到答案。Config 类用于配置是否开启内存检测，从其配置项就可以看出来 leakcanary 支持：<strong>Activity、Fragment、FragmentView、ViewModel</strong> 等四种类型</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Config</span>(</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Whether AppWatcher should automatically watch destroyed activity instances.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Defaults to true.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> watchActivities: <span class="built_in">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Whether AppWatcher should automatically watch destroyed fragment instances.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Defaults to true.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> watchFragments: <span class="built_in">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Whether AppWatcher should automatically watch destroyed fragment view instances.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Defaults to true.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> watchFragmentViews: <span class="built_in">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Whether AppWatcher should automatically watch cleared [androidx.lifecycle.ViewModel]</span></span><br><span class="line"><span class="comment">     * instances.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Defaults to true.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> watchViewModels: <span class="built_in">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * How long to wait before reporting a watched object as retained.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Default to 5 seconds.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> watchDurationMillis: <span class="built_in">Long</span> = TimeUnit.SECONDS.toMillis(<span class="number">5</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Deprecated, this didn&#x27;t need to be a part of the API.</span></span><br><span class="line"><span class="comment">     * Used to indicate whether AppWatcher should watch objects (by keeping weak references to</span></span><br><span class="line"><span class="comment">     * them). Currently a no-op.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * If you do need to stop watching objects, simply don&#x27;t pass them to [objectWatcher].</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Deprecated(<span class="string">&quot;This didn&#x27;t need to be a part of LeakCanary&#x27;s API. No-Op.&quot;</span>)</span></span><br><span class="line">    <span class="keyword">val</span> enabled: <span class="built_in">Boolean</span> = <span class="literal">true</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<h1 id="二、初始化"><a href="#二、初始化" class="headerlink" title="二、初始化"></a>二、初始化</h1><p>如今，我们在项目中引入 LeakCanary 只需要添加如下依赖即可，无须任何的初始化行为等附加操作，当应用启动时 LeakCanary 就会自动启动并开始监测了</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">  <span class="comment">// debugImplementation because LeakCanary should only run in debug builds.</span></span><br><span class="line">  debugImplementation <span class="string">&#x27;com.squareup.leakcanary:leakcanary-android:2.4&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一般来说，像这类第三方库都是需要由外部传入一个 <code>ApplicationContext</code> 对象进行初始化并启动的，LeakCanary 的 1.x 版本也是如此，但在 2.x 版本中，LeakCanary 将初始过程交由 <code>AppWatcherInstaller</code> 这个 <code>ContentProvider</code> 来自动完成</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">sealed</span> <span class="keyword">class</span> <span class="title class_">AppWatcherInstaller</span> : <span class="type">ContentProvider</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * [MainProcess] automatically sets up the LeakCanary code that runs in the main app process.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">MainProcess</span> : <span class="type">AppWatcherInstaller</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * When using the `leakcanary-android-process` artifact instead of `leakcanary-android`,</span></span><br><span class="line"><span class="comment">     * [LeakCanaryProcess] automatically sets up the LeakCanary code</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">LeakCanaryProcess</span> : <span class="type">AppWatcherInstaller</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> application = context!!.applicationContext <span class="keyword">as</span> Application</span><br><span class="line">        AppWatcher.manualInstall(application)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>ContentProvider</code> 会在 <code>Application</code> 被创建之前就由系统调用其 <code>onCreate()</code> 方法来完成初始化，所以 LeakCanary 通过 <code>AppWatcherInstaller</code> 就可以拿到 <code>Context</code> 来完成初始化并随应用一起启动，通过这种方式就简化了使用者的引入成本。而且由于我们的引用方式是 <code>debugImplementation</code>，所以<strong>正式版本</strong>会自动移除对 LeakCanary 的所有引用，进一步简化了引入成本</p>
<p>Jetpack 也包含了一个组件来实现<strong>通过 ContentProvider 来完成初始化的逻辑</strong>：<a target="_blank" rel="noopener" href="https://juejin.im/post/6847902224069165070">AppStartup</a>。在实现思路上两者很类似，但是如果每个三方库都通过自定义 <code>ContentProvider</code> 来实现初始化的话，那么应用的启动速度就会很感人了吧 :joy:，所以 Jetpack 官方推出的 <code>AppStartup</code> 应该是以后的主流才对</p>
<p><code>AppWatcherInstaller</code> 最终会将 <code>Application</code> 对象传给 <code>InternalAppWatcher</code> 的 <code>install(Application)</code> 方法</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Note: this object must load fine in a JUnit environment</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> InternalAppWatcher &#123;</span><br><span class="line"></span><br><span class="line">  ···</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">val</span> objectWatcher = ObjectWatcher(</span><br><span class="line">      clock = clock,</span><br><span class="line">      checkRetainedExecutor = checkRetainedExecutor,</span><br><span class="line">      isEnabled = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(application: <span class="type">Application</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">//检测是否在 main 线程</span></span><br><span class="line">    checkMainThread()</span><br><span class="line">    <span class="comment">//避免重复初始化</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>::application.isInitialized) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    InternalAppWatcher.application = application</span><br><span class="line">    <span class="keyword">if</span> (isDebuggableBuild) &#123;</span><br><span class="line">      SharkLog.logger = DefaultCanaryLog()</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//拿到默认配置，默认四种类型都进行检测</span></span><br><span class="line">    <span class="keyword">val</span> configProvider = &#123; AppWatcher.config &#125;</span><br><span class="line">    <span class="comment">//检测 Activity</span></span><br><span class="line">    ActivityDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    <span class="comment">//检测 Fragment、FragmentView、ViewModel</span></span><br><span class="line">    FragmentDestroyWatcher.install(application, objectWatcher, configProvider)</span><br><span class="line">    onAppWatcherInstalled(application)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ···</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>LeakCanary 具体进行内存泄露检测的逻辑可以分为三类：</p>
<ul>
<li>ObjectWatcher。检测 Object 的内存泄露情况</li>
<li>ActivityDestroyWatcher。检测 Activity 的内存泄露情况</li>
<li>FragmentDestroyWatcher。检测 Fragment、FragmentView、ViewModel 的内存泄露情况</li>
</ul>
<p>当中，<code>ActivityDestroyWatcher</code> 和 <code>FragmentDestroyWatcher</code> 都需要依靠 <code>ObjectWatcher</code> 来完成，因为 <code>Activity、Fragment、FragmentView、ViewModel</code>  本质上都属于不同类型的 <code>Object</code> </p>
<h1 id="三、ObjectWatcher：检测任意对象"><a href="#三、ObjectWatcher：检测任意对象" class="headerlink" title="三、ObjectWatcher：检测任意对象"></a>三、ObjectWatcher：检测任意对象</h1><p>我们知道，当一个对象不再被我们引用时，如果该对象由于代码错误或者其它原因导致迟迟无法被系统回收，此时就是发生了内存泄露。那么 LeakCanary 是怎么知道应用是否发生了内存泄露呢？</p>
<p>这个可以依靠引用队列 <code>ReferenceQueue</code> 来实现。先来看个小例子</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span>: leavesCZY</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Github</span>：https://github.com/leavesCZY</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> referenceQueue = ReferenceQueue&lt;Pair&lt;String, <span class="built_in">Int</span>&gt;?&gt;()</span><br><span class="line">    <span class="keyword">var</span> pair: Pair&lt;String, <span class="built_in">Int</span>&gt;? = Pair(<span class="string">&quot;name&quot;</span>, <span class="number">24</span>)</span><br><span class="line">    <span class="keyword">val</span> weakReference = WeakReference(pair, referenceQueue)</span><br><span class="line"></span><br><span class="line">    println(referenceQueue.poll()) <span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">    pair = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    System.gc()</span><br><span class="line">    <span class="comment">//GC 后休眠一段时间，等待 pair 被回收</span></span><br><span class="line">    Thread.sleep(<span class="number">4000</span>)</span><br><span class="line"></span><br><span class="line">    println(referenceQueue.poll()) <span class="comment">//java.lang.ref.WeakReference@d716361</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，在 GC 过后 <code>referenceQueue.poll()</code> 的返回值变成了<strong>非 null</strong>，这是由于 <code>WeakReference</code> 和 <code>ReferenceQueue</code> 的一个组合特性导致的：在声明一个 <code>WeakReference</code> 对象时如果同时传入了 <code>ReferenceQueue</code> 作为构造参数的话，那么当 <code>WeakReference</code> 持有的对象被 GC 回收时，JVM 就会把这个<strong>弱引用</strong>存入与之关联的引用队列之中。依靠这个特性，我们就可以实现内存泄露的检测了</p>
<p>例如，当用户按返回键退出 Activity 时，正常情况下该 Activity 对象应该在不久后就被系统回收，我们可以监听 Activity 的 <code>onDestroy</code> 回调，在回调时把 Activity 对象保存到和 <code>ReferenceQueue</code> 关联的 <code>WeakReference</code> 中，在一段时间后（可以主动触发几次 GC）检测 <code>ReferenceQueue</code> 中是否有值，如果一直为 null 的话就说明发生了内存泄露。LeakCanary 就是通过这种方法来实现的</p>
<p><code>ObjectWatcher</code> 中就封装了上述逻辑，这里来看看其实现逻辑</p>
<p><code>ObjectWatcher</code> 的起始方法是 <code>watch(Any, String)</code>，该方法就用于监听指定对象</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * References passed to [watch].</span></span><br><span class="line"><span class="comment"> * 用于保存要监听的对象，mapKey 是该对象的唯一标识、mapValue 是该对象的弱引用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> watchedObjects = mutableMapOf&lt;String, KeyedWeakReference&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">//KeyedWeakReference 关联的引用队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> queue = ReferenceQueue&lt;Any&gt;()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Watches the provided [watchedObject].</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> description Describes why the object is watched.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Synchronized</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">watch</span><span class="params">(watchedObject: <span class="type">Any</span>, description: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    removeWeaklyReachableObjects()</span><br><span class="line">    <span class="comment">//为 watchedObject 生成一个唯一标识</span></span><br><span class="line">    <span class="keyword">val</span> key = UUID.randomUUID().toString()</span><br><span class="line">    <span class="keyword">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class="line">    <span class="comment">//创建 watchedObject 关联的弱引用</span></span><br><span class="line">    <span class="keyword">val</span> reference = KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">    ···</span><br><span class="line">    watchedObjects[key] = reference</span><br><span class="line">    checkRetainedExecutor.execute &#123;</span><br><span class="line">        moveToRetained(key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>watch()</code> 方法的主要逻辑：</p>
<ol>
<li>为每个 <code>watchedObject</code> 生成一个<strong>唯一标识 key</strong>，通过该 key 构建一个 <code>watchedObject</code> 的弱引用 <code>KeyedWeakReference</code>，将该弱引用保存到 <code>watchedObjects</code> 中。<code>ObjectWatcher</code> 可以先后监测多个对象，每个对象都会先被存入到 <code>watchedObjects</code> 中</li>
<li>外部通过传入的 <code>checkRetainedExecutor</code> 来指定检测内存泄露的触发时机，通过 <code>moveToRetained</code> 方法来判断是否真的发生了内存泄露</li>
</ol>
<p><code>KeyedWeakReference</code>  是一个自定义的 <code>WeakReference</code> 子类，包含一个唯一 key 来标识特定对象，也包含一个 <code>retainedUptimeMillis</code> 字段用来标记是否发生了内存泄露</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KeyedWeakReference</span>(</span><br><span class="line">        referent: Any,</span><br><span class="line">        <span class="keyword">val</span> key: String,</span><br><span class="line">        <span class="keyword">val</span> description: String,</span><br><span class="line">        <span class="keyword">val</span> watchUptimeMillis: <span class="built_in">Long</span>,</span><br><span class="line">        referenceQueue: ReferenceQueue&lt;Any&gt;</span><br><span class="line">) : WeakReference&lt;Any&gt;(</span><br><span class="line">        referent, referenceQueue</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Time at which the associated object ([referent]) was considered retained, or -1 if it hasn&#x27;t</span></span><br><span class="line"><span class="comment">     * been yet.</span></span><br><span class="line"><span class="comment">     * 用于标记 referent 是否还未被回收，是的话则值不为 -1</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Volatile</span></span><br><span class="line">    <span class="keyword">var</span> retainedUptimeMillis = -<span class="number">1L</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="meta">@JvmStatic</span></span><br><span class="line">        <span class="keyword">var</span> heapDumpUptimeMillis = <span class="number">0L</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>moveToRetained</code> 方法就用于判断指定 key 关联的对象是否已经泄露，如果没有泄露则移除对该对象的弱引用，有泄露的话则更新其 <code>retainedUptimeMillis</code> 值，以此来标记其发生了泄露，并同时通过回调 <code>onObjectRetainedListeners</code> 来分析内存泄露链</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Synchronized</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetained</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    removeWeaklyReachableObjects()</span><br><span class="line">    <span class="keyword">val</span> retainedRef = watchedObjects[key]</span><br><span class="line">    <span class="keyword">if</span> (retainedRef != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">//记录当前时间</span></span><br><span class="line">        retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class="line">        onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果判断到一个对象没有发生内存泄露，那么就移除对该对象的弱引用</span></span><br><span class="line"><span class="comment">//此方法会先后调用多次</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">removeWeaklyReachableObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">    <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">    <span class="keyword">var</span> ref: KeyedWeakReference?</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        ref = queue.poll() <span class="keyword">as</span> KeyedWeakReference?</span><br><span class="line">        <span class="keyword">if</span> (ref != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果 ref 不为 null，说明 ref 关联的对象没有发生内存泄露，那么就移除对该对象的引用</span></span><br><span class="line">            watchedObjects.remove(ref.key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (ref != <span class="literal">null</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、ActivityDestroyWatcher：检测Activity"><a href="#四、ActivityDestroyWatcher：检测Activity" class="headerlink" title="四、ActivityDestroyWatcher：检测Activity"></a>四、ActivityDestroyWatcher：检测Activity</h1><p>理解了 <code>ObjectWatcher</code> 的流程后来看 <code>ActivityDestroyWatcher</code> 就会比较简单了。<code>ActivityDestroyWatcher</code> 会向 <code>Application</code> 注册一个 <code>ActivityLifecycleCallbacks</code> 回调，当收到每个 Activity 执行了 <code>onDestroy</code> 的回调后，就会将将 Activity 对象转交由 <code>ObjectWatcher</code> 来进行监听</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">ActivityDestroyWatcher</span> <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="keyword">private</span> <span class="keyword">val</span> objectWatcher: ObjectWatcher, <span class="keyword">private</span> <span class="keyword">val</span> configProvider: () -&gt; Config) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> lifecycleCallbacks = <span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityDestroyed</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (configProvider().watchActivities) &#123;</span><br><span class="line">                objectWatcher.watch(activity, <span class="string">&quot;<span class="subst">$&#123;activity::class.java.name&#125;</span> received Activity#onDestroy() callback&quot;</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(application: <span class="type">Application</span>, objectWatcher: <span class="type">ObjectWatcher</span>, configProvider: () -&gt; <span class="type">Config</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> activityDestroyWatcher = ActivityDestroyWatcher(objectWatcher, configProvider)</span><br><span class="line">            application.registerActivityLifecycleCallbacks(activityDestroyWatcher.lifecycleCallbacks)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、FragmentDestroyWatcher：检测Fragment"><a href="#五、FragmentDestroyWatcher：检测Fragment" class="headerlink" title="五、FragmentDestroyWatcher：检测Fragment"></a>五、FragmentDestroyWatcher：检测Fragment</h1><p>做 Android 应用开发的应该都知道，现在 Google 提供的基础依赖包分为了 <strong>Support</strong> 和 <strong>AndroidX</strong> 两种，<strong>Support</strong> 版本已经不再维护，主流的都是使用 <strong>AndroidX</strong> 了。而 LeakCanary 为了照顾老项目，就贴心的为这两种版本分别提供了 Fragment 的内存检测功能</p>
<p><code>FragmentDestroyWatcher</code> 可以看做是一个分发器，它会根据外部环境的不同来选择不同的检测手段，其主要逻辑是：</p>
<ul>
<li>系统版本大于等于 8.0。使用 AndroidOFragmentDestroyWatcher 来检测 Fragment、FragmentView 的内存泄露</li>
<li>开发者使用的是 Support 包。使用 AndroidSupportFragmentDestroyWatcher 来检测 Fragment、FragmentView 的内存泄露</li>
<li>开发者使用的是 AndroidX 包。使用 AndroidXFragmentDestroyWatcher 来检测 Fragment、FragmentView、ViewModel 的内存泄露</li>
<li>通过反射 Class.forName 来判断开发者使用的是 Support 包还是 AndroidX 包</li>
<li>由于 Fragment 都需要被挂载在 Activity 上，所有向 Application 注册一个 ActivityLifecycleCallback，每当有 Activity 被创建时就监听该 Activity 内可能存在的 Fragment</li>
</ul>
<blockquote>
<p>这里令我很疑惑的一个点就是：当系统版本大于等于  8.0 时，AndroidOFragmentDestroyWatcher 不就会和 AndroidSupportFragmentDestroyWatcher 或者 AndroidXFragmentDestroyWatcher 重复了吗？这算咋回事:joy:</p>
</blockquote>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> FragmentDestroyWatcher &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ANDROIDX_FRAGMENT_CLASS_NAME = <span class="string">&quot;androidx.fragment.app.Fragment&quot;</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =</span><br><span class="line">    <span class="string">&quot;leakcanary.internal.AndroidXFragmentDestroyWatcher&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Using a string builder to prevent Jetifier from changing this string to Android X Fragment</span></span><br><span class="line">  <span class="meta">@Suppress(<span class="string">&quot;VariableNaming&quot;</span>, <span class="string">&quot;PropertyName&quot;</span>)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> ANDROID_SUPPORT_FRAGMENT_CLASS_NAME =</span><br><span class="line">    StringBuilder(<span class="string">&quot;android.&quot;</span>).append(<span class="string">&quot;support.v4.app.Fragment&quot;</span>)</span><br><span class="line">        .toString()</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME =</span><br><span class="line">    <span class="string">&quot;leakcanary.internal.AndroidSupportFragmentDestroyWatcher&quot;</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">    application: <span class="type">Application</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    objectWatcher: <span class="type">ObjectWatcher</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    configProvider: () -&gt; <span class="type">AppWatcher</span>.<span class="type">Config</span></span></span></span><br><span class="line"><span class="params"><span class="function">  )</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> fragmentDestroyWatchers = mutableListOf&lt;(Activity) -&gt; <span class="built_in">Unit</span>&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SDK_INT &gt;= O) &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(</span><br><span class="line">          AndroidOFragmentDestroyWatcher(objectWatcher, configProvider)</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AndroidX </span></span><br><span class="line">    getWatcherIfAvailable(</span><br><span class="line">        ANDROIDX_FRAGMENT_CLASS_NAME,</span><br><span class="line">        ANDROIDX_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,</span><br><span class="line">        objectWatcher,</span><br><span class="line">        configProvider</span><br><span class="line">    )?.let &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Support </span></span><br><span class="line">    getWatcherIfAvailable(</span><br><span class="line">        ANDROID_SUPPORT_FRAGMENT_CLASS_NAME,</span><br><span class="line">        ANDROID_SUPPORT_FRAGMENT_DESTROY_WATCHER_CLASS_NAME,</span><br><span class="line">        objectWatcher,</span><br><span class="line">        configProvider</span><br><span class="line">    )?.let &#123;</span><br><span class="line">      fragmentDestroyWatchers.add(it)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (fragmentDestroyWatchers.size == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    application.registerActivityLifecycleCallbacks(<span class="keyword">object</span> : Application.ActivityLifecycleCallbacks <span class="keyword">by</span> noOpDelegate() &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onActivityCreated</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        activity: <span class="type">Activity</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">        savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">      )</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (watcher <span class="keyword">in</span> fragmentDestroyWatchers) &#123;</span><br><span class="line">          watcher(activity)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ···</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>AndroidXFragmentDestroyWatcher</code>、<code>AndroidSupportFragmentDestroyWatcher</code>、<code>AndroidOFragmentDestroyWatcher</code> 在逻辑上很类似，且就 <code>AndroidXFragmentDestroyWatcher</code> 同时提供了 <code>ViewModel</code> 内存泄露的检测功能，所以这里只看 <code>AndroidXFragmentDestroyWatcher</code> 就行</p>
<p><code>AndroidXFragmentDestroyWatcher</code> 的主要逻辑是：</p>
<ul>
<li>在 invoke 方法里向 Activity 的 FragmentManager 以及 childFragmentManager 注册一个 FragmentLifecycleCallback，通过该回调拿到 onFragmentViewDestroyed 和 onFragmentDestroyed 的事件通知，收到通知时就通过 ObjectWatcher 启动检测</li>
<li>在 onFragmentCreated 回调里通过 ViewModelClearedWatcher 来启动和 Fragment 关联的 ViewModel 的内存泄露检测逻辑</li>
<li>在 invoke 方法里通过 ViewModelClearedWatcher 来启动和 Activity 关联的 ViewModel 的内存泄露检测</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">AndroidXFragmentDestroyWatcher</span>(</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> objectWatcher: ObjectWatcher,</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> configProvider: () -&gt; Config</span><br><span class="line">) : (Activity) -&gt; <span class="built_in">Unit</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> fragmentLifecycleCallbacks = <span class="keyword">object</span> : FragmentManager.FragmentLifecycleCallbacks() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentCreated</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      fragment: <span class="type">Fragment</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">      ViewModelClearedWatcher.install(fragment, objectWatcher, configProvider)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentViewDestroyed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      fragment: <span class="type">Fragment</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">      <span class="keyword">val</span> view = fragment.view</span><br><span class="line">      <span class="keyword">if</span> (view != <span class="literal">null</span> &amp;&amp; configProvider().watchFragmentViews) &#123;</span><br><span class="line">        objectWatcher.watch(</span><br><span class="line">            view, <span class="string">&quot;<span class="subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroyView() callback &quot;</span> +</span><br><span class="line">            <span class="string">&quot;(references to its views should be cleared to prevent leaks)&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onFragmentDestroyed</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">      fm: <span class="type">FragmentManager</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      fragment: <span class="type">Fragment</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (configProvider().watchFragments) &#123;</span><br><span class="line">        objectWatcher.watch(</span><br><span class="line">            fragment, <span class="string">&quot;<span class="subst">$&#123;fragment::class.java.name&#125;</span> received Fragment#onDestroy() callback&quot;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">invoke</span><span class="params">(activity: <span class="type">Activity</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (activity <span class="keyword">is</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">val</span> supportFragmentManager = activity.supportFragmentManager</span><br><span class="line">      supportFragmentManager.registerFragmentLifecycleCallbacks(fragmentLifecycleCallbacks, <span class="literal">true</span>)</span><br><span class="line">      ViewModelClearedWatcher.install(activity, objectWatcher, configProvider)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Fragment 和 FragmentView 走向 <code>Destroyed</code> 时，正常情况下它们都是不会被复用的，应该会很快就被 GC 回收，且它们本质上都只是一种对象，所以直接使用 <code>ObjectWatcher</code> 进行检测即可</p>
<h1 id="六、ViewModelClearedWatcher：检测ViewModel"><a href="#六、ViewModelClearedWatcher：检测ViewModel" class="headerlink" title="六、ViewModelClearedWatcher：检测ViewModel"></a>六、ViewModelClearedWatcher：检测ViewModel</h1><p>和 Fragment、FragmentView 相比，ViewModel 就比较特殊了，由于可能存在一个 Activity 和多个 Fragment 同时持有一个 ViewModel 实例的情况，而 leakcanary 无法知道 ViewModel 到底是同时被几个持有者所持有，所以无法通过单独一个 Activity 和 Fragment 的 <code>Destroyed</code> 回调来启动对 ViewModel 的检测。幸好 ViewMode 也提供了 <code>onCleared()</code> 的回调事件，leakcanary 就通过该回调来知道 ViewModel 是什么时候需要被回收。对 ViewModel 的实现原理不清楚的同学可以看我的这篇文章：<a target="_blank" rel="noopener" href="https://juejin.im/post/6873356946896846856">从源码看 Jetpack（6）-ViewModel源码详解</a></p>
<p><code>ViewModelClearedWatcher</code> 的主要逻辑是：</p>
<ul>
<li>ViewModelClearedWatcher 继承于 ViewModel，当拿到 ViewModelStoreOwner 实例（Activity 或者 Fragment）后，就创建一个和该实例绑定的 ViewModelClearedWatcher 对象</li>
<li>ViewModelClearedWatcher 通过反射获取到 ViewModelStore 中的 mMap 变量，该变量就存储了所有的 Viewmodel 实例</li>
<li>当 ViewModelClearedWatcher 的 onCleared() 方法被回调了，就说明了所有和 Activity 或者 Fragment 绑定的 ViewModel 实例都不再被需要了，此时就可以开始监测所有的 ViewModel 实例了</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">ViewModelClearedWatcher</span>(</span><br><span class="line">        storeOwner: ViewModelStoreOwner,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> objectWatcher: ObjectWatcher,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> configProvider: () -&gt; Config</span><br><span class="line">) : ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> viewModelMap: Map&lt;String, ViewModel&gt;?</span><br><span class="line"></span><br><span class="line">    <span class="keyword">init</span> &#123;</span><br><span class="line">        <span class="comment">// We could call ViewModelStore#keys with a package spy in androidx.lifecycle instead,</span></span><br><span class="line">        <span class="comment">// however that was added in 2.1.0 and we support AndroidX first stable release. viewmodel-2.0.0</span></span><br><span class="line">        <span class="comment">// does not have ViewModelStore#keys. All versions currently have the mMap field.</span></span><br><span class="line">        viewModelMap = <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> mMapField = ViewModelStore::<span class="keyword">class</span>.java.getDeclaredField(<span class="string">&quot;mMap&quot;</span>)</span><br><span class="line">            mMapField.isAccessible = <span class="literal">true</span></span><br><span class="line">            <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">            mMapField[storeOwner.viewModelStore] <span class="keyword">as</span> Map&lt;String, ViewModel&gt;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ignored: Exception) &#123;</span><br><span class="line">            <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCleared</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (viewModelMap != <span class="literal">null</span> &amp;&amp; configProvider().watchViewModels) &#123;</span><br><span class="line">            viewModelMap.values.forEach &#123; viewModel -&gt;</span><br><span class="line">                objectWatcher.watch(</span><br><span class="line">                        viewModel, <span class="string">&quot;<span class="subst">$&#123;viewModel::class.java.name&#125;</span> received ViewModel#onCleared() callback&quot;</span></span><br><span class="line">                )</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">install</span><span class="params">(storeOwner: <span class="type">ViewModelStoreOwner</span>, objectWatcher: <span class="type">ObjectWatcher</span>, configProvider: () -&gt; <span class="type">Config</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> provider = ViewModelProvider(storeOwner, <span class="keyword">object</span> : Factory &#123;</span><br><span class="line">              <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">              <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel?&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T =</span><br><span class="line">                      ViewModelClearedWatcher(storeOwner, objectWatcher, configProvider) <span class="keyword">as</span> T</span><br><span class="line">            &#125;)</span><br><span class="line">            provider.<span class="keyword">get</span>(ViewModelClearedWatcher::<span class="keyword">class</span>.java)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、检测到内存泄露后的流程"><a href="#七、检测到内存泄露后的流程" class="headerlink" title="七、检测到内存泄露后的流程"></a>七、检测到内存泄露后的流程</h1><p>我们不可能在 Activity 刚被回调了 <code>onDestroy</code> 方法就马上来判断 <code>ReferenceQueue</code> 中是否有值，因为 JVM 的 GC 时机是不确定的，Activity 对象可能不会那么快就被回收，所以需要延迟一段时间后再来检测。而即使延迟检测了，也可能会存在<strong>应用没有发生内存泄露只是系统还未执行 GC</strong> 的情况，所以就需要去主动触发 GC，经过几轮检测后才可以确定当前应用是否的确发生了内存泄露</p>
<p>这里就来看下具体的检测流程</p>
<p><code>ObjectWatcher</code> 对象包含了一个 <code>Executor</code> 参数：<code>checkRetainedExecutor</code>。检测操作的触发时机就取决于向 <code>checkRetainedExecutor</code> 提交的任务在什么时候会被执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectWatcher</span> <span class="keyword">constructor</span>(<span class="keyword">private</span> <span class="keyword">val</span> clock: Clock, <span class="keyword">private</span> <span class="keyword">val</span> checkRetainedExecutor: Executor,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Calls to [watch] will be ignored when [isEnabled] returns false</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> isEnabled: () -&gt; <span class="built_in">Boolean</span> = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Watches the provided [watchedObject].</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> description Describes why the object is watched.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">watch</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            watchedObject: <span class="type">Any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            description: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isEnabled()) &#123;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        removeWeaklyReachableObjects()</span><br><span class="line">        <span class="keyword">val</span> key = UUID.randomUUID()</span><br><span class="line">                .toString()</span><br><span class="line">        <span class="keyword">val</span> watchUptimeMillis = clock.uptimeMillis()</span><br><span class="line">        <span class="keyword">val</span> reference =</span><br><span class="line">                KeyedWeakReference(watchedObject, key, description, watchUptimeMillis, queue)</span><br><span class="line">        SharkLog.d &#123;</span><br><span class="line">            <span class="string">&quot;Watching &quot;</span> +</span><br><span class="line">                    (<span class="keyword">if</span> (watchedObject <span class="keyword">is</span> Class&lt;*&gt;) watchedObject.toString() <span class="keyword">else</span> <span class="string">&quot;instance of <span class="subst">$&#123;watchedObject.javaClass.name&#125;</span>&quot;</span>) +</span><br><span class="line">                    (<span class="keyword">if</span> (description.isNotEmpty()) <span class="string">&quot; (<span class="variable">$description</span>)&quot;</span> <span class="keyword">else</span> <span class="string">&quot;&quot;</span>) +</span><br><span class="line">                    <span class="string">&quot; with key <span class="variable">$key</span>&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">        watchedObjects[key] = reference</span><br><span class="line">        <span class="comment">//重点</span></span><br><span class="line">        checkRetainedExecutor.execute &#123;</span><br><span class="line">            moveToRetained(key)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断 key 关联的对象是否已经泄露</span></span><br><span class="line">    <span class="comment">//是的话则将更新其 retainedUptimeMillis 值，以此来标记其发生了泄露</span></span><br><span class="line">    <span class="meta">@Synchronized</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">moveToRetained</span><span class="params">(key: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        removeWeaklyReachableObjects()</span><br><span class="line">        <span class="keyword">val</span> retainedRef = watchedObjects[key]</span><br><span class="line">        <span class="keyword">if</span> (retainedRef != <span class="literal">null</span>) &#123;</span><br><span class="line">            retainedRef.retainedUptimeMillis = clock.uptimeMillis()</span><br><span class="line">            <span class="comment">//重点，向外发出可能有内存泄露的通知</span></span><br><span class="line">            onObjectRetainedListeners.forEach &#123; it.onObjectRetained() &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ObjectWatcher</code> 对象又是在 <code>InternalAppWatcher</code> 里初始化的，<code>checkRetainedExecutor</code> 在收到任务后会通过 <code>Handler</code> 来延时五秒执行</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> InternalAppWatcher &#123;</span><br><span class="line"></span><br><span class="line">  ···	</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> mainHandler <span class="keyword">by</span> lazy &#123;</span><br><span class="line">    Handler(Looper.getMainLooper())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> checkRetainedExecutor = Executor &#123;</span><br><span class="line">    mainHandler.postDelayed(it, AppWatcher.config.watchDurationMillis)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">val</span> objectWatcher = ObjectWatcher(</span><br><span class="line">      clock = clock,</span><br><span class="line">      checkRetainedExecutor = checkRetainedExecutor,</span><br><span class="line">      isEnabled = &#123; <span class="literal">true</span> &#125;</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  ···</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ObjectWatcher</code> 的 <code>moveToRetained</code> 方法又会通过 <code>onObjectRetained</code> 向外发出通知：<strong>当前可能发生了内存泄露</strong>。<code>InternalLeakCanary</code> 会收到这个通知，然后交由 <code>HeapDumpTrigger</code> 来进行检测</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">object</span> InternalLeakCanary : (Application) -&gt; <span class="built_in">Unit</span>, OnObjectRetainedListener &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> heapDumpTrigger: HeapDumpTrigger</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onObjectRetained</span><span class="params">()</span></span> = scheduleRetainedObjectCheck()</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">()</span></span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (<span class="keyword">this</span>::heapDumpTrigger.isInitialized) &#123;</span><br><span class="line">      		heapDumpTrigger.scheduleRetainedObjectCheck()</span><br><span class="line">    	&#125;</span><br><span class="line"> 	&#125;</span><br><span class="line">    </span><br><span class="line">    ···</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 LeakCanary 判定当前真的存在内存泄露时，就会进行 <strong>DumpHeap</strong>，找到泄露对象的引用链，而这个操作是比较<strong>费时费内存</strong>的，可能会直接导致应用页面无响应，所以 LeakCanary 进行 DumpHeap 前会有许多前置检查操作和前置条件，就是为了尽量减少 DumpHeap 次数以及在 DumpHeap 时尽量减少对开发人员的干扰</p>
<p> <code>heapDumpTrigger</code> 的 <code>scheduleRetainedObjectCheck()</code> 方法的主要逻辑是：</p>
<ol>
<li>获取当前还未回收的对象个数 retainedKeysCount。如果个数大于 0，则先主动触发 GC，尽量尝试回收对象，避免误判，然后执行第二步；如果个数为 0，那么流程就结束了</li>
<li>GC 过后再次更新 retainedKeysCount 值，如果对象都被回收了（即 retainedKeysCount 值为 0），那么流程就结束了，否则就执行第三步</li>
<li>如果 retainedKeysCount 小于阈值 5，且当前“应用处于前台”或者是“应用处于后台但退到后台的时间还未超出五秒”，那么就启动一个定时任务，在二十秒后重新执行第一步，否则执行第四步</li>
<li>如果上一次 DumpHeap 离现在不足一分钟，那么就启动一个定时任务，满一分钟后重新执行第一步，否则执行第五步</li>
<li>此时各个条件都满足了，已经可以确定发生了内存泄漏，去执行 DumpHeap</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="keyword">class</span> <span class="title class_">HeapDumpTrigger</span>(</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> application: Application,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> backgroundHandler: Handler,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> objectWatcher: ObjectWatcher,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> gcTrigger: GcTrigger,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> heapDumper: HeapDumper,</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">val</span> configProvider: () -&gt; Config</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">    ···</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">scheduleRetainedObjectCheck</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            delayMillis: <span class="type">Long</span> = <span class="number">0</span>L</span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> checkCurrentlyScheduledAt = checkScheduledAt</span><br><span class="line">        <span class="keyword">if</span> (checkCurrentlyScheduledAt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果当前已经在进行检测了，则直接返回</span></span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        checkScheduledAt = SystemClock.uptimeMillis() + delayMillis</span><br><span class="line">        backgroundHandler.postDelayed(&#123;</span><br><span class="line">          checkScheduledAt = <span class="number">0</span></span><br><span class="line">          checkRetainedObjects()</span><br><span class="line">        &#125;, delayMillis)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkRetainedObjects</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> iCanHasHeap = HeapDumpControl.iCanHasHeap()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> config = configProvider()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (iCanHasHeap <span class="keyword">is</span> Nope) &#123;</span><br><span class="line">            <span class="keyword">if</span> (iCanHasHeap <span class="keyword">is</span> NotifyingNope) &#123;</span><br><span class="line">                <span class="comment">// Before notifying that we can&#x27;t dump heap, let&#x27;s check if we still have retained object.</span></span><br><span class="line">                <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    gcTrigger.runGc()</span><br><span class="line">                    retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">val</span> nopeReason = iCanHasHeap.reason()</span><br><span class="line">                <span class="keyword">val</span> wouldDump = !checkRetainedCount(</span><br><span class="line">                        retainedReferenceCount, config.retainedVisibleThreshold, nopeReason</span><br><span class="line">                )</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (wouldDump) &#123;</span><br><span class="line">                    <span class="keyword">val</span> uppercaseReason = nopeReason[<span class="number">0</span>].toUpperCase() + nopeReason.substring(<span class="number">1</span>)</span><br><span class="line">                    onRetainInstanceListener.onEvent(DumpingDisabled(uppercaseReason))</span><br><span class="line">                    showRetainedCountNotification(</span><br><span class="line">                            objectCount = retainedReferenceCount,</span><br><span class="line">                            contentText = uppercaseReason</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                SharkLog.d &#123;</span><br><span class="line">                    application.getString(</span><br><span class="line">                            R.string.leak_canary_heap_dump_disabled_text, iCanHasHeap.reason()</span><br><span class="line">                    )</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取当前还未回收的对象个数</span></span><br><span class="line">        <span class="keyword">var</span> retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retainedReferenceCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//主动触发 GC，尽量尝试回收对象，避免误判</span></span><br><span class="line">            gcTrigger.runGc()</span><br><span class="line">            retainedReferenceCount = objectWatcher.retainedObjectCount</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (checkRetainedCount(retainedReferenceCount, config.retainedVisibleThreshold))</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> now = SystemClock.uptimeMillis()</span><br><span class="line">        <span class="keyword">val</span> elapsedSinceLastDumpMillis = now - lastHeapDumpUptimeMillis</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果上一次 DumpHeap 离现在不足一分钟，那么就启动一个定时任务，满一分钟后再次检查</span></span><br><span class="line">        <span class="keyword">if</span> (elapsedSinceLastDumpMillis &lt; WAIT_BETWEEN_HEAP_DUMPS_MILLIS) &#123;</span><br><span class="line">            onRetainInstanceListener.onEvent(DumpHappenedRecently)</span><br><span class="line">            showRetainedCountNotification(</span><br><span class="line">                    objectCount = retainedReferenceCount,</span><br><span class="line">                    contentText = application.getString(R.string.leak_canary_notification_retained_dump_wait)</span><br><span class="line">            )</span><br><span class="line">            scheduleRetainedObjectCheck(</span><br><span class="line">                    delayMillis = WAIT_BETWEEN_HEAP_DUMPS_MILLIS - elapsedSinceLastDumpMillis</span><br><span class="line">            )</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dismissRetainedCountNotification()</span><br><span class="line">        <span class="comment">//各个条件都满足了，已经可以确定发生了内存泄漏，去执行 DumpiHeap</span></span><br><span class="line">        dumpHeap(retainedReferenceCount, retry = <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断当前是否符合 DumpHeap 的条件，符合的话返回 false</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> retainedKeysCount 当前还未回收的对象个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> retainedVisibleThreshold 触发 DumpHeap 的阈值</span></span><br><span class="line"><span class="comment">     * 只有当 retainedKeysCount 大于等于 retainedVisibleThreshold 时才会触发 DumpHeap，默认值是 5</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nopeReason</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">checkRetainedCount</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">            retainedKeysCount: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            retainedVisibleThreshold: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">            nopeReason: <span class="type">String</span>? = <span class="literal">null</span></span></span></span><br><span class="line"><span class="params"><span class="function">    )</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="comment">//用于标记本次检测相对上次，未回收的对象个数是否发生了变化</span></span><br><span class="line">        <span class="keyword">val</span> countChanged = lastDisplayedRetainedObjectCount != retainedKeysCount</span><br><span class="line">        lastDisplayedRetainedObjectCount = retainedKeysCount</span><br><span class="line">        <span class="keyword">if</span> (retainedKeysCount == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (countChanged) &#123;</span><br><span class="line">                <span class="comment">//如果 retainedKeysCount 为 0，且值相对上次检测减少了，则说明有对象被回收了</span></span><br><span class="line">                SharkLog.d &#123; <span class="string">&quot;All retained objects have been garbage collected&quot;</span> &#125;</span><br><span class="line">                onRetainInstanceListener.onEvent(NoMoreObjects)</span><br><span class="line">                showNoMoreRetainedObjectNotification()</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//应用是否还在前台</span></span><br><span class="line">        <span class="keyword">val</span> applicationVisible = applicationVisible</span><br><span class="line">        <span class="keyword">val</span> applicationInvisibleLessThanWatchPeriod = applicationInvisibleLessThanWatchPeriod</span><br><span class="line"></span><br><span class="line">        ···</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (retainedKeysCount &lt; retainedVisibleThreshold) &#123; <span class="comment">//还未达到阈值</span></span><br><span class="line">            <span class="keyword">if</span> (applicationVisible || applicationInvisibleLessThanWatchPeriod) &#123;</span><br><span class="line">                <span class="keyword">if</span> (countChanged) &#123;</span><br><span class="line">                    onRetainInstanceListener.onEvent(BelowThreshold(retainedKeysCount))</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//在通知栏显示当前未回收的对象个数</span></span><br><span class="line">                showRetainedCountNotification(</span><br><span class="line">                        objectCount = retainedKeysCount,</span><br><span class="line">                        contentText = application.getString(</span><br><span class="line">                                R.string.leak_canary_notification_retained_visible, retainedVisibleThreshold</span><br><span class="line">                        )</span><br><span class="line">                )</span><br><span class="line">                <span class="comment">//retainedKeysCount 还未达到阈值，且当前“应用处于前台”或者是“应用处于后台但退到后台的时间还未超出五秒”</span></span><br><span class="line">                <span class="comment">//此时就启动一个定时任务，在二十秒后重新再检测一遍</span></span><br><span class="line">                scheduleRetainedObjectCheck(</span><br><span class="line">                        delayMillis = WAIT_FOR_OBJECT_THRESHOLD_MILLIS</span><br><span class="line">                )</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   ···</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更后面的流程就涉及具体的 DumpHeap 操作了，这里就不再展开了，因为我也不太懂，后续有机会再单独写一篇文章来介绍了~~</p>
<h1 id="八、小提示"><a href="#八、小提示" class="headerlink" title="八、小提示"></a>八、小提示</h1><h2 id="1、检测任意对象"><a href="#1、检测任意对象" class="headerlink" title="1、检测任意对象"></a>1、检测任意对象</h2><p>除了 LeakCanary 默认支持的四种类型外，我们还可以主动检测任意对象。例如，可以检测 Service： </p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyService</span> : <span class="type">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    AppWatcher.objectWatcher.watch(</span><br><span class="line">      watchedObject = <span class="keyword">this</span>,</span><br><span class="line">      description = <span class="string">&quot;MyService received Service#onDestroy() callback&quot;</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2、更改配置项"><a href="#2、更改配置项" class="headerlink" title="2、更改配置项"></a>2、更改配置项</h2><p>LeakCanary 提供的默认配置项大多数情况已经很适合我们在项目中直接使用了，而如果我们想要更改 LeakCanary 的默认配置项（例如不希望检测 FragmentView），可以在 Application 中进行更改：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DebugExampleApplication</span> : <span class="type">Application</span>() &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate()</span><br><span class="line">    AppWatcher.config = AppWatcher.config.copy(watchFragmentViews = <span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 LeakCanary 的引用方式是 <code>debugImplementation</code>，在 <code>releas</code> 环境下是引用不到 LeakCanary 的，所以为了避免在生成 <code>release</code> 包时需要主动来删除这行配置项，需要将 <code>DebugExampleApplication</code> 放到 <code>src/debug/java</code> 文件夹中</p>
<h1 id="九、结尾"><a href="#九、结尾" class="headerlink" title="九、结尾"></a>九、结尾</h1><p>可以看出 <strong>Activity、Fragment、FragmentView、ViewModel</strong> 等四种类型的内存检测都是需要依靠 <code>ObjectWatcher</code> 来完成的，因为这四种类型本质上都是属于不同的对象。而 <code>ObjectWatcher</code> 需要依靠引用队列 <code>ReferenceQueue</code> 来实现，因此 LeakCanary 的基本实现基础就是来源于 Java 的原生特性</p>
<p>LeakCanary 的整体源码讲得也差不多了，后边就再来写一篇关于<strong>内存泄露</strong>的扩展阅读 😂😂</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>千越</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://qianyuebits.github.io/2017/05/17/Android-LeakCanary/">https://qianyuebits.github.io/2017/05/17/Android-LeakCanary/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/Android/"># Android</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2023/04/11/%E8%AF%BB%E4%B9%A6%E7%AF%87-%E3%80%8A%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E3%80%8B/">读书篇:《高效能人士的七个习惯》</a>
            
            
            <a class="next" rel="next" href="/2014/05/25/Android-Handler/">Android Handler</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 千越 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>