<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="千越">





<title>Java 泛型 | 千越</title>



    <link rel="icon" href="/image/icon.jpeg">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">千越的博客</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">千越的博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Java 泛型</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">千越</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">2024-01-18&nbsp;&nbsp;1:31:01</a>
                        </span>
                    
                    
                        <span class="post-category">
                    Category:
                            
                                <a href="/category/%E6%8A%80%E6%9C%AF/">技术</a>
                            
                        </span>
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>泛型的目的就是在不失去类型检查的情况下尽可能的让代码宽泛起来。Java 的泛型是一个在理想主义上建立起来的残次品！</p>
<p>设想我们需要开发一个容器来存储对象，对象类型不限。第一选择可以是使用 Object:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Holder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object obj;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">getObj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj the obj to set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以达成目标，但是可能会在类型转换的时候发生异常，它不是类型安全的(转换成 Object 的时候，一定程度上丢失了类型信息)，我们在 getObj 时需要做出类型检查。</p>
<p>泛型则弥补了这一点 —— 它一开始在使用容器的时候就要求你确定容器所装元素的类型，这就是泛型（顾名思义，不限类型），这样既可以消除类型转换，也可以在编译时提供类型检查：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericContainer</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> T obj;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericContainer</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Pass type in as parameter to constructor</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericContainer</span><span class="params">(T t)</span>&#123;</span><br><span class="line">        obj = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the obj</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getObj</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> obj the obj to set</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setObj</span><span class="params">(T t)</span> &#123;</span><br><span class="line">        obj = t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不得不说：集合是一个非常特殊的例子 —— Object 的定义明显太过宽泛，同时 Interface 并不能概括所有的情况。从以上情况看，它主要有以下几个好处：<br>1、编译时更强的类型的检查；<br>2、消除类型转换；<br>3、开发者可以实现泛型算法；</p>
<p>然而实际上泛型的目标并不止于此，上面说的泛型是 Java 中泛型的意义。在 TIJ 本章开始和结尾的地方，作者都描述了泛型的根本目标 —— <strong>在进行静态检查的同时，使我们的代码可以尽可能的宽泛（即可以使用在更多的地方）</strong>。</p>
<h1 id="泛型的形式"><a href="#泛型的形式" class="headerlink" title="泛型的形式"></a>泛型的形式</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Generator</span>&lt;T&gt; &#123; T <span class="title function_">next</span><span class="params">()</span>; &#125;</span><br><span class="line"><span class="comment">// 泛型方法 —— 如果泛型只用于这个方法上，则需要在方法返回值前面使用相关字符显示用到的泛型，如下&lt;T&gt;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="title function_">makeList</span><span class="params">(T... args)</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 继承泛型类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Colored</span>&lt;T <span class="keyword">extends</span> <span class="title class_">HasColor</span>&gt; <span class="keyword">extends</span> <span class="title class_">HoldItem</span>&lt;T&gt;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TupleList</span>&lt;A,B,C,D&gt; <span class="keyword">extends</span> <span class="title class_">ArrayList</span>&lt;FourTuple&lt;A,B,C,D&gt;&gt;</span><br></pre></td></tr></table></figure>
<p>除了上面这两种简单的用法，泛型还可以添加边界，即使用 <code>super</code> 和 <code>extends</code> 两个关键字。类型擦除中说到泛型不具备协变能力，那么如何来描述或者补偿协变能力呢 —— Wildcards（通配符）！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">Fruit</span>&gt; flist = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Apple&gt;();</span><br></pre></td></tr></table></figure>
<p>flist 可以理解为一个存储着任何继承 Fruit 类型对象的 list，但这并不意味着他可以存储任何类型的 Fruit，因为这里存在着一个冲突：这个通配符实际的含义是，flist 确实指向一个只能存储特定类型的对象的 List，但是 flist 这个引用并没有指明具体是什么类型（flist 的含义如前面所说）！<br>既然如此，flist 完全可以指向 Fruit 的特定的子类，这就造成向 flist 中添加任何的 Fruit 类和其子类的对象都变得不可行！（编译器在编译器并不知道这个 flist 指向的具体 List 类型）</p>
<p>因此，如下是错误的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="keyword">extends</span> <span class="title class_">A</span>&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;A&gt;();</span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">A</span>()); <span class="comment">// ERROR</span></span><br></pre></td></tr></table></figure>
<p>但是从 list 里面拿出来的对象是可以调用 A 类的所有方法的，这是安全的。</p>
<p>除了对协变有补偿，对于逆变，Java 也有补偿，这就是 super 关键字。例子如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="built_in">super</span> Apple&gt; apples</span><br></pre></td></tr></table></figure>
<p>这个 List 表示存储着任何 Apple 类的基类。因此它存储 Apple 以及 Apple 的子类是安全的（编译无错误），但是存储 Fruit 就是错误的，因为如果这样存储，整个 List 就对 Apple 的所有父类开放，将失去静态类型安全检查（Apple 可能有多层继承，实现了多个接口）。从 apples 中提取的 element 只可以调用 Object 的方法。<br>因此如下是错误的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;? <span class="built_in">super</span> A&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;A&gt;();</span><br><span class="line"><span class="type">A</span> <span class="variable">a</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// ERROR，它是个 Object。</span></span><br></pre></td></tr></table></figure>
<p>为什么不能用 A 去引用呢？要注意 super 的含义！因为可能存在以下赋值：List&lt;? super A&gt; list3 &#x3D; new ArrayList<Object>();</p>
<p>还有以下情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">A</span>()); <span class="comment">// OK —— 子类是 OK 的，获取出来也只能是 Object</span></span><br><span class="line">list.add(<span class="keyword">new</span> <span class="title class_">Object</span>()); <span class="comment">// ERROR —— 添加父类是不行的，因为不知道实际存储的是哪个父类</span></span><br></pre></td></tr></table></figure>

<p>所以虽然 list 表示存储着 A 的基类，但首先，这个基类没有被明显表示出来，因此不能再添加元素，也因为没有指明，因此拿出来的元素不知道具体的类型，只能是 Object 而不能是 A，因为从 A 的基类到 A 的转换是不安全的。<br>注意，只有”? super”这种形式，不存在 T super 的形式，因此，在泛型类声明的时候不能使用 super。<br>注意：<code>new ArrayList&lt;? super A&gt;();</code> &amp; <code>new ArrayList&lt;? extends A&gt;();</code> 是不允许的。实例化的必须是一个实际的内容，通配符不行（想象一下传参）。</p>
<h1 id="Latent-Typing"><a href="#Latent-Typing" class="headerlink" title="Latent Typing"></a>Latent Typing</h1><p>我们可以使用泛型写出一个可以容纳任何对象的 Holder。但是因为类型擦除，当我们需要使用类型的行为特征的时候，却必须为此加上一个 bound，这就对 Java 泛型造成了明显的限制 —— 在某些情况下，我们可以使用一个普通类或者接口去替代泛型，因为两者可能并没有区别。（泛型用于返回值的时候会不太一样）。</p>
<p>一些语言对此的解决方案就是 Duck Typing（如果一个东西走起路来像鸭子，叫起来像鸭子，那么我就可以当它是一只鸭子）。泛型代码通常只会调用泛型类型的若干方法（属性可以通过方法访问）。一个使用 Latent typing 的语言通过只要求泛型类型实现这几个方法而非一定要是某个 class 或者 interface 来放松类型要求。由此，latent typing 允许不去使用继承或者接口实现。所以一段代码就可以做到：我不关心你是什么类型，你只需要可以 speak() 和 <code>sit()</code> 就可以了 —— 这样，你的代码就更加宽泛了。</p>
<blockquote>
<p>编译器如果能这样检查，确实更为高级，实际上已经不叫泛型，因为已经超出类型了。</p>
</blockquote>
<p>Latent typing 是一个代码组织和重用机制。使用 Latent typing，一段代码就可以尽可能在更多的地方被使用。C++ 和 Python 中都可实现了 Latent typing。其中 C++ 是在编译时检查类型是否正确，而 Python 则是在运行时检查，两者都是强类型的。</p>
<p>因为 Java 中的泛型是后期加上去的，因此并不能支持这种 latent typing —— 变得略泛型。在 Java 上，如果要表明一个类型既可以 <code>speak()</code>，又可以 <code>sit()</code>，那就必须声明一个接口，而一旦声明接口，那么后续的合作代码其实可以不用再用泛型，而是用接口去代替。</p>
<h1 id="泛型擦除"><a href="#泛型擦除" class="headerlink" title="泛型擦除"></a>泛型擦除</h1><p>泛型信息只存在于代码编译阶段，但是在运行期(已经生成字节码文件后)与泛型相关的信息会被擦除掉。即 <code>ArrayList.class</code>，却没有 <code>ArrayList&lt;Integer&gt;.class</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ErasedTypeEquivalence</span> &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().getClass();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;().getClass();</span><br><span class="line">        System.out.println(c1 == c2);</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Output:</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这就是类型擦除 —— 用于具体化泛型的参数信息会抹除掉，我们只能拿到最原始的类型信息。我们可以使用 <code>Class.getTypeParameters()</code> 来获取泛型类的泛型类型，听上去好像可以获得泛型参数的类型，而实际上并没有，只能获取到泛型列表：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;().getClass();</span><br><span class="line"><span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;().getClass();</span><br><span class="line">System.out.println(Arrays.toString(c1.getTypeParameters())); <span class="comment">// [E]</span></span><br><span class="line">System.out.println(Arrays.toString(c2.getTypeParameters())); <span class="comment">// [E]</span></span><br><span class="line">System.out.println(Arrays.toString(c3.getTypeParameters())); <span class="comment">// [K, V]</span></span><br></pre></td></tr></table></figure>

<p>因为类型擦除，因此在泛型代码中就无法判断泛型类型具备哪些接口（C++ 的模板中是存储这个类型的），因此如果你需要在泛型代码中调用泛型类型的一个方法，就需要为泛型加上 bounds，即限定条件，比如<code>&lt;T extends HasF&gt;</code>。（C++ 就不需要，它只需要有这个方法即可，编译器会自动检查）。</p>
<p>前面说了泛型类型会被擦除，因此像 <code>&lt;T extends HasF&gt;</code> 会被擦除为 <code>HasF</code> —— 即所有的泛型 T 出现的地方都会被替换为 <code>HasF</code>。这就展示了一个很重要的点 —— 泛型只有在你想要使用一个比具体类（以及所有它的子类型）更宽泛的类型的时候才有用，简言之，基类、抽象类甚至接口已经不能满足需求的时候才有用。</p>
<p>如上，如果泛型参数有限定，即<code>&lt;T extends HasF&gt;</code>，则会使用第一个边界泛型参数来替换变量，比如将 T 替换成 <code>HasF</code>（可能有多个限定，比如<code>&lt;T extends Comparable &amp; Serializable&gt;</code>，会被替换为 <code>Comparable</code>），如果没有限定，直接是 <code>&lt;T&gt;</code>，则会被替换成 Object。</p>
<p>既然类型可以被擦除，那么任意的对象其实都可以被存入 <code>ArrayList&lt;String&gt;</code> 中去，但是为什么会报错呢？这说明编译器在编译期就对泛型进行了检查。泛型的整个检查会编译期完成，这就是下面代码的解释：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- ArrayList&lt;String&gt; arrayList1=<span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">- arrayList1.add(<span class="string">&quot;1&quot;</span>);<span class="comment">//编译通过</span></span><br><span class="line">- arrayList1.add(<span class="number">1</span>);<span class="comment">//编译错误</span></span><br><span class="line">- String str1=arrayList1.get(<span class="number">0</span>);<span class="comment">//返回类型就是String</span></span><br><span class="line">-</span><br><span class="line">- ArrayList arrayList2=<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">- arrayList2.add(<span class="string">&quot;1&quot;</span>);<span class="comment">//编译通过</span></span><br><span class="line">- arrayList2.add(<span class="number">1</span>);<span class="comment">//编译通过</span></span><br><span class="line">- Object object=arrayList2.get(<span class="number">0</span>);<span class="comment">//返回类型就是Object</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是：类型擦除并不是语言特性，即不是 Java 故意这么做的，因为一开始泛型就不在 Java 的考虑范围内，后期又要实现泛型，因此这是一个折中。但是正是因为类型擦除，才导致 Java 的泛型不能那么“泛”。</p>
<p>类型擦除的核心动机就是为了使用非泛型的库 —— 这得保证它们最终编译出来的字节码一致，但是早期的 Java 就是没有保持所谓的泛型类型信息，因此就算 Java 添加了泛型，也不能完全的实现这个特性，必须做擦除 —— 向后兼容。如果保存泛型类型信息，则旧库无法使用，因此 <code>List&lt;T&gt;</code> 必须编译成 List。—— 这是类型擦除存在的第一原因。</p>
<p>类型擦除除了前面提到的问题，还有什么问题呢？类型擦除其实意味着所有有关 T 的信息全部丢失，因此类似 cast、instanceof 和 new 等操作都不能使用 T（注意，并不是 T instanceof ClassA 不行，而是 InstanceA instanceof T 不行）:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Erased</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">SIZE</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(Object arg)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(arg <span class="keyword">instanceof</span> T) &#123;&#125;;<span class="comment">//ERROR</span></span><br><span class="line">            <span class="type">T</span> <span class="variable">var</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">T</span>();<span class="comment">//ERROR</span></span><br><span class="line">            T[] array = <span class="keyword">new</span> <span class="title class_">T</span>[SIZE];<span class="comment">//ERROR</span></span><br><span class="line">            T[] array = (T)<span class="keyword">new</span> <span class="title class_">Object</span>[SIZE]; <span class="comment">// Unchecked warning</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译器在这方面很智能：它理解你的用意，同时阻止你犯愚蠢的错误。按照【类型擦除代码javap示例】中描述的，其实 T 最终会被替换成 Object，因此类似 instanceof，new 的操作实际上是没有问题的（编译成字节码之后是可以运行的），但是这并不是开发者的实际意图，开发者实际是想创建 T 所代表的实际类型的实例，判断是不是 T 所代表的实际类型，这样的编码，Java 编译器直接从编译阶段就报错。</p>
<p>Sometimes even an interface is too restrictive. An interface still requires that your code work with that particular interface. You could write even more general code if you could say that your code works with “some unspecified type,” rather than a specific interface or class.<br>有些时候，要求实现一个接口还是太拘束了，我们的代码可以变得更加宽泛，如果某段代码只需要一个类具备某些行为而非要求它是一个特定的类。</p>

        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>千越</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://qianyuebits.github.io/2024/01/18/Java-Generics/">https://qianyuebits.github.io/2024/01/18/Java-Generics/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/Java/"># Java</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/2024/01/18/Java-ConcurrentHashMap/">Java ConcurrentHashMap</a>
            
            
            <a class="next" rel="next" href="/2024/01/17/Java-Memory-Management/">Java 内存管理</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 千越 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>