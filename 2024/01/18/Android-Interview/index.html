<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="千越">





<title>Android 面试（持续 Update） | 千越</title>



    <link rel="icon" href="/image/icon.jpeg">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">千越的博客</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">千越的博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Android 面试（持续 Update）</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">千越</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">2024-01-18&nbsp;&nbsp;22:43:03</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://javaguide.cn/home.html">JavaGuide（Java学习&amp;面试指南）</a></li>
</ol>
<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="算法-amp-数据结构"><a href="#算法-amp-数据结构" class="headerlink" title="算法 &amp; 数据结构"></a>算法 &amp; 数据结构</h2><h4 id="⭐️-快速排序-amp-amp-冒泡排序"><a href="#⭐️-快速排序-amp-amp-冒泡排序" class="headerlink" title="⭐️ 快速排序 &amp;&amp; 冒泡排序"></a>⭐️ 快速排序 &amp;&amp; 冒泡排序</h4><p>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序算法</a><br>关键点：</p>
<ol>
<li>快速排序是不稳定的，平均复杂度 O(nlogn)，冒泡排序是稳定的，平均复杂度 O(n^2)；</li>
<li>快速排序又是一种分而治之思想在排序算法上的典型应用，使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）；</li>
<li>手写快排：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/description/">Leetcode</a>；</li>
</ol>
<blockquote>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>
<h4 id="⭐️-链表？"><a href="#⭐️-链表？" class="headerlink" title="⭐️ 链表？"></a>⭐️ 链表？</h4><p>相关问题：在 Leetcode 上均可找到对应题目。</p>
<ol>
<li>环形链表判断：<ul>
<li>一快一慢指针，形象的来说，等于慢指针走在前面，快指针走在后面（因为有环），但是快指针每次都比慢指针多走一格，在有序靠近慢指针；</li>
<li><strong>找入口？</strong> 在快慢指针相遇的地方，定义一个指针；再定义一个指针指向链表头，同时前进，相遇的地方即环入口，推导详见：<a target="_blank" rel="noopener" href="https://programmercarl.com/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.html#%E7%AE%97%E6%B3%95%E5%85%AC%E5%BC%80%E8%AF%BE">环形链表II</a></li>
</ul>
</li>
<li>链表相交判断（有环、无环）：<ul>
<li>如果两个无环，直接判断最后一个节点是否一样；</li>
<li>如果一个无环，一个有环，则肯定不相交（否则肯定两个都是环）；</li>
<li>如果两个都是环，寻找两个环的入口，在一个环中遍历寻找是否存在另外一个环的入口；</li>
</ul>
</li>
<li>反转单链表；</li>
<li>移除链单&#x2F;双表节点；</li>
<li>链表中间节点；</li>
</ol>
<p>注意活用双指针。</p>
<h4 id="⭐️-谈谈你对时间复杂度和空间复杂度的理解？"><a href="#⭐️-谈谈你对时间复杂度和空间复杂度的理解？" class="headerlink" title="⭐️ 谈谈你对时间复杂度和空间复杂度的理解？"></a>⭐️ 谈谈你对时间复杂度和空间复杂度的理解？</h4><p>针对同一问题，可以有很多种算法来解决，但不同的算法在效率和占用存储空间上的区别可能会很大。那么，通过什么指标来衡量算法的优劣呢？其中，上面提到的效率可以用算法的时间复杂度来描述，而所占用的存储空间可以用算法的空间复杂度来描述。</p>
<ul>
<li>时间复杂度：用于评估执行程序所消耗的时间，可以估算出程序对处理器的使用程度。</li>
<li>空间复杂度：用于评估执行程序所占用的内存空间，可以估算出程序对计算机内存的使用程度。</li>
</ul>
<h4 id="⭐️-什么是红黑树？为什么要用红黑树？❓"><a href="#⭐️-什么是红黑树？为什么要用红黑树？❓" class="headerlink" title="⭐️ 什么是红黑树？为什么要用红黑树？❓"></a>⭐️ 什么是红黑树？为什么要用红黑树？❓</h4><p><strong>一种自平衡二叉查找树</strong>。它的性质参见 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">Wiki</a>：</p>
<ol>
<li>根是黑色</li>
<li>节点是红色或黑色</li>
<li>所有叶子都是黑色（叶子是 null 节点）</li>
<li>每个红色节点必须有两个黑色的子节点。（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点。）（或者说不存在两个相邻的红色节点，相邻指两个节点是父子关系。）（或者说红色节点的父节点和子节点均是黑色的。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</li>
</ol>
<p>红黑树并不是一颗 AVL 平衡二叉搜索树：平衡二叉搜索树（英语：Balanced Binary Search Tree）是一种结构平衡的二叉搜索树，它是一种每个节点的左右两子树高度差都不超过 1 的二叉树。但是根据性质 5，它的黑色节点满足平衡，又被称为<strong>黑色完美平衡</strong>。</p>
<p><strong>红黑树相对于 AVL 树来说，牺牲了部分平衡性以换取插入和删除操作时少量的旋转操作，整体来说性能要优于 AVL 树。</strong></p>
<h4 id="⭐️-如何从一百万个数里面找到最小的一百个数，考虑算法的时间复杂度和空间复杂度❓"><a href="#⭐️-如何从一百万个数里面找到最小的一百个数，考虑算法的时间复杂度和空间复杂度❓" class="headerlink" title="⭐️ 如何从一百万个数里面找到最小的一百个数，考虑算法的时间复杂度和空间复杂度❓"></a>⭐️ 如何从一百万个数里面找到最小的一百个数，考虑算法的时间复杂度和空间复杂度❓</h4><p>TopK 问题，类似的有：</p>
<ol>
<li>最小的 k 个数；</li>
<li>数组中的第 K 个最大元素；</li>
</ol>
<p>常见解决方法：</p>
<ol>
<li>整体排序：O(nlogn)；</li>
<li>局部排序：只冒泡排序前 k 个最大值，O(n*k)；</li>
<li>利用堆：O(nlogk)</li>
<li>优化：快速选择（quickselect）算法</li>
<li>分治法</li>
</ol>
<h4 id="⭐️-二叉树前序-x2F-中序-x2F-后序-x2F-层次遍历"><a href="#⭐️-二叉树前序-x2F-中序-x2F-后序-x2F-层次遍历" class="headerlink" title="⭐️ 二叉树前序&#x2F;中序&#x2F;后序&#x2F;层次遍历"></a>⭐️ 二叉树前序&#x2F;中序&#x2F;后序&#x2F;层次遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">Leetcode</a></p>
<ol>
<li>前序&#x2F;中序&#x2F;后序 三者属于深度优先搜索，均可使用递归来实现；</li>
<li>层次遍历属于广度优先搜索（BFS）的方法，可用队列实现；</li>
</ol>
<h4 id="⭐️-判断平衡二叉树"><a href="#⭐️-判断平衡二叉树" class="headerlink" title="⭐️ 判断平衡二叉树"></a>⭐️ 判断平衡二叉树</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/description/">Leetcode</a><br>关键点：双层递归</p>
<ol>
<li>按照 AVL 的定义，递归判断树的每个节点是否符合要求；</li>
<li>在判断每个节点是否符合要求时，需要递归获取它左右节点的子树高度；</li>
</ol>
<h4 id="⭐️-手写生产者-x2F-消费者模式（并发同步问题）❓"><a href="#⭐️-手写生产者-x2F-消费者模式（并发同步问题）❓" class="headerlink" title="⭐️ 手写生产者&#x2F;消费者模式（并发同步问题）❓"></a>⭐️ 手写生产者&#x2F;消费者模式（并发同步问题）❓</h4><ol>
<li>关键：两把锁，一把用于表示队列是否满，一把用于表示队列是否空；</li>
<li>手撸代码，变种在于使用不同的加锁方式，比如 <code>BlockingQueue</code>，信号量；</li>
</ol>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h4 id="⭐️-TCP-三次握手、四次挥手（为什么是三次握手不是两次握手？）"><a href="#⭐️-TCP-三次握手、四次挥手（为什么是三次握手不是两次握手？）" class="headerlink" title="⭐️ TCP 三次握手、四次挥手（为什么是三次握手不是两次握手？）"></a>⭐️ TCP 三次握手、四次挥手（为什么是三次握手不是两次握手？）</h4><p><code>TCP（Transmission Control Protocol）</code>是一种可靠的传输协议，用于在计算机网络中建立可靠的连接。TCP 使用三次握手（Three-Way Handshake）来建立连接，以及四次挥手（Four-Way Handshake）来关闭连接。</p>
<p>三次握手的过程如下：</p>
<ol>
<li>第一步（SYN）：客户端发送一个 SYN（同步）报文段给服务器，其中包含一个随机初始序列号（ISN）和请求建立连接的标志位。</li>
<li>第二步（SYN-ACK）：服务器收到客户端的 SYN 报文段后，会发送一个 SYN-ACK 报文段给客户端。该报文段中会包含确认号（ACK）和服务器的 ISN，同时也会确认客户端的 SYN 报文段。</li>
<li>第三步（ACK）：客户端收到服务器的 SYN-ACK 报文段后，会发送一个确认报文段给服务器，确认号为服务器的 ISN 加 1。这个报文段的发送完成后，连接就建立起来了。</li>
</ol>
<p>四次挥手的过程如下：</p>
<ol>
<li>第一步（FIN）：当客户端决定关闭连接时，发送一个 FIN（结束）报文段给服务器，表示客户端不再发送数据。</li>
<li>第二步（ACK）：服务器收到客户端的 FIN 报文段后，会发送一个确认报文段给客户端，确认客户端的 FIN 报文段。</li>
<li>第三步（FIN）：服务器也决定关闭连接时（之前可能还要发送数据），会发送一个 FIN 报文段给客户端，表示服务器不再发送数据。</li>
<li>第四步（ACK）：客户端收到服务器的 FIN 报文段后，发送一个确认报文段给服务器，确认服务器的 FIN 报文段。此时，连接就完全关闭了。</li>
</ol>
<p>通过三次握手，双方能够确认彼此的状态并同意建立连接。而四次挥手则是为了安全地关闭连接，确保数据的可靠传输。</p>
<p><strong>可以二次握手吗？</strong><br>主要为了防止已失效的连接请求报文段突然又传送到了 B，因而产生错误。如 A 发出连接请求，但因连接请求报文丢失而未收到确认，于是 A 再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，A 工发出了两个连接请求报文段，其中第一个丢失，第二个到达了 B，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达 B，此时 B 误认为 A 又发出一次新的连接请求，于是就向 A 发出确认报文段，同意建立连接，不采用三次握手，只要 B 发出确认，就建立新的连接了，此时 A 不理睬 B 的确认且不发送数据，则 B 一致等待 A 发送数据，浪费资源。</p>
<p>为什么断开连接需要四次挥手呢？<br>TCP协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工 模式，这就意味着，在客户端想要断开连接时，客户端向服务端发送 FIN 报文，只是表示客户端已经没有数据要发送了，但是这个时候客户端还是可以接收来自服务端的数据。<br>当服务端接收到 FIN 报文，并返回 ACK 报文，表示服务端已经知道了客户端要断开连接，客户端已经没有数据要发送了，但是这个时候服务端可能依然有数据要传输给客户端。<br>当服务端的数据传输完之后，服务端会发送 FIN 报文给客户端，表示服务端也没有数据要传输了，服务端同意关闭连接，之后，客户端收到 FIN 报文，立即发送给客户端一个 ACK 报文，确定关闭连接。在之后，客户端和服务端彼此就愉快的断开了这次的 TCP 连接。</p>
<h4 id="⭐️-介绍一下-Http-协议"><a href="#⭐️-介绍一下-Http-协议" class="headerlink" title="⭐️ 介绍一下 Http 协议"></a>⭐️ 介绍一下 Http 协议</h4><p>HTTP（Hypertext Transfer Protocol）是一种用于在客户端和服务器之间传输数据的应用层协议。它是互联网上最常用的协议之一，用于在 Web 浏览器和 Web 服务器之间传输超文本和其他资源。</p>
<p>以下是 HTTP 协议的一些特点和主要特性：</p>
<ol>
<li>状态无关性：HTTP 是一种无状态协议，即每个请求-响应对之间没有任何关联。服务器在处理请求并发送响应后，不会保留任何关于前一次请求的信息。这导致每个请求都是独立的，服务器无法直接识别请求的来源。</li>
<li>请求-响应模型：HTTP 使用请求-响应模型进行通信。客户端发送一个 HTTP 请求到服务器，服务器处理请求并返回一个 HTTP 响应。请求和响应都包含了一些元数据，如请求方法（GET、POST 等）、URL、协议版本、请求头、响应状态码等。</li>
<li>简单灵活：HTTP 的设计目标之一是简单性和可扩展性。它定义了一组基本的请求方法（如 GET、POST、PUT、DELETE）和响应状态码（如 200 OK、404 Not Found），同时允许通过扩展头部字段和自定义方法来满足不同的需求。</li>
<li>明文传输：HTTP 默认以明文方式传输数据，即数据不经过加密处理。这使得 HTTP 在传输过程中存在安全风险，因为第三方可以截获和窃听通信的内容。为了解决这个问题，通常使用 HTTPS 来对 HTTP 进行加密和身份验证。</li>
<li>无连接性：每个 HTTP 请求都是独立的，服务器在处理完请求后关闭与客户端的连接。这意味着服务器不会保持与客户端之间的持久连接，每个请求需要重新建立连接。</li>
<li>资源定位：HTTP 使用统一资源定位符（URL）来标识和定位网络上的资源。通过使用 URL，客户端可以指定要请求的资源的位置和路径。</li>
</ol>
<h4 id="⭐️-请简述-Http-与-Https-的区别？"><a href="#⭐️-请简述-Http-与-Https-的区别？" class="headerlink" title="⭐️ 请简述 Http 与 Https 的区别？"></a>⭐️ 请简述 Http 与 Https 的区别？</h4><p>HTTP（Hypertext Transfer Protocol）和 HTTPS（Hypertext Transfer Protocol Secure）是两种在计算机网络中用于传输数据的协议，它们有以下几个主要区别：</p>
<ol>
<li>安全性：HTTP 是明文传输协议，数据在传输过程中不经过加密处理，容易被中间人窃听和篡改。而 HTTPS 使用 SSL&#x2F;TLS 协议对通信进行加密，保护数据的安全性和完整性，使得数据在传输过程中更加安全；</li>
<li>默认端口：HTTP 使用默认端口 80 进行通信，而 HTTPS 使用默认端口 443。这使得服务器能够根据端口号来区分使用不同协议的请求；</li>
</ol>
<h4 id="⭐️-请简述一次-Http-网络请求的过程？"><a href="#⭐️-请简述一次-Http-网络请求的过程？" class="headerlink" title="⭐️ 请简述一次 Http 网络请求的过程？"></a>⭐️ 请简述一次 Http 网络请求的过程？</h4><p>一次 HTTP 网络请求的过程可以概括为以下步骤：</p>
<ul>
<li>建立连接：客户端（如浏览器）与服务器建立 TCP 连接。TCP 是一种可靠的传输协议，用于在网络上建立可靠的数据传输通道。</li>
<li>发起请求：客户端向服务器发送 HTTP 请求。请求包括请求方法（如 GET、POST）、URL、请求头（如 Accept、User-Agent）和请求正文（对于 POST 请求）等信息。</li>
<li>服务器处理请求：服务器接收到请求后，根据请求的 URL 和方法来处理请求。服务器可能会验证身份、读取请求的数据、查询数据库等。</li>
<li>服务器响应：服务器生成 HTTP 响应，并将响应发送回客户端。响应包括响应状态码（如 200 OK、404 Not Found）、响应头（如 Content-Type、Cache-Control）和响应正文等信息。</li>
<li>数据传输：服务器将响应的数据通过建立的 TCP 连接发送回客户端。数据被分割为多个 TCP 数据包进行传输，并在接收端进行重新组装。</li>
<li>客户端处理响应：客户端接收到响应后，根据响应的状态码和响应头来处理响应。客户端可能会解析响应的数据、渲染页面、执行 JavaScript 等操作。</li>
<li>关闭连接：一旦请求和响应的数据传输完成，客户端和服务器之间的 TCP 连接可以被关闭。这释放了网络资源，并结束了这次请求-响应周期。</li>
</ul>
<p>这里面缺了 DNS 解析、序列化、TCP 数据传输方式的解释。</p>
<h4 id="⭐️-计算机网络中的重定向是什么"><a href="#⭐️-计算机网络中的重定向是什么" class="headerlink" title="⭐️ 计算机网络中的重定向是什么"></a>⭐️ 计算机网络中的重定向是什么</h4><p>在计算机网络中，重定向（Redirect）是一种机制，用于将请求从一个 URL（统一资源定位符）转发到另一个 URL。当客户端发送一个请求到服务器时，服务器可以返回一个特殊的响应，其中包含新的URL。客户端会根据这个新的URL重新发送请求，从而实现请求的重定向。</p>
<p>重定向通常用于以下情况：</p>
<ol>
<li>资源被移动：当一个资源（如网页、文件等）在服务器上的位置发生变化时，服务器可以返回一个重定向响应，指示客户端去访问新的位置。这对于维护网站结构和改变资源的 URL 是非常有用的。</li>
<li>负载均衡：在负载均衡环境中，多个服务器共同处理请求。当一个服务器接收到请求时，它可以返回一个重定向响应，将请求转发到其他服务器上，从而实现负载均衡。</li>
<li>认证和授权：在需要进行身份验证或授权的情况下，服务器可以返回一个重定向响应，将客户端引导到认证页面或授权页面，以便进行相应的操作。</li>
</ol>
<p>重定向使用 HTTP 响应状态码来指示重定向类型。常见的重定向状态码有：</p>
<ul>
<li><code>301 Moved Permanently</code>：永久重定向，表示资源已永久移动到新的 URL。</li>
<li><code>302 Found / 307 Temporary Redirect</code>：临时重定向，表示资源暂时移动到新的 URL。</li>
<li><code>303 See Other</code>：表示客户端应该使用 GET 方法重定向到新的 URL。</li>
<li><code>304 Not Modified</code>：表示资源未修改，客户端可以使用缓存的版本。</li>
</ul>
<p>当客户端收到重定向响应时，它会根据新的 URL 发起新的请求。这个过程对于用户是透明的，因为它们会自动被重定向到新的位置。重定向是网络应用中常用的机制，它允许服务器和客户端之间进行灵活的资源操作和导航。</p>
<h4 id="⭐️-断点下载如何实现？"><a href="#⭐️-断点下载如何实现？" class="headerlink" title="⭐️ 断点下载如何实现？"></a>⭐️ 断点下载如何实现？</h4><p>关键点：</p>
<ol>
<li><code>Accept-Ranges</code> 判断服务器是否支持断点下载，值为 bytes 表示支持；</li>
<li>请求 Header 字段 <code>Range</code>，响应 Header 字段 <code>Content-Range</code></li>
<li>同时通过 <code>Etag</code>&#x2F;<code>Last-Modified</code>&#x2F;<code>If-Range</code> Header 来判断资源是否有变化</li>
</ol>
<p>参见：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b1c62273cf82">断点续传和分片上传</a></p>
<p>上传无协议支持，可以自己想办法实现：比如将文件切分为固定大小的小文件，先分开上传，再合并。</p>
<h4 id="⭐️-假如让你实现断点上传功能，你认为应该怎样去做？"><a href="#⭐️-假如让你实现断点上传功能，你认为应该怎样去做？" class="headerlink" title="⭐️ 假如让你实现断点上传功能，你认为应该怎样去做？"></a>⭐️ 假如让你实现断点上传功能，你认为应该怎样去做？</h4><p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904046436843527">字节跳动面试官：请你实现一个大文件上传和断点续传</a></p>
<h4 id="keep-alive-的作用"><a href="#keep-alive-的作用" class="headerlink" title="keep-alive 的作用"></a><code>keep-alive</code> 的作用</h4><h4 id="Http-2-0-介绍"><a href="#Http-2-0-介绍" class="headerlink" title="Http 2.0 介绍"></a>Http 2.0 介绍</h4><p>参见：<a target="_blank" rel="noopener" href="https://web.dev/articles/performance-http2?hl=zh-cn">HTTP&#x2F;2 简介</a><br>前身为 Google 的 SPDY 协议，特点：</p>
<ol>
<li>Header 压缩；</li>
<li>同一连接上多路复用；</li>
<li>支持请求优先级设定；</li>
<li>二进制分帧：一个请求&#x2F;响应消息分成多个帧在同一个连接&#x2F;流上传输；</li>
<li>服务器能够针对单个客户端请求发送多个响应（Push）；</li>
</ol>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="⭐️-数据库索引、事务的概念"><a href="#⭐️-数据库索引、事务的概念" class="headerlink" title="⭐️ 数据库索引、事务的概念"></a>⭐️ 数据库索引、事务的概念</h4><p>索引是一种特殊的文件，包含着对数据表里所有记录的引用指针，可以对表中的一列或者多列创建索引，并指定索引的类型，各类索引有各自的数据结构实现，比如 B+ 树。使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据，因此能加快数据库的查询速度。</p>
<p>数据库事务通常包含了一个序列的对数据库的读&#x2F;写操作，这些操作要么一起成功，要么一起失败（中间异常会回滚）。数据库事务拥有以下四个特性，习惯上被称之为 ACID 特性：</p>
<ol>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行；</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束；</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行；</li>
<li>持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中；</li>
</ol>
<h4 id="⭐️-关系型数据库中的主键是什么"><a href="#⭐️-关系型数据库中的主键是什么" class="headerlink" title="⭐️ 关系型数据库中的主键是什么"></a>⭐️ 关系型数据库中的主键是什么</h4><p>在关系型数据库中，主键（Primary Key）能够少数标识数据表中的一行记录。主键可以包含数据表中的一列或者多列，主键不能为空。同时，在同一个数据表中，主键列上不能有两行甚至多行相同的值，也就是说，在同一个数据表中，每行数据对应的主键列的值必须少数。</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h4 id="⭐️-分别讲讲-final，static，synchronized，Java-静态方法是否可以被重写"><a href="#⭐️-分别讲讲-final，static，synchronized，Java-静态方法是否可以被重写" class="headerlink" title="⭐️ 分别讲讲 final，static，synchronized，Java 静态方法是否可以被重写"></a>⭐️ 分别讲讲 <code>final</code>，<code>static</code>，<code>synchronized</code>，Java 静态方法是否可以被重写</h4><p>静态方法不可以被重写</p>
<h4 id="⭐️-Java-中有哪几种变量修饰符，有什么区别，protected-是否是包级可见的"><a href="#⭐️-Java-中有哪几种变量修饰符，有什么区别，protected-是否是包级可见的" class="headerlink" title="⭐️ Java 中有哪几种变量修饰符，有什么区别，protected 是否是包级可见的"></a>⭐️ Java 中有哪几种变量修饰符，有什么区别，<code>protected</code> 是否是包级可见的</h4><p><code>package</code> 才是。</p>
<h4 id="⭐️-synchronized-对普通方法、静态方法加锁有什么区别"><a href="#⭐️-synchronized-对普通方法、静态方法加锁有什么区别" class="headerlink" title="⭐️ synchronized 对普通方法、静态方法加锁有什么区别"></a>⭐️ <code>synchronized</code> 对普通方法、静态方法加锁有什么区别</h4><p>对象锁 VS 类锁</p>
<h4 id="⭐️-抽象类与接口的区别？"><a href="#⭐️-抽象类与接口的区别？" class="headerlink" title="⭐️ 抽象类与接口的区别？"></a>⭐️ 抽象类与接口的区别？</h4><ol>
<li>接口只有定义，不能有方法的实现，java 1.8 中可以定义 <code>default</code> 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现；</li>
<li>实现接口的关键字为 <code>implements</code>，继承抽象类的关键字为 <code>extends</code>。一个类可以实现多个接口，但一个类只能继承一个抽象类；</li>
<li>接口强调特定功能的实现，而抽象类强调所属关系；</li>
<li>接口成员变量默认为 <code>public static final</code>，必须赋初值，不能被修改；其所有的成员方法都是 <code>public</code>、<code>abstract</code> 的。抽象类中除了抽象方法，其余与普通方法无异，而抽象方法被 <code>abstract</code> 修饰，不能被 <code>private</code>、<code>static</code>、<code>synchronized</code> 和 <code>native</code> 等修饰，必须以分号结尾，不带花括号；</li>
</ol>
<p>关于第三点举个例子：比如我们用一个模型来描述雇员，对于公司的雇员来说，他有很多的基本属性和方法，比如走路、讲话、会隶属于某个部门、会有具体的 Base，这些我们可以使用抽象类来描述，强调这个类用来描述雇员。但同时，每个雇员又有不同的职责，比如 Android 开发要求会写 UI，懂 Java 和算法，会读写英语，那这些作为附加能力，可以抽象为接口。</p>
<h4 id="⭐️-谈谈-Error-和-Exception-的区别？"><a href="#⭐️-谈谈-Error-和-Exception-的区别？" class="headerlink" title="⭐️ 谈谈 Error 和 Exception 的区别？"></a>⭐️ 谈谈 <code>Error</code> 和 <code>Exception</code> 的区别？</h4><p>在 Java 中，<code>Error</code> 和 <code>Exception</code> 都是表示程序执行过程中的异常情况，但它们在使用和处理上有一些重要的区别。</p>
<p><code>Error</code> 是指那些严重错误，通常是由于系统级问题或虚拟机自身的错误导致，例如内存溢出（<code>OutOfMemoryError</code>）或栈溢出（<code>StackOverflowError</code>）。<code>Error</code> 表示程序无法恢复或继续执行，并且通常会导致程序的中断或终止。由于 <code>Error</code> 是严重的问题，一般情况下不建议对其进行捕获和处理，而是让程序自行终止并进行相应的修复。</p>
<p><code>Exception</code> 则表示程序执行过程中的非正常情况，但是它们通常是由于可控因素引起的，例如输入错误、网络中断、文件不存在等。<code>Exception</code> 可以分为两种类型：<strong>已检查异常（Checked Exception）</strong>和<strong>未检查异常（Unchecked Exception）</strong>。</p>
<ul>
<li><p><strong>已检查异常</strong>：已检查异常是指那些在编译时强制要求进行捕获或声明抛出的异常。这些异常通常表示程序可能遇到的一些预期的、可处理的情况。如果一个方法声明抛出了已检查异常，那么调用该方法的代码必须使用 <code>try-catch</code> 块捕获异常或者继续声明抛出异常，否则会产生编译错误。</p>
<p>例如，<code>IOException</code> 是一个已检查异常，它表示在输入&#x2F;输出操作中发生的错误，如文件读写错误。在处理文件操作时，我们需要捕获或声明抛出 <code>IOException</code>。</p>
</li>
<li><p><strong>未检查异常</strong>：未检查异常是指那些在编译时不需要强制捕获或声明抛出的异常。这些异常通常表示程序遇到了一些非预期、无法处理的错误或错误的使用方式。未检查异常是 <code>RuntimeException</code> 类或其子类的实例。</p>
<p>例如，<code>NullPointerException</code>（空指针异常）和 <code>ArrayIndexOutOfBoundsException</code>（数组越界异常）都是未检查异常。它们通常表示代码中的错误逻辑或错误使用了空引用或越界访问数组的情况。</p>
</li>
</ul>
<p>一般来说，应该尽量避免抛出未检查异常，而是通过良好的设计和编程实践来避免这些错误的发生。对于已检查异常，我们可以选择捕获并进行适当的处理，或者继续将其声明抛出给上层调用者。</p>
<p>总结起来，<code>Error</code> 和 <code>Exception</code> 都表示程序执行过程中的异常情况，但 <code>Error</code> 表示严重错误和系统级问题，不建议捕获和处理；而 <code>Exception</code> 则表示可控的异常情况，分为已检查异常和未检查异常，需要根据具体情况进行捕获和处理。</p>
<h4 id="⭐️-什么是反射机制？反射机制的应用场景有哪些？"><a href="#⭐️-什么是反射机制？反射机制的应用场景有哪些？" class="headerlink" title="⭐️ 什么是反射机制？反射机制的应用场景有哪些？"></a>⭐️ 什么是反射机制？反射机制的应用场景有哪些？</h4><p>反射机制（Reflection）是一种在运行时检查、访问和修改程序结构（如类、对象、属性、方法等）的能力。通过反射，我们可以在程序运行时动态地获取和操作类的信息，包括类的成员、方法、构造函数等。</p>
<p>Kotlin 提供了强大的反射机制，可以通过 <code>KClass</code> 类和相关的函数来实现反射操作。以下是一些反射机制的应用场景：</p>
<ol>
<li>动态加载类和创建对象：反射机制允许在运行时根据类名动态加载类，并使用反射 API 创建类的实例。这对于需要在编译时无法确定类名的情况下非常有用，例如插件化系统、依赖注入框架等。</li>
<li>访问和操作类的属性和方法：通过反射，我们可以在运行时获取类的属性和方法的信息，并对其进行读取和调用。这使得我们可以动态地访问和操作类的成员，实现一些灵活的功能，如动态注入依赖、调用私有方法等。</li>
<li>注解处理：反射机制可以用于处理注解。我们可以使用反射 API 获取类、属性、方法等上的注解，进而根据注解的信息执行相应的逻辑，例如自定义注解的处理器、AOP（面向切面编程）框架等。</li>
<li>序列化和反序列化：反射机制可以帮助我们将对象转换为字节流或字符串，并在需要时将其还原为对象。这在数据存储、网络传输和对象持久化等场景中非常有用。</li>
<li>单元测试和调试工具：反射机制可以用于编写单元测试和调试工具。通过反射，我们可以检查类的状态、调用私有方法、修改私有属性等，以便于编写全面的测试用例和排查问题。</li>
</ol>
<p>总结起来，反射机制是一种在运行时检查、访问和修改程序结构的能力。它的应用场景包括动态加载类、创建对象、访问和操作类的属性和方法、注解处理、序列化和反序列化，以及编写单元测试和调试工具等。通过反射，我们可以在运行时对程序进行更加灵活和动态的操作。</p>
<h4 id="⭐️-谈谈如何重写-equals-方法？为什么还要重写-hashCode-？"><a href="#⭐️-谈谈如何重写-equals-方法？为什么还要重写-hashCode-？" class="headerlink" title="⭐️ 谈谈如何重写 equals() 方法？为什么还要重写 hashCode()？"></a>⭐️ 谈谈如何重写 <code>equals()</code> 方法？为什么还要重写 <code>hashCode()</code>？</h4><p>重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法是为了正确地实现对象的相等性比较和在散列容器（如哈希表）中正确地存储对象。下面是关于如何重写这两个方法的一些指导和原因：</p>
<p>重写 <code>equals()</code> 方法：</p>
<ul>
<li><code>equals()</code> 方法用于比较两个对象是否相等。默认情况下，<code>equals()</code> 方法在比较对象时使用的是引用相等性（即比较对象的内存地址），但在许多情况下，我们希望比较对象的内容是否相等。重写 <code>equals()</code> 方法时应遵循以下原则：<ul>
<li>自反性：<code>x.equals(x)</code> 应始终返回 true。</li>
<li>对称性：如果 <code>x.equals(y)</code> 返回 true，那么 <code>y.equals(x)</code> 也应返回 true。</li>
<li>传递性：如果 <code>x.equals(y)</code> 和 <code>y.equals(z)</code> 都返回 true，那么 <code>x.equals(z)</code> 也应返回 true。</li>
<li>一致性：在对象未修改的情况下，多次调用 <code>x.equals(y)</code> 应始终返回相同的结果。</li>
<li>非空性：<code>x.equals(null)</code> 应返回 false。</li>
</ul>
</li>
<li>重写 <code>equals()</code> 方法通常需要比较对象的字段值。可以使用 <code>instanceof</code> 运算符检查类型，然后比较字段值是否相等。</li>
</ul>
<p>重写 <code>hashCode()</code> 方法：</p>
<ul>
<li><code>hashCode()</code> 方法返回对象的散列码，用于在散列容器（如哈希表）中定位对象的存储位置。</li>
<li>当重写 <code>equals()</code> 方法时，也应该相应地重写 <code>hashCode()</code> 方法，以保证对象相等的实例具有相等的散列码。<br><code>hashCode()</code> 方法的重写应满足以下原则（JavaDoc）：<ul>
<li>如果两个对象通过 <code>equals()</code> 方法比较是相等的，那么它们的 <code>hashCode()</code> 必须一致；</li>
<li>如果两个对象通过 <code>equals()</code> 方法比较是不相等的，那么它们的 <code>hashCode()</code> 最好不一致（不强求），这样可以提高性能，比如在 Hash 时不会集中到个别桶中；</li>
</ul>
</li>
<li>通常，可以使用对象的字段值来计算散列码。可以选择使用某些字段的散列码进行异或操作，以生成最终的散列码。</li>
</ul>
<p>为什么还要重写 <code>hashCode()</code> 方法？</p>
<ul>
<li>在散列容器中存储对象时，为了能够正确地定位和访问对象，需要使用散列码。如果不重写 <code>hashCode()</code> 方法，那么每次调用默认的 <code>hashCode()</code> 方法时，都会返回不同的散列码，导致对象无法正确地存储和检索；</li>
<li>重写 <code>hashCode()</code> 方法保证了对象相等的实例具有相等的散列码，这在散列容器中尤为重要。如果两个对象通过 equals() 方法比较是相等的，但它们具有不同的散列码，那么在散列容器中它们被视为不同的对象，可能会导致数据结构的不一致和错误的结果（相等却找不到）；</li>
</ul>
<p>综上所述，重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法是为了确保对象的相等性比较和散列码计算的一致性和正确性，从而保证对象在比较和存储时的预期行为。</p>
<h4 id="⭐️-谈谈你对-Java-泛型中类型擦除的理解，并说说其局限性？"><a href="#⭐️-谈谈你对-Java-泛型中类型擦除的理解，并说说其局限性？" class="headerlink" title="⭐️ 谈谈你对 Java 泛型中类型擦除的理解，并说说其局限性？"></a>⭐️ 谈谈你对 Java 泛型中类型擦除的理解，并说说其局限性？</h4><p>参考：<a href="https://qianyuebits.github.io/2024/01/18/Java-Generics/">Java 泛型</a></p>
<h4 id="⭐️-String-为什么要设计成不可变的？其如何实现不可变性的？"><a href="#⭐️-String-为什么要设计成不可变的？其如何实现不可变性的？" class="headerlink" title="⭐️ String 为什么要设计成不可变的？其如何实现不可变性的？"></a>⭐️ String 为什么要设计成不可变的？其如何实现不可变性的？</h4><p>从技术层面：</p>
<ol>
<li>保存字符串的数组 value 被 <code>private</code> 和 <code>final</code> 修饰，并且 <code>String</code> 类没有提供修改 value 的方法；</li>
<li>String 类被 final 修饰，不能被继承修改；</li>
</ol>
<p>Java 的字符串被设计为不可变的（Immutable）有以下几个原因：</p>
<ul>
<li>性能优化：字符串常常被用作散列键（如在哈希表中使用），因此如果字符串是可变的，那么当字符串的值发生变化时，需要重新计算哈希值。而不可变字符串可以缓存其哈希值，提高散列性能；</li>
<li>线程安全：不可变字符串是线程安全的，因为多个线程可以共享相同的字符串实例而无需担心数据竞争或并发修改问题。这简化了多线程环境下的编程和调试；</li>
<li>安全性：字符串常常被用于表示敏感信息（如密码），如果字符串是可变的，那么它的值可以在不知情的情况下被修改。通过设计字符串为不可变，可以提高安全性，防止数据被意外修改；</li>
<li>缓存和重用：由于字符串是不可变的，可以被安全地作为缓存键或常量池中的键使用。这样可以提高性能，避免创建重复的字符串对象，节省内存开销；</li>
<li>API 设计和可预测性：字符串不可变性使得字符串操作的 API 更加简单和可靠。不可变性确保了字符串的值不会在操作期间发生变化，使得代码更易于理解、调试和维护；</li>
</ul>
<p>尽管字符串是不可变的，但是 Java 提供了一些字符串操作的方法，如拼接、替换、截取等，这些操作并不直接修改原始字符串，而是返回一个新的字符串对象。这样既保持了字符串的不可变性，又提供了方便的操作接口。</p>
<h4 id="⭐️-说说你对-Java-注解的理解？编译期注解-VS-运行时注解？"><a href="#⭐️-说说你对-Java-注解的理解？编译期注解-VS-运行时注解？" class="headerlink" title="⭐️ 说说你对 Java 注解的理解？编译期注解 VS 运行时注解？"></a>⭐️ 说说你对 Java 注解的理解？编译期注解 VS 运行时注解？</h4><p>Java 注解（Annotation）是一种用于在程序中添加元数据（metadata）的特殊标记。它们提供了一种在代码中嵌入附加信息的方式，可以用于编译、运行时以及工具框架的处理。</p>
<p>Java 注解可以应用于类、方法、字段和其他程序元素上。它们以 <code>@</code> 符号开头，跟随注解名称和一组可选的参数。注解可以提供额外的信息，用于编写文档、配置代码生成、指示编译器行为、触发运行时处理等。</p>
<p>根据注解的处理时机，我们可以将 Java 注解分为两类：编译期注解和运行时注解。</p>
<p><strong>编译期注解（Compile-Time Annotation）</strong>：编译期注解是在编译阶段由编译器处理的注解。编译器可以根据注解提供的信息来进行代码生成、静态检查、警告或错误的产生等。编译期注解对程序的运行时行为没有直接影响，它们更多地用于在编译时进行静态分析和代码生成。</p>
<p>一些常见的编译期注解包括 <code>@Override</code>、<code>@Deprecated</code> 和 <code>@SuppressWarnings</code>。例如，<code>@Override</code> 注解用于确保子类正确重写了父类的方法，编译器在编译时会检查并发出警告或错误。</p>
<p><strong>运行时注解（Runtime Annotation）</strong>：运行时注解是在程序运行时由解释器或运行时库处理的注解。运行时注解可以在程序运行期间通过反射机制访问和处理。它们常用于实现依赖注入、配置加载、动态代理等功能，可以在运行时动态地修改程序的行为。</p>
<p>一些常见的运行时注解包括 <code>@Autowired</code>、<code>@Transactional</code> 和 <code>@RequestMapping</code>。例如，<code>@Autowired</code> 注解用于自动注入依赖对象，在程序运行时框架会根据注解的信息自动将依赖对象注入到相应的位置。</p>
<p>需要注意的是，并非所有的注解都可以在运行时访问。只有通过 <code>@Retention(RetentionPolicy.RUNTIME)</code> 显式声明为运行时注解的注解才能在运行时被访问。</p>
<p>总结起来，Java 注解是一种用于在程序中添加元数据的特殊标记。根据注解的处理时机，可以将注解分为编译期注解和运行时注解。编译期注解在编译阶段由编译器处理，用于静态分析和代码生成；运行时注解在程序运行时由解释器或运行时库处理，用于实现动态行为和功能。</p>
<h4 id="⭐️-HashMap-的实现原理？"><a href="#⭐️-HashMap-的实现原理？" class="headerlink" title="⭐️ HashMap 的实现原理？"></a>⭐️ <code>HashMap</code> 的实现原理？</h4><p>数组 + 链表&#x2F;红黑树</p>
<h4 id="⭐️-谈谈对于-ConcurrentHashMap-的理解？"><a href="#⭐️-谈谈对于-ConcurrentHashMap-的理解？" class="headerlink" title="⭐️ 谈谈对于 ConcurrentHashMap 的理解？"></a>⭐️ 谈谈对于 <code>ConcurrentHashMap</code> 的理解？</h4><p>参考：<a target="_blank" rel="noopener" href="https://javaguide.cn/java/collection/concurrent-hash-map-source-code.html">ConcurrentHashMap 源码分析</a></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="⭐️-Java-中使用多线程的方式有哪些？"><a href="#⭐️-Java-中使用多线程的方式有哪些？" class="headerlink" title="⭐️ Java 中使用多线程的方式有哪些？"></a>⭐️ Java 中使用多线程的方式有哪些？</h4><ol>
<li>线程创建方面，可以自己创建 Thread 或者使用线程池；</li>
<li>任务创建方面，可以继承 <code>Runnable</code> 或者 <code>Callable</code> 或者 <code>FutureTask</code> 来创建；</li>
</ol>
<h4 id="⭐️-说一下线程的几种状态？"><a href="#⭐️-说一下线程的几种状态？" class="headerlink" title="⭐️ 说一下线程的几种状态？"></a>⭐️ 说一下线程的几种状态？</h4><p>参见：<a href="https://qianyuebits.github.io/2024/01/17/Java-Thread-State/">Java Thread 状态</a></p>
<p><strong>总结下：</strong></p>
<ol>
<li>初始化</li>
<li>可运行&#x2F;就绪状态</li>
<li>等待（Waiting）</li>
<li>阻塞（Blocked）</li>
<li>终止状态</li>
</ol>
<h4 id="⭐️-谈谈线程阻塞的原因？"><a href="#⭐️-谈谈线程阻塞的原因？" class="headerlink" title="⭐️ 谈谈线程阻塞的原因？"></a>⭐️ 谈谈线程阻塞的原因？</h4><ol>
<li>等待外部资源：线程可能因为等待外部资源的可用性而被阻塞。这包括等待用户输入、等待磁盘I&#x2F;O、等待网络数据等。当线程需要依赖外部资源的时候，如果资源不可用，线程将被阻塞，直到资源准备就绪；</li>
<li>线程同步：在多线程编程中，线程之间可能需要协调和同步执行。当线程需要访问某个共享资源时，可能需要获取锁或等待其他线程释放锁才能继续执行。当线程无法获取到所需的锁时，它将被阻塞，直到锁可用；</li>
<li>等待条件满足：线程可能因为等待某个条件满足而被阻塞。这通常通过调用对象的等待方法（如 wait()）来实现。线程在等待条件满足之前会被阻塞，并释放对象的锁，允许其他线程访问该对象。当条件满足时，线程会被唤醒并重新竞争获取锁；</li>
</ol>
<h4 id="⭐️-如何实现多线程中的同步？谈一谈-Java-线程常见的几种锁？"><a href="#⭐️-如何实现多线程中的同步？谈一谈-Java-线程常见的几种锁？" class="headerlink" title="⭐️ 如何实现多线程中的同步？谈一谈 Java 线程常见的几种锁？"></a>⭐️ 如何实现多线程中的同步？谈一谈 Java 线程常见的几种锁？</h4><p>参见：<a href="https://qianyuebits.github.io/2024/01/17/Java-Thread-Programming/">Java 并发编程</a></p>
<ol>
<li><code>synchronized</code></li>
<li><code>ReentrantLock</code>（建议研究下这个类）</li>
<li>Java 提供了一些并发工具类，如 <code>CountDownLatch</code>、<code>Semaphore</code>、<code>CyclicBarrier</code>、<code>Lock</code> 等</li>
</ol>
<h4 id="⭐️-谈谈线程死锁，如何有效的避免线程死锁？"><a href="#⭐️-谈谈线程死锁，如何有效的避免线程死锁？" class="headerlink" title="⭐️ 谈谈线程死锁，如何有效的避免线程死锁？"></a>⭐️ 谈谈线程死锁，如何有效的避免线程死锁？</h4><p>死锁的概念：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。产生死锁的必要条件：</p>
<ol>
<li>互斥（mutual exclusion），一个资源每次只能被一个进程使用；</li>
<li>不可抢占（no preemption），进程已获得的资源，在未使用完之前，不能强行剥夺；</li>
<li>占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li>
<li>环形等待（circular wait），若干进程之间形成一种首尾相接的循环等待资源关系；</li>
</ol>
<p>死锁的解除与预防：理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p>
<p>比如哲学家问题，可以让其中一个哲学家先拿左边的筷子，后拿右边的，而其余的哲学家则相反，这样就破坏了最后一个条件，也就不会造成死锁。</p>
<h4 id="⭐️-synchronized-和-ReentrantLock-有什么区别"><a href="#⭐️-synchronized-和-ReentrantLock-有什么区别" class="headerlink" title="⭐️ synchronized 和 ReentrantLock 有什么区别"></a>⭐️ <code>synchronized</code> 和 <code>ReentrantLock</code> 有什么区别</h4><ul>
<li><code>synchronized</code> 是 Java 语言内置的关键字，通过隐式地获取和释放锁来实现同步，功能相对简单，适用于大多数的线程同步需求；</li>
<li><code>ReentrantLock</code> 是一个显示锁，需要显式地调用 <code>lock()</code> 方法来获取锁，并提供了更多高级的特性，如可重入性、公平性、条件变量等，适用于更复杂的线程同步需求。但使用时需要注意避免死锁和正确释放锁的问题；</li>
</ul>
<h4 id="⭐️-synchronized-和-volatile-关键字的区别？"><a href="#⭐️-synchronized-和-volatile-关键字的区别？" class="headerlink" title="⭐️ synchronized 和 volatile 关键字的区别？"></a>⭐️ <code>synchronized</code> 和 <code>volatile</code> 关键字的区别？</h4><ul>
<li><code>synchronized</code> 关键字用于实现互斥访问共享资源，保证同一时刻只有一个线程能够执行被修饰的代码块或方法，并提供了可见性和有序性的特性；</li>
<li><code>volatile</code> 关键字用于实现变量的可见性，保证对 <code>volatile</code> 变量的修改对其他线程立即可见，但不提供互斥访问的功能；</li>
</ul>
<h4 id="⭐️-谈谈-ThreadLocal-用法和原理？"><a href="#⭐️-谈谈-ThreadLocal-用法和原理？" class="headerlink" title="⭐️ 谈谈 ThreadLocal 用法和原理？"></a>⭐️ 谈谈 <code>ThreadLocal</code> 用法和原理？</h4><p>参考：<a href="https://qianyuebits.github.io/2014/05/25/Java-ThreadLocal/">Java ThreadLocal</a></p>
<h4 id="⭐️-谈一谈线程-sleep-和-wait-的区别？"><a href="#⭐️-谈一谈线程-sleep-和-wait-的区别？" class="headerlink" title="⭐️ 谈一谈线程 sleep() 和 wait() 的区别？"></a>⭐️ 谈一谈线程 <code>sleep()</code> 和 <code>wait()</code> 的区别？</h4><ul>
<li><code>sleep()</code> 方法是线程类的静态方法，用于暂停当前线程的执行一段时间；</li>
<li><code>wait()</code> 方法是对象实例方法，用于将当前线程置于等待状态，直到其他线程唤醒；</li>
<li><code>sleep()</code> 方法在暂停期间不会释放锁，<code>wait()</code> 方法会释放锁（只能在同步代码块或同步方法中调用，否则会抛出 <code>IllegalMonitorStateException</code> 异常）；</li>
<li><code>sleep()</code> 方法的唤醒只能等待指定时间过去后自动唤醒，而 <code>wait()</code> 方法的唤醒需要其他线程显式调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法；</li>
</ul>
<h4 id="⭐️-Java-线程中-notify-和-notifyAll-有什么区别？"><a href="#⭐️-Java-线程中-notify-和-notifyAll-有什么区别？" class="headerlink" title="⭐️ Java 线程中 notify 和 notifyAll 有什么区别？"></a>⭐️ Java 线程中 <code>notify</code> 和 <code>notifyAll</code> 有什么区别？</h4><p>都会导致某个对象锁上的等待线程进入可运行状态，前者随机唤醒一个，后者唤醒全部。</p>
<h4 id="⭐️-什么是线程池？如何创建一个线程池？"><a href="#⭐️-什么是线程池？如何创建一个线程池？" class="headerlink" title="⭐️ 什么是线程池？如何创建一个线程池？"></a>⭐️ 什么是线程池？如何创建一个线程池？</h4><p>线程组件，负责线程的创建、销毁和任务的调度。可见<a href="https://qianyuebits.github.io/2024/01/17/Java-ThreadPool/">Java ThreadPool</a>。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h4 id="⭐️-谈一谈-JAVA-垃圾回收机制？"><a href="#⭐️-谈一谈-JAVA-垃圾回收机制？" class="headerlink" title="⭐️ 谈一谈 JAVA 垃圾回收机制？"></a>⭐️ 谈一谈 JAVA 垃圾回收机制？</h4><p>关键：</p>
<ol>
<li>内存分区；</li>
<li>垃圾回收算法；</li>
<li>垃圾回收器；</li>
</ol>
<p>参考：<a href="https://qianyuebits.github.io/2024/01/17/Java-Memory-Management/">Java 内存管理</a></p>
<h4 id="⭐️-回答一下什么是强、软、弱、虚引用以及它们之间的区别？"><a href="#⭐️-回答一下什么是强、软、弱、虚引用以及它们之间的区别？" class="headerlink" title="⭐️ 回答一下什么是强、软、弱、虚引用以及它们之间的区别？"></a>⭐️ 回答一下什么是强、软、弱、虚引用以及它们之间的区别？</h4><p>强弱软虚</p>
<h4 id="⭐️-JMM-是什么？它存在哪些问题？该如何解决？"><a href="#⭐️-JMM-是什么？它存在哪些问题？该如何解决？" class="headerlink" title="⭐️ JMM 是什么？它存在哪些问题？该如何解决？"></a>⭐️ JMM 是什么？它存在哪些问题？该如何解决？</h4><p>参考：<a href="https://qianyuebits.github.io/2024/01/17/JMM/">JMM（Java 内存模型）</a></p>
<p><strong>JMM（Java内存模型）是 Java 编程语言中定义了多线程并发访问内存的规范。它定义了线程如何与主内存和各自的工作内存进行交互，以及如何保证多线程之间的数据可见性、有序性和原子性。</strong></p>
<p>JMM 存在以下几个问题：</p>
<ul>
<li><strong>可见性问题</strong> 可见性问题指的是当一个线程修改了共享变量的值后，其他线程可能无法立即看到最新的值。这是因为线程在工作内存中进行操作，对主内存的修改可能不会立即同步到其他线程的工作内存中，从而导致数据不一致。</li>
<li><strong>有序性问题</strong> 有序性问题指的是程序的执行顺序可能与我们期望的不一致。由于编译器和处理器的优化，指令可能会被重排序，这可能导致某些操作的执行顺序与程序代码的顺序不一致。</li>
<li><strong>原子性问题</strong> 原子性问题指的是一个操作的执行过程中可能被其他线程的操作所中断，从而导致操作没有完全执行或者执行部分结果，违背了原子性的要求。</li>
</ul>
<p>为了解决 JMM 存在的问题，可以采取以下方法：</p>
<ol>
<li>使用 <code>volatile</code> 关键字：<code>volatile</code> 关键字可以确保被修饰的变量对所有线程可见，并且禁止了对该变量的重排序；</li>
<li>使用 <code>synchronized</code> 关键字或者 Lock 等其他同步方法：<code>synchronized</code> 关键字可以保证线程对同步块或方法的访问是互斥的，即同一时刻只有一个线程可以执行同步代码块，从而解决可见性、有序性和原子性问题；</li>
<li>使用原子类：Java 提供了一系列的原子类，如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等，它们提供了原子性的操作，可以解决原子性问题；</li>
</ol>
<p>通过合理地使用上述方法，可以解决 JMM 存在的可见性、有序性和原子性问题，从而保证多线程程序的正确性和可靠性。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="⭐️-简述-JVM-中类的加载机制与加载过程？（Classloader-工作原理）"><a href="#⭐️-简述-JVM-中类的加载机制与加载过程？（Classloader-工作原理）" class="headerlink" title="⭐️ 简述 JVM 中类的加载机制与加载过程？（Classloader 工作原理）"></a>⭐️ 简述 JVM 中类的加载机制与加载过程？（<code>Classloader</code> 工作原理）</h4><p>JVM（Java 虚拟机）在运行 Java 程序时，采用了类的动态加载机制。类的加载过程包括加载、验证、准备、解析和初始化等阶段。以下是对这些阶段的简要描述：</p>
<ol>
<li><strong>加载（Loading）</strong>：</li>
</ol>
<ul>
<li>类加载是将类的二进制数据从磁盘或网络加载到内存中的过程。</li>
<li>类加载器负责加载类，并生成对应的 Class 对象。</li>
<li>加载阶段包括三个步骤：通过类的全限定名获取类的字节码数据，创建一个对应的 Class 对象，并将 Class 对象放入方法区的运行时常量池中。</li>
</ul>
<ol start="2">
<li><strong>验证（Verification）</strong>：</li>
</ol>
<ul>
<li>验证阶段用于确保类的字节码符合 JVM 规范，并且不会危害 JVM 本身的安全。</li>
<li>验证过程包括文件格式验证、元数据验证、字节码验证和符号引用验证等。</li>
</ul>
<ol start="3">
<li><strong>准备（Preparation）</strong>：</li>
</ol>
<ul>
<li>在准备阶段，JVM 为类的静态变量分配内存，并设置默认初始值。</li>
<li>静态变量会被分配在方法区中的静态变量区域。</li>
</ul>
<ol start="4">
<li><strong>解析（Resolution</strong>）：</li>
</ol>
<ul>
<li>解析阶段将常量池中的符号引用替换为直接引用，即将类、方法、字段等符号引用解析为具体的内存地址。</li>
<li>解析可以在加载阶段后进行，也可以在初始化阶段之前进行。</li>
</ul>
<ol start="5">
<li><strong>初始化（Initialization）</strong>：</li>
</ol>
<ul>
<li>初始化阶段是类加载的最后一步，是类中静态变量赋予正确初始值的过程。</li>
<li>在初始化阶段，会执行类的静态初始化器（<code>&lt;clinit&gt;</code>方法）的代码，静态变量会被赋予程序中指定的值。<br>需要注意的是，类的加载过程是按需进行的，即在首次使用类时才会进行加载。同时，JVM 还提供了类的卸载机制，当类不再被使用时，会被卸载并释放内存。<br>类的加载机制和加载过程是 JVM 实现 Java 语言跨平台特性的重要组成部分，它们确保了类的正确加载和初始化，使得 Java 程序能够在不同的平台上运行。</li>
</ul>
<h4 id="⭐️-饿汉单例为什么是线程安全的？"><a href="#⭐️-饿汉单例为什么是线程安全的？" class="headerlink" title="⭐️ 饿汉单例为什么是线程安全的？"></a>⭐️ 饿汉单例为什么是线程安全的？</h4><p>参考：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/shoufeng/p/10820964.html">设计模式 - Java中单例模式的6种写法及优缺点对比</a></p>
<p>饿汉模式利用 JVM 加载类的原理，保证在使用到静态变量的时候一定是经过初始化的。可见类的加载过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饥饿模式: 类加载时就初始化</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">HungrySingleton</span> &#123;</span><br><span class="line">    <span class="comment">/** 实例对象 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">HungrySingleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HungrySingleton</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 禁用构造方法 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">HungrySingleton</span><span class="params">()</span> &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取单例对象, 直接返回已创建的实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> instance 本类的实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="⭐️-JVM、Dalvik、ART-三者的原理和区别？"><a href="#⭐️-JVM、Dalvik、ART-三者的原理和区别？" class="headerlink" title="⭐️ JVM、Dalvik、ART 三者的原理和区别？"></a>⭐️ JVM、Dalvik、ART 三者的原理和区别？</h4><p>参考：<a target="_blank" rel="noopener" href="https://source.android.com/docs/core/runtime?hl=zh-cn">Android Runtime (ART) 和 Dalvik</a></p>
<p>JVM（Java Virtual Machine）、Dalvik 和 ART（Android Runtime）是三种不同的虚拟机技术，它们在原理和应用上有所不同。以下是对它们的简要介绍：</p>
<ol>
<li><strong>JVM（Java Virtual Machine）</strong>：JVM 是 Java 平台上的虚拟机，用于执行 Java 字节码。它负责将 Java 字节码解释成机器码并执行。JVM 是 Java 语言的核心组成部分，提供了内存管理、垃圾回收、线程调度等功能。JVM 的设计目标是实现平台无关性，使得一次编译的 Java 程序可以在不同的操作系统和硬件平台上运行。</li>
<li><strong>Dalvik</strong>：Dalvik 虚拟机是 Android 平台上的早期虚拟机，用于执行 Android 应用程序。与 JVM 不同，Dalvik 并不直接执行 Java 字节码，而是使用自己的指令集（Dalvik 字节码，dex 文件）。Dalvik 虚拟机的设计目标是优化移动设备上的资源利用，例如内存和处理器速度。Dalvik 使用基于寄存器的架构，通过运行时的即时编译（Just-In-Time Compilation）将 Dalvik 字节码转换为机器码执行。</li>
<li><strong>ART（Android Runtime）</strong>：ART 是 Android 平台上的新一代运行时环境，取代了 Dalvik。ART 使用 <strong>Ahead-Of-Time（AOT）</strong>编译技术，将应用的字节码在安装时预先编译为本地机器码（在安装时，ART 使用设备自带的 <code>dex2oat</code> 工具来编译应用。此实用工具接受 DEX 文件作为输入，并为目标设备生成经过编译的应用可执行文件。），而不是在运行时进行即时编译。这样可以提高应用的启动速度和执行性能，减少了运行时的性能开销。同时，ART 还引入了更高效的垃圾回收算法和内存管理机制，提供了更好的资源管理和应用响应性。</li>
</ol>
<p>主要区别如下：</p>
<ul>
<li>执行方式：JVM 解释执行 Java 字节码。Dalvik 和 ART 通过即时编译将字节码转换为机器码执行。ART 是在应用安装时进行预编译，而 Dalvik 是在运行时即时编译。</li>
<li>指令集：JVM 使用 Java 字节码作为指令集，Dalvik 使用 Dalvik 字节码，ART 使用本地机器码。</li>
<li>性能：ART 相较于 Dalvik 在启动速度和执行性能方面有所提升，因为它使用预编译的本地机器码执行。ART 还引入了更高效的垃圾回收算法和内存管理机制。</li>
<li>资源利用：Dalvik 专注于优化移动设备上的资源利用，例如内存和处理器速度。ART 在资源利用方面也有所改进，但更注重性能提升。</li>
</ul>
<p>总结起来，JVM、Dalvik 和 ART 都是虚拟机技术，用于执行不同平台上的应用程序。JVM 是 Java 平台上的虚拟机，执行 Java 字节码；Dalvik 是 Android 平台早期的虚拟机，使用 Dalvik 字节码，并通过即时编译执行；ART 是 Android 平台的新一代运行时环境，使用预编译的本地机器码执行，并提供了更好的性能和资源管理。</p>
<h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><h4 id="⭐️-请简述一下什么是-Kotlin？它有哪些特性？"><a href="#⭐️-请简述一下什么是-Kotlin？它有哪些特性？" class="headerlink" title="⭐️ 请简述一下什么是 Kotlin？它有哪些特性？"></a>⭐️ 请简述一下什么是 Kotlin？它有哪些特性？</h4><p>它是一种适用于 Java 虚拟机（JVM）和其他平台的通用编程语言，可以与现有的 Java 代码无缝集成。</p>
<ol>
<li>与 Java 互操作性</li>
<li>空安全性</li>
<li>函数式编程支持</li>
<li>扩展函数：Kotlin 引入了扩展函数的概念，可以为现有的类添加新的函数，而无需修改类的定义。这使得在不修改类的情况下，为类添加新的功能变得非常方便。</li>
<li>协程支持：Kotlin 提供了协程（Coroutines）支持，用于简化异步编程和并发任务的处理。协程可以在代码中以顺序的方式表达异步操作，使得异步代码更易于编写、理解和维护。</li>
</ol>
<h4 id="⭐️-Kotlin-中注解-JvmOverloads-的作用？"><a href="#⭐️-Kotlin-中注解-JvmOverloads-的作用？" class="headerlink" title="⭐️ Kotlin 中注解 @JvmOverloads 的作用？"></a>⭐️ Kotlin 中注解 <code>@JvmOverloads</code> 的作用？</h4><p>指示 Kotlin 编译器为该函数生成替代默认参数值的重载。<br>如果一个方法有 N 个参数，其中 M 个参数有默认值，那么就会生成 M 个重载。：第一个方法有 N-1 个参数，第二个方法有 N-2 个参数，依此类推（除了最后一个方法都有默认值）。</p>
<h4 id="⭐️-Kotlin-中-List-与-MutableList-的区别？"><a href="#⭐️-Kotlin-中-List-与-MutableList-的区别？" class="headerlink" title="⭐️ Kotlin 中 List 与 MutableList 的区别？"></a>⭐️ Kotlin 中 <code>List</code> 与 <code>MutableList</code> 的区别？</h4><ol>
<li><code>List</code>：<code>List</code> 是一个只读接口，表示一个不可变的列表。它提供了访问元素的方法，但不能进行添加、删除或更新元素的操作；</li>
<li><code>MutableList</code>：<code>MutableList</code> 是 <code>List</code> 的可变版本，它继承了 <code>List</code> 接口并添加了一些修改列表的方法，如添加、删除和更新元素等；</li>
</ol>
<h4 id="⭐️-在-Kotlin-中，什么是解构？该如何使用？"><a href="#⭐️-在-Kotlin-中，什么是解构？该如何使用？" class="headerlink" title="⭐️ 在 Kotlin 中，什么是解构？该如何使用？"></a>⭐️ 在 Kotlin 中，什么是解构？该如何使用？</h4><p>在 Kotlin 中，解构（Destructuring）是一种将复杂的数据结构（如对象、数组、集合等）拆解为独立变量的过程。它允许我们以一种简洁的方式从复杂的数据结构中提取出其中的元素，并将它们赋值给对应的变量。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    <span class="keyword">val</span> (name, age) = person</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;Name: <span class="variable">$name</span>, Age: <span class="variable">$age</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解构数组和集合的时候要求变量的数量元素数量相匹配：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> list = listOf(<span class="string">&quot;Apple&quot;</span>, <span class="string">&quot;Banana&quot;</span>, <span class="string">&quot;Orange&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> (fruit1, fruit2, fruit3) = list</span><br><span class="line">    </span><br><span class="line">    println(<span class="string">&quot;Fruit 1: <span class="variable">$fruit1</span>, Fruit 2: <span class="variable">$fruit2</span>, Fruit 3: <span class="variable">$fruit3</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于对象，要求对象的类实现了 <code>component1()</code>、<code>component2()</code> 等命名约定的函数，这些函数定义了属性的顺序。</p>
<h4 id="⭐️-谈谈你对-Kotlin-中的-data-关键字的理解？相比于普通类有哪些特点？"><a href="#⭐️-谈谈你对-Kotlin-中的-data-关键字的理解？相比于普通类有哪些特点？" class="headerlink" title="⭐️ 谈谈你对 Kotlin 中的 data 关键字的理解？相比于普通类有哪些特点？"></a>⭐️ 谈谈你对 Kotlin 中的 data 关键字的理解？相比于普通类有哪些特点？</h4><p>在 Kotlin 中，<code>data</code> 关键字用于声明数据类（Data Class）。数据类是一种特殊类型的类，旨在用于存储和表示数据，而不是提供复杂的行为和业务逻辑。数据类提供了一些默认实现，使得在编写与数据相关的代码时更加简洁和方便。</p>
<p>以下是数据类相对于普通类的一些特点和优势：</p>
<ol>
<li>自动生成成员函数：数据类自动为定义的属性生成了一些标准的成员函数，包括 <code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>、<code>copy()</code> 等。这些函数会根据属性的值自动生成，避免了手动编写大量重复的代码。</li>
<li>组件函数（Component Functions）：数据类会自动生成用于解构声明的组件函数，这使得可以直接通过解构声明来访问数据类的属性，方便地进行对象的解构赋值操作。</li>
<li>可以通过 <code>copy()</code> 函数生成对象副本：数据类提供了一个 <code>copy()</code> 函数，该函数可以创建一个新的数据类对象，同时可以选择性地修改其中的属性值。这在需要创建对象副本并进行修改的场景下非常有用。</li>
<li>自动生成 <code>equals()</code> 和 <code>hashCode()</code> 函数：数据类会根据类中声明的属性自动生成 <code>equals()</code> 和 <code>hashCode()</code> 函数。这使得可以方便地进行对象之间的相等性比较和用作集合的元素。</li>
<li>编译器自动提供 <code>toString()</code> 函数：数据类会自动生成一个默认的 <code>toString()</code> 函数，用于以可读性良好的字符串形式表示对象的内容。</li>
</ol>
<p>需要注意的是，数据类必须满足一些要求：</p>
<ul>
<li>主构造函数至少要有一个参数。</li>
<li>主构造函数的所有参数必须标记为 <code>val</code> 或 <code>var</code>。</li>
<li>数据类不能是抽象、开放、密封或内部类。</li>
</ul>
<p>以下是一个示例数据类的定义和使用：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Person</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> age: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> person1 = Person(<span class="string">&quot;Alice&quot;</span>, <span class="number">25</span>)</span><br><span class="line">    <span class="keyword">val</span> person2 = person1.copy(age = <span class="number">30</span>)</span><br><span class="line">    </span><br><span class="line">    println(person1)  <span class="comment">// 输出：Person(name=Alice, age=25)</span></span><br><span class="line">    println(person2)  <span class="comment">// 输出：Person(name=Alice, age=30)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">val</span> (name, age) = person1</span><br><span class="line">    println(<span class="string">&quot;Name: <span class="variable">$name</span>, Age: <span class="variable">$age</span>&quot;</span>)  <span class="comment">// 输出：Name: Alice, Age: 25</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结起来，<code>data</code> 关键字用于声明数据类，它们提供了一些默认实现和便利的函数，使得在处理数据时更加简洁和方便。数据类是 Kotlin 语言中用于存储和表示数据的一种有用的机制。</p>
<h4 id="谈谈-Kotlin-中的构造方法？有哪些注意事项？"><a href="#谈谈-Kotlin-中的构造方法？有哪些注意事项？" class="headerlink" title="谈谈 Kotlin 中的构造方法？有哪些注意事项？"></a>谈谈 Kotlin 中的构造方法？有哪些注意事项？</h4><h4 id="什么是委托属性？请简要说说其使用场景和原理？"><a href="#什么是委托属性？请简要说说其使用场景和原理？" class="headerlink" title="什么是委托属性？请简要说说其使用场景和原理？"></a>什么是委托属性？请简要说说其使用场景和原理？</h4><h4 id="请举例说明-Kotlin-中-with-与-apply-函数的应用场景和区别？"><a href="#请举例说明-Kotlin-中-with-与-apply-函数的应用场景和区别？" class="headerlink" title="请举例说明 Kotlin 中 with 与 apply 函数的应用场景和区别？"></a>请举例说明 Kotlin 中 with 与 apply 函数的应用场景和区别？</h4><h4 id="Kotlin-内置标准函数-let-的原理是什么？"><a href="#Kotlin-内置标准函数-let-的原理是什么？" class="headerlink" title="Kotlin 内置标准函数 let 的原理是什么？"></a>Kotlin 内置标准函数 let 的原理是什么？</h4><h4 id="Kotlin-语言的-run-高阶函数的原理是什么？"><a href="#Kotlin-语言的-run-高阶函数的原理是什么？" class="headerlink" title="Kotlin 语言的 run 高阶函数的原理是什么？"></a>Kotlin 语言的 run 高阶函数的原理是什么？</h4><h4 id="Kotlin-中-infix-关键字的原理和使用场景？"><a href="#Kotlin-中-infix-关键字的原理和使用场景？" class="headerlink" title="Kotlin 中 infix 关键字的原理和使用场景？"></a>Kotlin 中 <code>infix</code> 关键字的原理和使用场景？</h4><h4 id="Kotlin-中的可见性修饰符有哪些？相比于-Java-有什么区别？"><a href="#Kotlin-中的可见性修饰符有哪些？相比于-Java-有什么区别？" class="headerlink" title="Kotlin 中的可见性修饰符有哪些？相比于 Java 有什么区别？"></a>Kotlin 中的可见性修饰符有哪些？相比于 Java 有什么区别？</h4><h4 id="说说-Kotlin-中的-Any-与-Java-中的-Object-有何异同？"><a href="#说说-Kotlin-中的-Any-与-Java-中的-Object-有何异同？" class="headerlink" title="说说 Kotlin 中的 Any 与 Java 中的 Object 有何异同？"></a>说说 Kotlin 中的 Any 与 Java 中的 Object 有何异同？</h4><h4 id="Kotlin-中-Unit-类型的作用以及与-Java-中-Void-的区别？"><a href="#Kotlin-中-Unit-类型的作用以及与-Java-中-Void-的区别？" class="headerlink" title="Kotlin 中 Unit 类型的作用以及与 Java 中 Void 的区别？"></a>Kotlin 中 <code>Unit</code> 类型的作用以及与 Java 中 Void 的区别？</h4><h4 id="谈谈-Kotlin-中的-Sequence，为什么它处理集合操作更加高效？"><a href="#谈谈-Kotlin-中的-Sequence，为什么它处理集合操作更加高效？" class="headerlink" title="谈谈 Kotlin 中的 Sequence，为什么它处理集合操作更加高效？"></a>谈谈 Kotlin 中的 <code>Sequence</code>，为什么它处理集合操作更加高效？</h4><h4 id="Kotlin-中该如何安全地处理可空类型？"><a href="#Kotlin-中该如何安全地处理可空类型？" class="headerlink" title="Kotlin 中该如何安全地处理可空类型？"></a>Kotlin 中该如何安全地处理可空类型？</h4><h4 id="Kotlin中的数据类型有隐式转换吗？为什么？"><a href="#Kotlin中的数据类型有隐式转换吗？为什么？" class="headerlink" title="Kotlin中的数据类型有隐式转换吗？为什么？"></a>Kotlin中的数据类型有隐式转换吗？为什么？</h4><h4 id="⭐️-Kotlin-中集合遍历有哪几种方式？"><a href="#⭐️-Kotlin-中集合遍历有哪几种方式？" class="headerlink" title="⭐️ Kotlin 中集合遍历有哪几种方式？"></a>⭐️ Kotlin 中集合遍历有哪几种方式？</h4><p>参见：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6979464522666868744">kotlin集合遍历和集合操作符</a></p>
<h4 id="⭐️-Kotlin-中实现单例的几种常见方式？"><a href="#⭐️-Kotlin-中实现单例的几种常见方式？" class="headerlink" title="⭐️ Kotlin 中实现单例的几种常见方式？"></a>⭐️ Kotlin 中实现单例的几种常见方式？</h4><p>与 Java 一样，但写法有变化，比如饿汉模式：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> SingletonDemo</span><br></pre></td></tr></table></figure>

<h4 id="⭐️-在-Kotlin-中，什么是内联函数？有什么作用？"><a href="#⭐️-在-Kotlin-中，什么是内联函数？有什么作用？" class="headerlink" title="⭐️ 在 Kotlin 中，什么是内联函数？有什么作用？"></a>⭐️ 在 Kotlin 中，什么是内联函数？有什么作用？</h4><p>在 Kotlin 中，内联函数（inline functions）是一种特殊类型的函数，它在编译时会将函数的代码直接插入到调用它的地方，而不是通过函数调用的方式执行。通过使用 inline 关键字修饰函数，我们可以将函数调用处的开销减少到最小，从而提高代码的性能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inline fun <span class="title function_">calculateSum</span><span class="params">(a: Int, b: Int)</span>: Int &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="请谈谈-Kotlin-中的-Coroutines，它与线程有什么区别？有哪些优点？"><a href="#请谈谈-Kotlin-中的-Coroutines，它与线程有什么区别？有哪些优点？" class="headerlink" title="请谈谈 Kotlin 中的 Coroutines，它与线程有什么区别？有哪些优点？"></a>请谈谈 Kotlin 中的 <code>Coroutines</code>，它与线程有什么区别？有哪些优点？</h4><h4 id="Kotlin-中的数据类型有隐式转换吗？为什么？"><a href="#Kotlin-中的数据类型有隐式转换吗？为什么？" class="headerlink" title="Kotlin 中的数据类型有隐式转换吗？为什么？"></a>Kotlin 中的数据类型有隐式转换吗？为什么？</h4><h4 id="你觉得-Kotlin-与-Java-混合开发时需要注意哪些问题？"><a href="#你觉得-Kotlin-与-Java-混合开发时需要注意哪些问题？" class="headerlink" title="你觉得 Kotlin 与 Java 混合开发时需要注意哪些问题？"></a>你觉得 Kotlin 与 Java 混合开发时需要注意哪些问题？</h4><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><h4 id="⭐️-简述下-Handler-机制的总体原理？一个线程中可以有几个-Handler？几个-Looper？几个-MessageQueue？"><a href="#⭐️-简述下-Handler-机制的总体原理？一个线程中可以有几个-Handler？几个-Looper？几个-MessageQueue？" class="headerlink" title="⭐️ 简述下 Handler 机制的总体原理？一个线程中可以有几个 Handler？几个 Looper？几个 MessageQueue？"></a>⭐️ 简述下 Handler 机制的总体原理？一个线程中可以有几个 <code>Handler</code>？几个 <code>Looper</code>？几个 <code>MessageQueue</code>？</h4><p>参考：<a href="https://qianyuebits.github.io/2014/05/25/Android-Handler/">Android Handler</a></p>
<h4 id="⭐️-谈谈你对-Activity-runOnUiThread-的理解？"><a href="#⭐️-谈谈你对-Activity-runOnUiThread-的理解？" class="headerlink" title="⭐️ 谈谈你对 Activity.runOnUiThread 的理解？"></a>⭐️ 谈谈你对 <code>Activity.runOnUiThread</code> 的理解？</h4><p>直接看源代码好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">mHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line"><span class="keyword">private</span> Thread mUiThread;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runOnUiThread</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">        mHandler.post(action);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         action.run();</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="⭐️-HandlerThread-的使用场景和用法？"><a href="#⭐️-HandlerThread-的使用场景和用法？" class="headerlink" title="⭐️ HandlerThread 的使用场景和用法？"></a>⭐️ <code>HandlerThread</code> 的使用场景和用法？</h4><p>封装了 Handler 的 Thread，避免写模板代码。在功能上，类似 <code>newSingleThreadExecutor</code> 线程池，只不过是用 Android 相关概念和机制实现的。</p>
<h4 id="⭐️-Handler-中有-Loop-死循环，为什么没有阻塞主线程，原理是什么"><a href="#⭐️-Handler-中有-Loop-死循环，为什么没有阻塞主线程，原理是什么" class="headerlink" title="⭐️ Handler 中有 Loop 死循环，为什么没有阻塞主线程，原理是什么?"></a>⭐️ Handler 中有 Loop 死循环，为什么没有阻塞主线程，原理是什么?</h4><p>当然阻塞住了，只不过阻塞的时候，主线程没有任务需要执行。当其余线程向主线程 <code>MessageQueue</code> 添加任务后，Looper 的阻塞会被唤醒。</p>
<h4 id="⭐️-延迟消息是怎么实现的？Looper-的等待是如何能够准确唤醒的？同步屏障和异步消息是怎么实现的？📚"><a href="#⭐️-延迟消息是怎么实现的？Looper-的等待是如何能够准确唤醒的？同步屏障和异步消息是怎么实现的？📚" class="headerlink" title="⭐️ 延迟消息是怎么实现的？Looper 的等待是如何能够准确唤醒的？同步屏障和异步消息是怎么实现的？📚"></a>⭐️ 延迟消息是怎么实现的？Looper 的等待是如何能够准确唤醒的？同步屏障和异步消息是怎么实现的？📚</h4><p><code>epoll_wait()</code> 机制，当有消息需要延时处理的时候，可以通过该函数阻塞延时时间后再唤醒。如果过程中有新的消息进来，可以通过往对应的 FD 中写入数据来唤醒线程。</p>
<h4 id="⭐️-Looper-中的-quitAllowed-字段是啥？有什么用？"><a href="#⭐️-Looper-中的-quitAllowed-字段是啥？有什么用？" class="headerlink" title="⭐️ Looper 中的 quitAllowed 字段是啥？有什么用？"></a>⭐️ Looper 中的 <code>quitAllowed</code> 字段是啥？有什么用？</h4><p>Looper 类中的 <code>quitAllowed</code> 字段表示是否允许该 Looper 退出（quit）。它是一个布尔类型的标志位。如果为 false，则在调用 quit() 方法的时候会抛出异常，比如主线程即为 false。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!mQuitAllowed) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalStateException</span>(<span class="string">&quot;Main thread not allowed to quit.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h3><h4 id="⭐️-Activity-与-Fragment-之间常见的几种通信方式？"><a href="#⭐️-Activity-与-Fragment-之间常见的几种通信方式？" class="headerlink" title="⭐️ Activity 与 Fragment 之间常见的几种通信方式？"></a>⭐️ Activity 与 Fragment 之间常见的几种通信方式？</h4><p>注意下传参方式吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FragmentOne</span> <span class="variable">fragmentOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FragmentOne</span>();</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putString(<span class="string">&quot;name&quot;</span>, text);</span><br><span class="line">fragmentOne.setArguments(bundle);</span><br><span class="line"><span class="keyword">return</span> fragmentOne;</span><br></pre></td></tr></table></figure>

<h4 id="⭐️-LaunchMode-的应用场景？"><a href="#⭐️-LaunchMode-的应用场景？" class="headerlink" title="⭐️ LaunchMode 的应用场景？"></a>⭐️ LaunchMode 的应用场景？</h4><p>参见：<a href="https://qianyuebits.github.io/2018/12/04/Android-Intent-FLAG/">Android Activity 启动模式</a></p>
<h4 id="⭐️-BroadcastReceiver，LocalBroadcastReceiver-区别？"><a href="#⭐️-BroadcastReceiver，LocalBroadcastReceiver-区别？" class="headerlink" title="⭐️ BroadcastReceiver，LocalBroadcastReceiver 区别？"></a>⭐️ <code>BroadcastReceiver</code>，<code>LocalBroadcastReceiver</code> 区别？</h4><p><code>BroadcastReceiver</code> 和 <code>LocalBroadcastManager</code> 是 Android 中用于接收广播消息的两个类，它们之间有以下区别：</p>
<ul>
<li>范围：<code>BroadcastReceiver</code> 可以接收全局广播（Global Broadcast），即由任何应用程序发送的广播消息。它可以接收系统级别的广播（如网络变化、电量变化等）以及其他应用程序发送的广播。<code>LocalBroadcastManager</code> 只能接收本地广播（Local Broadcast），即由本应用程序内部发送的广播消息。它仅在当前应用程序的上下文中进行广播传递，不会离开应用程序边界；</li>
<li>使用方式：<code>BroadcastReceiver</code> 是一个普通的广播接收器类，可以通过在 <code>AndroidManifest.xml</code> 文件中声明来注册全局广播接收器。也可以使用动态注册的方式，在代码中指定接收的广播类型和处理逻辑。<code>LocalBroadcastManager</code> 是一个用于处理本地广播的辅助类。我们可以通过调用 <code>LocalBroadcastManager.getInstance(Context)</code> 来获取 <code>LocalBroadcastManager</code> 的实例，并使用它注册和发送本地广播；</li>
<li>效率和性能：由于 <code>LocalBroadcastManager</code> 只在应用程序内部进行广播传递，不需要经过进程间通信（IPC），因此比全局广播具有更高的效率和性能。<code>LocalBroadcastManager</code> 使用了内存级别的消息传递，避免了序列化和反序列化的开销，同时也减少了系统资源的消耗。</li>
</ul>
<p>综上所述，<code>BroadcastReceiver</code> 适用于接收全局广播，可以接收其他应用程序和系统级别的广播消息。而 <code>LocalBroadcastManager</code> 适用于接收本地广播，只在应用程序内部进行广播传递，具有更高的安全性和性能。根据具体的需求和场景，选择合适的广播接收器类进行使用。</p>
<h4 id="⭐️-注册广播有几种方式，这些方式有何优缺点？"><a href="#⭐️-注册广播有几种方式，这些方式有何优缺点？" class="headerlink" title="⭐️ 注册广播有几种方式，这些方式有何优缺点？"></a>⭐️ 注册广播有几种方式，这些方式有何优缺点？</h4><p>在 Android 中，注册广播接收器有以下几种方式：</p>
<ul>
<li>在清单文件中静态注册：通过在 <code>AndroidManifest.xml</code> 文件中声明广播接收器，并指定接收的广播类型，系统会在应用安装时自动注册和管理广播接收器。这种方式适用于需要在应用未运行时也能接收广播的场景。优点是方便，无需手动注册和注销；缺点是无法动态控制广播接收器的生命周期，广播接收器将在应用安装后一直存在。</li>
<li>动态注册：通过在代码中使用registerReceiver()方法动态注册广播接收器，可以在特定的时机注册和注销广播接收器。这种方式适用于需要动态控制广播接收器生命周期的场景，如在特定页面打开时注册广播接收器，页面关闭时注销广播接收器。优点是灵活性高，可以根据需要控制注册和注销；缺点是需要手动管理广播接收器的生命周期。</li>
<li>本地广播：本地广播是一种只在应用内部传播的广播，通过使用 <code>LocalBroadcastManager</code> 类发送和接收广播。本地广播不会离开应用，因此安全性更高且效率更高。本地广播适用于应用内部的通信，不需要与其他应用共享广播。优点是安全性高、效率高、易于使用；缺点是只能在应用内部传播，无法与其他应用通信。</li>
</ul>
<p>每种方式都有其适用的场景和优缺点，选择合适的方式取决于具体需求：</p>
<ul>
<li>静态注册适用于应用未运行时也需要接收广播的情况，如开机启动广播等。但它无法动态控制广播接收器的生命周期，可能会导致不必要的资源消耗；</li>
<li>动态注册适用于需要在特定时机注册和注销广播接收器的场景，可以灵活地控制广播接收器的生命周期。但需要手动管理广播接收器的注册和注销，增加了一定的代码复杂性；</li>
<li>本地广播适用于应用内部的通信，具有较高的安全性和效率。但它只能在应用内部传播，无法与其他应用共享广播；</li>
</ul>
<h4 id="⭐️-谈一谈-startService-和-bindService-的区别，生命周期以及使用场景？"><a href="#⭐️-谈一谈-startService-和-bindService-的区别，生命周期以及使用场景？" class="headerlink" title="⭐️ 谈一谈 startService 和 bindService 的区别，生命周期以及使用场景？"></a>⭐️ 谈一谈 <code>startService</code> 和 <code>bindService</code> 的区别，生命周期以及使用场景？</h4><p>参见：<a href="https://qianyuebits.github.io/2024/01/18/Android-Service/">Android Service</a></p>
<h4 id="⭐️-IntentService-的应用场景和使用姿势？"><a href="#⭐️-IntentService-的应用场景和使用姿势？" class="headerlink" title="⭐️ IntentService 的应用场景和使用姿势？"></a>⭐️ <code>IntentService</code> 的应用场景和使用姿势？</h4><p><code>IntentService</code> 是 Android 提供的一种特殊的服务（Service）类，用于处理异步任务和执行后台操作，本质上是 Service + Handler 的封装。<strong>它在后台线程中逐个处理传递给它的每个 Intent 请求，并且在处理完最后一个请求后自动停止。</strong></p>
<p><code>IntentService</code> 的应用场景和使用姿势如下：</p>
<ul>
<li>异步任务处理：<code>IntentService</code> 适用于需要在后台执行异步任务的场景。比如，下载文件、上传数据、执行网络请求等任务可以放在 <code>IntentService</code> 中处理，而不会阻塞主线程；</li>
<li>顺序执行：<code>IntentService</code> 会按照请求的顺序逐个处理 Intent。这对于需要保证任务有序执行的场景非常有用；</li>
<li>自动停止：<code>IntentService</code> 在处理完最后一个 Intent 请求后会自动停止，无需手动调用 <code>stopSelf()</code> 或 <code>stopService()</code> 停止服务。这样可以避免因为忘记停止服务而导致的资源浪费；</li>
</ul>
<p>使用 <code>IntentService</code> 的方式如下：</p>
<ol>
<li>创建自定义的 <code>IntentService</code> 子类，并实现 <code>onHandleIntent()</code> 方法。在 <code>onHandleIntent()</code> 方法中处理传递给 <code>IntentService</code> 的每个 Intent 请求；</li>
<li>在需要使用 <code>IntentService</code> 的地方，创建一个新的 Intent 并调用 <code>startService()</code> 方法来启动 <code>IntentService</code>。可以通过 Intent 的附加数据传递参数给 <code>IntentService</code>；</li>
<li><code>IntentService</code> 会在后台线程中逐个处理传递给它的每个 Intent 请求。在 <code>onHandleIntent()</code> 方法中执行具体的后台操作，如网络请求、文件操作等；</li>
<li>在 <code>onHandleIntent()</code> 方法中处理完最后一个请求后，<code>IntentService</code> 会自动停止服务，无需手动调用停止服务的方法；</li>
</ol>
<p>总之，<code>IntentService</code> 适用于需要在后台执行异步任务、保证任务有序执行，并且自动停止服务的场景。它简化了后台任务的处理和服务的管理，提供了方便的异步操作机制。</p>
<h4 id="⭐️-Service-如何进行保活？"><a href="#⭐️-Service-如何进行保活？" class="headerlink" title="⭐️ Service 如何进行保活？"></a>⭐️ Service 如何进行保活？</h4><p>在 Android 中，Service 的保活是指在特定条件下，确保 Service 在后台持续运行，以便执行某些任务或提供某些功能。以下是一些常见的方法来实现 Service 的保活：</p>
<ul>
<li>前台服务（Foreground Service）：将 Service 设置为前台服务，通过调用 <code>startForeground()</code> 方法将其置于前台状态。前台服务会显示一个可见的通知，告知用户当前有一个正在运行的服务，从而提高服务的优先级，减少被系统杀死的概率；</li>
<li>使用 <code>START_STICKY</code>：在启动 Service 时，通过返回 <code>START_STICKY</code> 标志位告诉系统，如果 Service 被异常终止，系统会尝试重新启动它。这样可以保证 Service 在一定程度上持续运行。需要注意的是，当系统内存不足时，系统可能会终止 Service；</li>
<li>使用系统广播：注册一些系统广播，例如 <code>BOOT_COMPLETED</code>（开机完成）、<code>CONNECTIVITY_CHANGE</code>（网络连接变化）等，当接收到这些广播时，启动你的 Service。这样可以在特定事件发生时重新启动 Service；</li>
<li>使用 <code>AlarmManager</code>：通过 <code>AlarmManager</code> 在指定时间间隔触发一个 <code>PendingIntent</code>，启动 Service。这样可以定期唤醒 Service，确保其持续运行；</li>
<li>双进程守护：创建一个独立的进程，与主进程相互守护。当主进程被杀死时，独立进程会重新启动主进程，并重新启动 Service。</li>
</ul>
<p><strong>需要注意的是，Android 系统对于后台运行的应用有一些限制和策略，如后台应用限制、电池优化等。在实现 Service 的保活时，需要遵循系统的规则，并合理利用系统提供的机制，以避免过度耗电或影响用户体验。</strong></p>
<p>另外，需要根据具体的业务需求和应用场景来选择适合的保活方法，并进行充分的测试和优化，以确保 Service 的稳定运行。</p>
<h4 id="⭐️-说下切换横竖屏时-Activity-的生命周期"><a href="#⭐️-说下切换横竖屏时-Activity-的生命周期" class="headerlink" title="⭐️ 说下切换横竖屏时 Activity 的生命周期?"></a>⭐️ 说下切换横竖屏时 Activity 的生命周期?</h4><p>参考：<a href="https://qianyuebits.github.io/2014/05/25/Android-Activity-Lifecycle/">Android Handler</a></p>
<h4 id="⭐️-简单介绍下-ContentProvider-是如何实现数据共享的？说说-ContentProvider、ContentResolver、ContentObserver-之间的关系？"><a href="#⭐️-简单介绍下-ContentProvider-是如何实现数据共享的？说说-ContentProvider、ContentResolver、ContentObserver-之间的关系？" class="headerlink" title="⭐️ 简单介绍下 ContentProvider 是如何实现数据共享的？说说 ContentProvider、ContentResolver、ContentObserver 之间的关系？"></a>⭐️ 简单介绍下 <code>ContentProvider</code> 是如何实现数据共享的？说说 <code>ContentProvider</code>、<code>ContentResolver</code>、<code>ContentObserver</code> 之间的关系？</h4><p>具体使用例子参考，系统经典应用有”联系人”：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/providers/content-provider-creating?hl=zh-cn">创建 content provider</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/76101093">Carson带你学Android：关于ContentProvider的知识都在这里了！</a></li>
</ol>
<p><code>ContentProvider</code> 是 Android 中用于实现数据共享的组件。它提供了一种标准化的接口，允许应用程序之间共享数据，包括读取、写入、更新和删除等操作。以下是 <code>ContentProvider</code> 实现数据共享的主要步骤：</p>
<ol>
<li>定义数据模型：首先，需要定义要共享的数据的模型，即确定数据的结构和字段。这可以通过创建一个数据库表或其他数据结构来完成；</li>
<li>创建 <code>ContentProvider</code> 子类：然后，在应用的代码中创建一个继承自 <code>ContentProvider</code> 的子类。该子类负责处理与数据相关的请求和操作；</li>
<li>实现 <code>ContentProvider</code> 方法：在 <code>ContentProvider</code> 的子类中，需要实现一些关键方法，包括 <code>query()</code>、<code>insert()</code>、<code>update()</code>、<code>delete()</code> 等。这些方法用于处理对数据的查询、插入、更新和删除操作；</li>
<li>声明权限和 URI：在清单文件（<code>AndroidManifest.xml</code>）中声明 <code>ContentProvider</code>，并指定相应的权限和 URI。权限用于控制其他应用程序访问 <code>ContentProvider</code> 的权限级别，而 URI 则用于标识和访问特定的数据；</li>
<li>授权数据访问：在 <code>ContentProvider</code> 的子类中，可以通过重写 <code>onCreate()</code> 方法来执行初始化操作，并在其中完成数据源的创建或打开。同时，可以在 <code>ContentProvider</code> 的子类中定义访问数据的权限规则；</li>
<li>处理数据操作：在 <code>ContentProvider</code> 的子类中，根据传入的操作类型和参数，实现相应的数据操作逻辑。例如，在 <code>query()</code> 方法中执行数据查询，然后返回查询结果给调用者。</li>
<li>访问 <code>ContentProvider</code>：其他应用程序可以通过使用 <code>ContentResolver</code> 类来访问 <code>ContentProvider</code> 提供的数据。<code>ContentResolver</code> 提供了一组方法，用于查询、插入、更新和删除数据。</li>
</ol>
<p>通过以上步骤，<code>ContentProvider</code> 实现了数据共享的功能。其他应用程序可以通过 URI 和相应的权限来访问共享的数据，而不需要了解数据的具体实现细节。这种方式实现了应用程序之间的数据共享和解耦，提供了一种统一的数据访问方式。</p>
<p>综上：</p>
<ol>
<li>ContentProvider 用于应用向外提供增删改查功能（一般底层使用 DB）；</li>
<li>ContentResolver 用于其他应用查询 ContentProvider 提供的数据；</li>
<li>ContentObserver 用于监听数据的变化，但需要 ContentProvider 在数据变化时通过 <code>getContext().getContentResolver().notifyChange()</code> 方法主动通知，比如在 <code>delete()</code> 中调用；</li>
</ol>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><h4 id="⭐️-子线程能否更新-UI？"><a href="#⭐️-子线程能否更新-UI？" class="headerlink" title="⭐️ 子线程能否更新 UI？"></a>⭐️ 子线程能否更新 UI？</h4><p>参考：<a href="https://qianyuebits.github.io/2022/05/18/Android-Async-Update-UI/">Android 异步更新 UI</a></p>
<h4 id="⭐️-IntentFilter-是什么？有哪些使用场景？"><a href="#⭐️-IntentFilter-是什么？有哪些使用场景？" class="headerlink" title="⭐️ IntentFilter 是什么？有哪些使用场景？"></a>⭐️ <code>IntentFilter</code> 是什么？有哪些使用场景？</h4><p>为了通知系统它们可以处理哪些隐式意图，活动、服务和广播接收器可以具有一个或多个意图过滤器。案例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;activity android:name=<span class="string">&quot;.FlingActivity&quot;</span>&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name=<span class="string">&quot;com.hly.view.fling&quot;</span>/&gt;</span><br><span class="line">        &lt;category android:name=<span class="string">&quot;android.intent.category.DEFAULT&quot;</span>/&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">&lt;/activity&gt;</span><br></pre></td></tr></table></figure>
<p>跳转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Intent</span> <span class="variable">intent</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Intent</span>();</span><br><span class="line">intent.setAction(<span class="string">&quot;com.hly.view.fling&quot;</span>);</span><br><span class="line">startActivity(intent);</span><br></pre></td></tr></table></figure>

<h4 id="⭐️-AIntent-传输数据的大小有限制吗？如何解决？"><a href="#⭐️-AIntent-传输数据的大小有限制吗？如何解决？" class="headerlink" title="⭐️ AIntent 传输数据的大小有限制吗？如何解决？"></a>⭐️ AIntent 传输数据的大小有限制吗？如何解决？</h4><p>参考：<a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/activities/parcelables-and-bundles?hl=zh-cn">Parcelable 和 Bundle</a></p>
<p>The Binder transaction buffer has a limited fixed size, currently 1MB, which is shared by all transactions in progress for the process. Since this limit is at the process level rather than at the per activity level, these transactions include all binder transactions in the app such as onSaveInstanceState, startActivity and any interaction with the system. When the size limit is exceeded, a TransactionTooLargeException is thrown.</p>
<p>When sending data via an intent, you should be careful to limit the data size to a few KB. Sending too much data can cause the system to throw a TransactionTooLargeException exception.</p>
<p>For the specific case of savedInstanceState, the amount of data should be kept small because the system process needs to hold on to the provided data for as long as the user can ever navigate back to that activity (even if the activity’s process is killed). We recommend that you keep saved state to less than 50k of data.</p>
<ol>
<li>Binder 的缓冲区只有 1M 大小，但这是进程公用的，实际大小不足 1M；</li>
<li>建议通过 Bundle 传输的数据控制在 50KB 以内；</li>
</ol>
<h4 id="⭐️-介绍一下-Android-事件的分发流程（onTouchEvent-、onTouch-、onClick-、onLongClick-的先后顺序）📚"><a href="#⭐️-介绍一下-Android-事件的分发流程（onTouchEvent-、onTouch-、onClick-、onLongClick-的先后顺序）📚" class="headerlink" title="⭐️ 介绍一下 Android 事件的分发流程（onTouchEvent()、onTouch()、onClick()、onLongClick() 的先后顺序）📚"></a>⭐️ 介绍一下 Android 事件的分发流程（<code>onTouchEvent()</code>、<code>onTouch()</code>、<code>onClick()</code>、<code>onLongClick()</code> 的先后顺序）📚</h4><p>View 的事件的调度顺序是 <code>onTouchListener</code> &gt; <code>onTouchEvent</code> &gt; <code>onLongClickListener</code> &gt; <code>onClickListener</code>，其中 <code>dispatchTouchEvent</code> 会调用 <code>onInterceptTouchEvent</code>、<code>onTouchListener</code> 和 <code>onTouchEvent</code>，<code>onTouchEvent</code> 又会判断 <code>onLongClickListener</code> 和 <code>onClickListener</code>，事件是否被消费由返回值决定，true 表示消费，false 表示不消费，与是否使用了事件无关。</p>
<h4 id="⭐️-View-的绘制流程-📚"><a href="#⭐️-View-的绘制流程-📚" class="headerlink" title="⭐️ View 的绘制流程 📚"></a>⭐️ View 的绘制流程 📚</h4><ol>
<li>看 <code>ViewRootImpl.performTraversals()</code> 方法即可；</li>
<li>分为 measure、layout、draw 三个步骤；<ul>
<li>measure 中涉及到父 View 结合自身布局属性和子 View 布局属性为子 View 设置对应的宽高；</li>
<li>layout 和 measure 一样，会有遍历子 View 的过程；</li>
<li>draw 中涉及到硬件加速是否开启、以及背景&#x2F;内容&#x2F;fading edge&#x2F;滚动条的绘制顺序；</li>
</ul>
</li>
<li>3 个重要方法：<code>invalidate()</code>&#x2F;<code>postInvalidate()</code>&#x2F;<code>requestLayout</code>；</li>
</ol>
<h4 id="⭐️-Window-和-DecorView-是什么？DecorView-又是如何和-Window-建立联系的？📚"><a href="#⭐️-Window-和-DecorView-是什么？DecorView-又是如何和-Window-建立联系的？📚" class="headerlink" title="⭐️ Window 和 DecorView 是什么？DecorView 又是如何和 Window 建立联系的？📚"></a>⭐️ Window 和 <code>DecorView</code> 是什么？<code>DecorView</code> 又是如何和 Window 建立联系的？📚</h4><p>Activity 持有 PhoneWindow（Window 子类），然后持有 WindowManager，然后持有 WindowManagerGlobal（单例），然后持有 ViewRootImpl，然后持有 DecorView。</p>
<p>DecorView 是 ContentView 的父节点。</p>
<h4 id="⭐️-谈一谈-Activity，View，Window-三者的关系？📚"><a href="#⭐️-谈一谈-Activity，View，Window-三者的关系？📚" class="headerlink" title="⭐️ 谈一谈 Activity，View，Window 三者的关系？📚"></a>⭐️ 谈一谈 Activity，View，Window 三者的关系？📚</h4><h4 id="⭐️-简述一下-Android-中-UI-的刷新机制？invalidate-和-postInvalidate-的区别？"><a href="#⭐️-简述一下-Android-中-UI-的刷新机制？invalidate-和-postInvalidate-的区别？" class="headerlink" title="⭐️ 简述一下 Android 中 UI 的刷新机制？invalidate() 和 postInvalidate() 的区别？"></a>⭐️ 简述一下 Android 中 UI 的刷新机制？<code>invalidate()</code> 和 <code>postInvalidate()</code> 的区别？</h4><p><code>postInvalidate()</code> 最终调用到的是 <code>invalidate()</code>，区别是 <code>postInvalidate()</code> 可以从非主线程调用。</p>
<h4 id="⭐️-Android-中的动画有哪几类，它们的特点和区别是什么"><a href="#⭐️-Android-中的动画有哪几类，它们的特点和区别是什么" class="headerlink" title="⭐️ Android 中的动画有哪几类，它们的特点和区别是什么"></a>⭐️ Android 中的动画有哪几类，它们的特点和区别是什么</h4><p>在 Android 中，常见的动画可以分为以下几类：</p>
<ol>
<li>View 动画（View Animation）：<ul>
<li>特点：View 动画是一种补间动画（Tween Animation），通过对视图的属性进行逐帧动画的变化来实现动画效果。它可以应用于任何视图对象，并支持平移、缩放、旋转和透明度等基本动画效果。</li>
<li>区别：<strong>View 动画只是改变了视图的外观，而不会改变视图的实际位置和大小。</strong>它适用于简单的动画效果，但对于复杂的动画或需要与用户交互的场景可能不够灵活。</li>
</ul>
</li>
<li>属性动画（Property Animation）：<ul>
<li>特点：属性动画是一种更灵活和强大的动画机制，可以对任意对象的属性进行动画操作。它通过改变属性值的方式来实现动画效果，可以实现平移、缩放、旋转、透明度等动画效果，并且可以支持更复杂的动画组合和交互。</li>
<li>区别：属性动画可以直接改变视图对象的属性值，因此在动画过程中可以实时响应布局的改变。与 View 动画相比，属性动画更加灵活、功能更强大，适用于更复杂的动画场景。API level 11（3.0）才支持。</li>
</ul>
</li>
<li>帧动画（Frame Animation）：<ul>
<li>特点：帧动画是一种基于逐帧图像的动画效果，通过连续播放一系列预定义的图像（帧）来实现动画效果。每帧之间的切换由系统自动处理，可以创建逐帧的动画效果。</li>
<li>区别：帧动画适用于不需要复杂交互和过渡效果的简单动画场景。它会将所有帧图像加载到内存中，可能会占用较多的内存资源，因此对于帧数较多或图像较大的动画，需要注意内存的消耗。</li>
</ul>
</li>
<li>转场动画（Transition Animation）：<ul>
<li>特点：转场动画是一种用于在不同视图之间进行过渡的动画效果。它可以实现淡入淡出、滑动、缩放等过渡效果，用于改变应用界面的视觉效果，提供流畅的界面切换体验。</li>
<li>区别：转场动画主要用于界面之间的切换和过渡效果，可以通过 <code>TransitionManager</code> 类和相关的过渡效果类来实现。</li>
</ul>
</li>
</ol>
<p>这些动画类别各有特点和适用场景。在选择使用动画时，需要根据具体的需求和效果来选择合适的动画类型。例如，简单的视图动画可以使用 View 动画，需要更复杂的效果和交互则可以使用属性动画，切换界面时可以考虑转场动画等。</p>
<h4 id="⭐️-Parcelable-和-Serializable-区别"><a href="#⭐️-Parcelable-和-Serializable-区别" class="headerlink" title="⭐️ Parcelable 和 Serializable 区别"></a>⭐️ <code>Parcelable</code> 和 <code>Serializable</code> 区别</h4><p>在 Android 开发中，<code>Parcelable</code> 和 <code>Serializable</code> 是两种用于实现对象序列化的机制。它们在实现和性能方面有以下区别：</p>
<ol>
<li>实现方式：</li>
</ol>
<ul>
<li><code>Serializable</code>：<code>Serializable</code> 是 Java 平台提供的标准序列化机制。要使一个类可序列化，只需实现 <code>Serializable</code> 接口，然后框架会自动进行序列化和反序列化；</li>
<li><code>Parcelable</code>：<code>Parcelable</code> 是 Android 特定的接口，需要手动实现序列化和反序列化的逻辑。要使用 <code>Parcelable</code>，必须实现 <code>Parcelable</code> 接口并实现 <code>writeToParcel()</code> 和 <code>createFromParcel()</code> 方法；</li>
</ul>
<ol start="2">
<li>性能：</li>
</ol>
<ul>
<li><code>Parcelable</code> 通常比 <code>Serializable</code> 具有更高的性能（有测试文章表明 10x 的差距）。<code>Parcelable</code> 在序列化和反序列化过程中的开销较小，因为它是手动在内存操作的，不需要通过反射和字节码分析；</li>
<li><code>Serializable</code> 需要通过 Java 的反射机制，产生很多临时对象，这可能会导致一些性能损耗；</li>
</ul>
<p>总结来说：</p>
<ol>
<li>在 Android 上如果可以使用 <code>Parcelable</code> 还是使用 <code>Parcelable</code> 为好；如果偷懒，在对象大小较小的情况下，也可以使用 <code>Serializable</code>；</li>
<li>网络传输和保存至磁盘的时候用 <code>Serializable</code>，相对而言，它更通用；</li>
</ol>
<h4 id="⭐️-include、merge、ViewStub-的作用"><a href="#⭐️-include、merge、ViewStub-的作用" class="headerlink" title="⭐️ include、merge、ViewStub 的作用"></a>⭐️ <code>include</code>、<code>merge</code>、<code>ViewStub</code> 的作用</h4><ul>
<li><code>include</code> 布局文件复用</li>
<li><code>merge</code> include 布局文件时可以减少布局层级</li>
<li><code>ViewStub</code> 与 <code>include</code> 类似，但是按需加载，需要手动调用 <code>inflate()</code> 方法，注意，此时引用的文件不能使用 <code>merge</code> 标签；</li>
</ul>
<h4 id="⭐️-px、dp、sp-的区别"><a href="#⭐️-px、dp、sp-的区别" class="headerlink" title="⭐️ px、dp、sp 的区别"></a>⭐️ px、dp、sp 的区别</h4><ul>
<li><code>px</code> 即像素，1px 代表屏幕上一个物理的像素点；</li>
<li><code>dp</code> device independent pixels（设备独立像素），px &#x3D; dp * (dpi&#x2F;160)，其中 dpi 即像素密度，定义这个单位的目的是为了使得不同的像素密度的设备上显示的 View 有相同的物理尺寸；</li>
<li><code>sp</code> 与缩放无关的抽象像素（Scale-independent Pixel），支持自提大小调整；</li>
</ul>
<h4 id="⭐️-使用-Fragment-有什么好处？有没有使用过嵌套-Fragment？"><a href="#⭐️-使用-Fragment-有什么好处？有没有使用过嵌套-Fragment？" class="headerlink" title="⭐️ 使用 Fragment 有什么好处？有没有使用过嵌套 Fragment？"></a>⭐️ 使用 Fragment 有什么好处？有没有使用过嵌套 Fragment？</h4><p>Fragment 表示应用界面中可重复使用的一部分。Fragment 定义和管理自己的布局，具有自己的生命周期，并且可以处理自己的输入事件。Fragment 不能独立存在，而是必须由 Activity 或另一个 Fragment 托管。Fragment 的视图层次结构会成为宿主的视图层次结构的一部分，或附加到宿主的视图层次结构。</p>
<p><strong>Fragment 允许您将界面划分为离散的区块，从而将模块化和可重用性引入 Activity 的界面。Activity 是围绕应用的界面放置全局元素（如抽屉式导航栏）的理想位置。相反，Fragment 更适合定义和管理单个屏幕或部分屏幕的界面。</strong></p>
<h4 id="⭐️-进程优先级"><a href="#⭐️-进程优先级" class="headerlink" title="⭐️ 进程优先级"></a>⭐️ 进程优先级</h4><p>在 Android 中，进程的优先级可以分为以下几个级别，按优先级从高到低排列：</p>
<ol>
<li><strong>前台进程（Foreground Process）</strong> 前台进程是指当前对用户可见并与用户正在交互的应用进程。例如，正在展示前台界面、正在播放音乐或执行前台服务的进程都属于前台进程。前台进程拥有最高的优先级，系统会尽可能保持其运行，并在内存不足时尽量不回收前台进程。</li>
<li><strong>可见进程（Visible Process）</strong> 可见进程是指虽然没有在前台展示界面，但对用户可见的应用进程。例如，一个 Activity 被另一个 Activity 部分遮挡时，被遮挡的 Activity 所在的进程就是可见进程。可见进程的优先级较高，但低于前台进程，当系统内存不足时可能会被回收。</li>
<li><strong>服务进程（Service Process）</strong> 服务进程是指正在执行后台服务的应用进程。后台服务在没有与用户直接交互的情况下执行一些长时间运行的任务。服务进程的优先级低于前台和可见进程，但高于后台进程。当系统内存不足时，服务进程可能会被回收。</li>
<li><strong>后台进程（Background Process）</strong> 后台进程是指没有对用户可见且没有正在执行前台服务的应用进程。这些进程处于后台运行，不直接与用户交互，且对系统性能影响较小。后台进程的优先级较低，当系统内存不足时容易被系统回收。</li>
<li><strong>空进程（Empty Process）</strong> 空进程是指没有任何活动组件（如 Activity、Service）的应用进程。这些进程被系统保留，以缩短后续创建组件的时间。空进程的优先级最低，当系统需要更多内存时，空进程会被优先回收。</li>
</ol>
<p>需要注意的是，Android 系统会根据当前的内存使用情况和进程的活动状态动态调整进程的优先级，并根据需要进行回收。此外，应用可以通过设置进程的优先级、使用前台服务等方式来影响进程的优先级和保活能力，但也需要注意平衡系统资源和用户体验的关系。</p>
<h4 id="⭐️-什么是-ANR-如何避免它？"><a href="#⭐️-什么是-ANR-如何避免它？" class="headerlink" title="⭐️ 什么是 ANR 如何避免它？"></a>⭐️ 什么是 ANR 如何避免它？</h4><p>ANR（Application Not Responding）是指应用程序未响应，Android 系统对于一些事件需要在一定时间范围内完成，如果超过预定时间未能得到有效响应或者响应时间过长，都会造成 ANR。具体场景：</p>
<ol>
<li>点击事件（按键和触摸事件）5s 内没被处理；</li>
<li>Service：前台 Service 20s，后台 Service 200s 未完成启动；</li>
<li>BroadcastReceiver：前台广播 10s，后台广播 60s，<code>onReceive()</code> 在规定时间内没处理完；</li>
<li>ContentProvider：publish 在 10s 内没处理完；<br>避免办法：不要在主线程做耗时操作。</li>
</ol>
<h4 id="⭐️-assets-目录与-res-目录的区别？"><a href="#⭐️-assets-目录与-res-目录的区别？" class="headerlink" title="⭐️ assets 目录与 res 目录的区别？"></a>⭐️ assets 目录与 res 目录的区别？</h4><p>在 Android 项目中，<code>assets</code> 目录和 <code>res</code> 目录是用于存放不同类型资源的两个不同目录，它们有以下区别：</p>
<ol>
<li><p>存放位置：</p>
<ul>
<li><code>assets</code> 目录位于 Android 项目的根目录下，与 <code>src</code>、<code>res</code> 目录同级。</li>
<li><code>res</code> 目录位于 <code>app</code> 模块的 <code>src</code> 目录下，通常是 <code>app/src/main/res</code>。</li>
</ul>
</li>
<li><p>访问方式：</p>
<ul>
<li><code>assets</code> 目录中的资源通过 <code>AssetManager</code> 类进行访问。可以使用 <code>AssetManager</code> 的 <code>open()</code> 方法打开文件流来读取 <code>assets</code> 目录下的资源文件。</li>
<li><code>res</code> 目录中的资源通过自动生成的 <code>R</code> 类进行访问。可以通过 <code>R</code> 类的相应字段获取资源的 ID，然后使用 <code>Context</code> 的方法（如 <code>getResources()</code>）来获取资源的实际值。</li>
</ul>
</li>
<li><p>资源类型：</p>
<ul>
<li><code>assets</code> 目录可以存放任意类型的文件，如文本文件、音频文件、视频文件等。在编译打包过程中，<code>assets</code> 目录下的文件会被原封不动地复制到 APK 包中。</li>
<li><code>res</code> 目录用于存放特定类型的资源文件，如布局文件、字符串资源、图像资源、颜色资源等。这些资源文件会在编译过程中经过处理和优化，并生成相应的二进制资源文件，最终打包到 APK 中。</li>
</ul>
</li>
<li><p>资源访问和国际化：</p>
<ul>
<li><code>assets</code> 目录下的资源文件没有经过 Android 资源管理系统的处理，无法直接进行国际化、主题切换等功能。访问时需要自行处理资源的加载和适配。</li>
<li><code>res</code> 目录下的资源文件可以通过资源的不同配置（如语言、屏幕密度、主题等）自动适配，并由 Android 系统根据设备的配置自动选择最佳匹配的资源。</li>
</ul>
</li>
</ol>
<p>综上所述，<code>assets</code> 目录适合存放一些非特定类型的资源文件，如自定义数据文件、原始媒体文件等。而 <code>res</code> 目录则用于存放经过处理和优化的特定类型资源文件，可以通过资源管理系统进行访问、适配和国际化。</p>
<h4 id="⭐️-说说-WorkManager"><a href="#⭐️-说说-WorkManager" class="headerlink" title="⭐️ 说说 WorkManager"></a>⭐️ 说说 <code>WorkManager</code></h4><p><code>WorkManager</code> 是 Android Jetpack 组件之一，用于执行可延迟、周期性或需要在后台运行的任务。它提供了一种方便、灵活且可靠的方式来处理后台任务，如数据同步、日志上传、本地数据库清理等。</p>
<p><code>WorkManager</code> 的主要作用包括：</p>
<ol>
<li>后台任务调度：<code>WorkManager</code> 提供了一个统一的接口来调度和执行后台任务。它考虑了设备的状态、电量优化和系统限制，并选择最佳的执行时机来运行任务，以最大程度地减少对电池寿命和设备性能的影响。</li>
<li>灵活性和可靠性：<code>WorkManager</code> 提供了灵活的任务调度选项，包括延迟执行、周期性执行、指定重试策略等。它还保证任务的可靠执行，即使应用程序被杀死或设备重启，<code>WorkManager</code> 也会在适当的时候重新启动和执行任务。</li>
<li>兼容性：<code>WorkManager</code> 兼容 Android 4.0（API 级别 14）及更高版本，可以在广泛的 Android 设备上使用。</li>
<li>生命周期感知：<code>WorkManager</code> 可以感知应用程序的生命周期，并根据应用程序的状态来调度任务。例如，可以配置任务在设备处于空闲状态时执行，或者在应用程序处于前台时延迟执行任务。</li>
<li>链式任务和任务依赖：<code>WorkManager</code> 支持链式任务和任务依赖关系，可以定义一系列任务并指定它们的执行顺序和条件。</li>
<li>跨进程通信：<code>WorkManager</code> 可以在不同的进程之间进行通信，并执行跨进程的后台任务。</li>
</ol>
<p>通过使用 <code>WorkManager</code>，开发者可以简化后台任务的管理和调度，避免了直接使用传统的后台服务或线程池时所面临的复杂性和不稳定性。它提供了高度可靠且与系统协同工作的后台任务执行机制，使开发者能够专注于业务逻辑的实现而不必过多关注底层的细节。</p>
<h4 id="⭐️-PathClassLoader-和-DexClassLoader-有何区别？"><a href="#⭐️-PathClassLoader-和-DexClassLoader-有何区别？" class="headerlink" title="⭐️ PathClassLoader 和 DexClassLoader 有何区别？"></a>⭐️ <code>PathClassLoader</code> 和 <code>DexClassLoader</code> 有何区别？</h4><p><code>PathClassLoader</code> 和 <code>DexClassLoader</code> 是 Android 中用于加载类和资源的两个类加载器，它们有以下区别：</p>
<ol>
<li><p>加载方式：</p>
<ul>
<li><code>PathClassLoader</code> 是 Android 系统默认的类加载器，用于加载应用的 APK 文件中的类和资源。它会在应用启动时自动创建，并根据应用的 <code>Classpath</code> 加载类。</li>
<li><code>DexClassLoader</code> 是 <code>PathClassLoader</code> 的子类，用于加载存储在文件系统上的独立的 Dex 文件（Dalvik Executable）。它可以加载不同路径下的 Dex 文件，包括外部存储卡或网络上的 Dex 文件。</li>
</ul>
</li>
<li><p>加载范围：</p>
<ul>
<li><code>PathClassLoader</code> 只能加载应用的 APK 文件中的类和资源，即应用内部的类和资源。</li>
<li><code>DexClassLoader</code> 可以加载外部的 Dex 文件，因此可以用于加载动态下载的 Dex 文件、插件化开发等场景。</li>
</ul>
</li>
<li><p>类加载优先级：</p>
<ul>
<li><code>PathClassLoader</code> 是应用的默认类加载器，它会优先加载应用内部的类。如果应用内部找不到对应的类，则会委托给父类加载器（一般为 BootClassLoader）进行加载。</li>
<li><code>DexClassLoader</code> 是一个独立的类加载器，它会优先加载外部的 Dex 文件中的类。如果外部 Dex 文件找不到对应的类，则会委托给父类加载器（一般为 <code>PathClassLoader</code>）进行加载。</li>
</ul>
</li>
</ol>
<p>综上所述，<code>PathClassLoader</code> 用于加载应用内部的类和资源，是默认的类加载器；而 <code>DexClassLoader</code> 则能加载外部的 Dex 文件，具有更高的灵活性和危险性，适用于动态加载和插件化开发等场景。</p>
<h4 id="⭐️-为什么推荐用-SparseArray-代替-HashMap？"><a href="#⭐️-为什么推荐用-SparseArray-代替-HashMap？" class="headerlink" title="⭐️ 为什么推荐用 SparseArray 代替 HashMap？"></a>⭐️ 为什么推荐用 <code>SparseArray</code> 代替 HashMap？</h4><p>在 Android 开发中，推荐使用 <code>SparseArray</code> 类来代替 <code>HashMap</code> 的主要原因是 <code>SparseArray</code> 在某些场景下可以提供更高的性能和更低的内存消耗，特别是当键的范围是整型时。</p>
<p>以下是一些使用 <code>SparseArray</code> 的优势：</p>
<ol>
<li><p>内存消耗更低：</p>
<ul>
<li><code>SparseArray</code> 采用了一种特殊的数据结构，它使用两个数组来存储键值对，一个数组存储键的哈希值，另一个数组存储对应的值。相比之下，<code>HashMap</code> 需要使用对象包装器（<code>Integer</code>）作为键，因此会占用更多的内存。当存储大量数据时，<code>SparseArray</code> 可以显著减少内存开销。</li>
</ul>
</li>
<li><p>性能更高：</p>
<ul>
<li><code>SparseArray</code> 使用二分查找算法来查找键，因此在查找操作上具有较快的速度。相比之下，<code>HashMap</code> 使用哈希算法来查找键，当哈希冲突较多时，查找效率可能会下降。</li>
</ul>
</li>
<li><p>自动装箱和拆箱的避免：</p>
<ul>
<li>在使用 <code>HashMap</code> 时，由于整型键需要被包装为 <code>Integer</code> 对象，会涉及到自动装箱和拆箱的操作，增加了额外的开销。而 <code>SparseArray</code> 的键直接使用原始的整型数据类型，避免了这种开销。</li>
</ul>
</li>
</ol>
<p>需要注意的是，<code>SparseArray</code> 适用于键的范围是整型的情况，如果键的范围是其他类型（如字符串）或者需要支持更多的功能（如迭代、排序等），则 <code>HashMap</code> 仍然是更合适的选择。在选择使用 <code>SparseArray</code> 或 <code>HashMap</code> 时，需要根据具体的需求和数据特征进行权衡和取舍。</p>
<h4 id="⭐️-什么是-RemoteViews？使用场景有哪些？"><a href="#⭐️-什么是-RemoteViews？使用场景有哪些？" class="headerlink" title="⭐️ 什么是 RemoteViews？使用场景有哪些？"></a>⭐️ 什么是 <code>RemoteViews</code>？使用场景有哪些？</h4><p><code>RemoteViews</code> 是 Android 中的一个特殊类，用于在一个应用程序的进程中创建并更新在另一个应用程序的进程中运行的布局。它允许一个应用程序通过 PendingIntent 在其他应用程序的上下文中更新布局，从而实现跨进程的界面更新。</p>
<p><code>RemoteViews</code> 的使用场景包括：</p>
<ol>
<li>桌面小部件（App Widgets）：<code>RemoteViews</code> 最常见的用途之一是创建和更新桌面小部件。通过使用 <code>RemoteViews</code>，应用程序可以在桌面上显示自定义的布局，并且可以通过更新 <code>RemoteViews</code> 来更新小部件的外观和内容。</li>
<li>通知栏（Notification）：<code>RemoteViews</code> 也可以用于创建和定制通知栏中的布局。应用程序可以使用 <code>RemoteViews</code> 创建自定义的通知栏布局，并通过将其传递给通知构建器（Notification Builder）来显示自定义通知。</li>
<li>锁屏（Lock Screen）：在某些 Android 版本中，<code>RemoteViews</code> 还可以用于在锁屏界面上显示自定义布局。应用程序可以通过创建 <code>RemoteViews</code> 并将其传递给锁屏界面来定制锁屏上的显示内容。</li>
</ol>
<p>需要注意的是，由于 <code>RemoteViews</code> 是用于在不同进程中更新布局的，因此它具有一些限制。例如，只支持一部分的布局和视图操作，不支持包括自定义 View、动态注册的广播接收器等在内的某些功能。此外，由于涉及跨进程通信，使用 <code>RemoteViews</code> 进行布局更新可能会带来一些性能开销，因此在使用时需要注意性能和效率的问题。</p>
<h4 id="⭐️-谈一谈-SurfaceView-与-TextureView-的使用场景和用法？"><a href="#⭐️-谈一谈-SurfaceView-与-TextureView-的使用场景和用法？" class="headerlink" title="⭐️ 谈一谈 SurfaceView 与 TextureView 的使用场景和用法？"></a>⭐️ 谈一谈 <code>SurfaceView</code> 与 <code>TextureView</code> 的使用场景和用法？</h4><p><code>SurfaceView</code> 和 <code>TextureView</code> 都是 Android 中用于显示图像或视频的视图类，它们在使用场景和用法上有一些区别。</p>
<p><code>SurfaceView</code> 的使用场景和用法：</p>
<ul>
<li>使用场景：适用于需要在后台线程中绘制复杂、动态内容的情况，尤其是视频播放和游戏开发等需要频繁更新图像的场景。</li>
<li>原理：<code>SurfaceView</code> 在视图层级中创建了一个独立的窗口（<code>Surface</code>），使得后台线程可以直接在该窗口上进行绘制操作，而不受主线程 UI 更新的限制。</li>
<li>用法：需要通过实现 <code>SurfaceHolder.Callback</code> 接口来获取 <code>SurfaceHolder</code> 对象，并在后台线程中通过该对象的 <code>lockCanvas()</code> 方法获取画布进行绘制操作。绘制完成后，使用 <code>unlockCanvasAndPost()</code> 方法将画布内容提交显示。</li>
</ul>
<p><code>TextureView</code> 的使用场景和用法：</p>
<ul>
<li>使用场景：适用于需要在主线程中进行图像和视频渲染，并且需要与其他视图进行交互的情况。特别适合用于实现自定义滤镜、动画效果以及与其他 UI 元素叠加的效果。</li>
<li>原理：<code>TextureView</code> 基于硬件加速的 <code>SurfaceTexture</code> 实现，可以直接与 GPU 进行交互，提供更高的图像渲染性能。</li>
<li>用法：通过调用 <code>getSurfaceTexture()</code> 方法获取 <code>SurfaceTexture</code> 对象，并将其设置给视频播放器、相机预览或自定义渲染器等，然后在主线程中使用 <code>Canvas</code>、<code>OpenGL ES</code> 或 <code>MediaPlayer</code> 等进行绘制和渲染操作。</li>
</ul>
<p>总结来说，<code>SurfaceView</code> 适合在后台线程中进行频繁的图像绘制和更新，而 <code>TextureView</code> 则更适合在主线程中进行图像和视频渲染，并与其他 UI 元素进行交互。根据具体的需求和使用场景，选择适合的视图类可以获得更好的性能和用户体验。</p>
<h4 id="⭐️-SharedPreferences-是线程安全的吗？它的-commit-和-apply-方法有什么区别？"><a href="#⭐️-SharedPreferences-是线程安全的吗？它的-commit-和-apply-方法有什么区别？" class="headerlink" title="⭐️ SharedPreferences 是线程安全的吗？它的 commit 和 apply 方法有什么区别？"></a>⭐️ <code>SharedPreferences</code> 是线程安全的吗？它的 commit 和 apply 方法有什么区别？</h4><p><code>SharedPreferences</code> 并不是线程安全的。多个线程同时对同一个 <code>SharedPreferences</code> 对象进行读写操作可能导致数据的不一致或损坏。因此，在多线程环境下使用 <code>SharedPreferences</code> 时，需要进行适当的线程同步控制，以确保数据的一致性和正确性。</p>
<p><code>commit</code> 方法和 <code>apply</code> 方法是 <code>SharedPreferences.Editor</code> 接口中用于提交修改的两种不同方式，它们的主要区别如下：</p>
<ol>
<li><p><code>commit</code> 方法：</p>
<ul>
<li>同步操作：<code>commit</code> 方法是同步的，它会阻塞当前线程，直到数据写入磁盘完成，并返回写入结果（<code>true</code> 表示成功，<code>false</code> 表示失败）。</li>
<li>返回结果：<code>commit</code> 方法返回一个布尔值，用于指示写入操作是否成功。</li>
<li>主线程注意：由于 <code>commit</code> 方法的同步特性，如果在主线程中频繁调用 <code>commit</code> 方法，可能会导致 UI 响应性能下降，因为主线程会被阻塞等待写入操作完成。</li>
</ul>
</li>
<li><p><code>apply</code> 方法：</p>
<ul>
<li>异步操作：<code>apply</code> 方法是异步的，它会立即将修改操作提交到内存中的 <code>SharedPreferences</code> 对象，然后在后台线程中异步写入磁盘，不会阻塞当前线程。</li>
<li>无返回结果：<code>apply</code> 方法没有返回值，因此无法知道写入操作是否成功。</li>
<li>主线程注意：由于 <code>apply</code> 方法是异步的，不会阻塞当前线程，因此在主线程中频繁调用 <code>apply</code> 方法不会对 UI 响应性能造成影响。</li>
</ul>
</li>
</ol>
<p>通常情况下，推荐使用 <code>apply</code> 方法进行修改提交，因为它是异步的，不会阻塞当前线程，适用于大多数场景。如果需要明确知道写入操作的结果或需要在写入操作完成后执行特定的逻辑，可以考虑使用 <code>commit</code> 方法，但需要注意在主线程中使用时可能会对响应性能产生影响。</p>
<h4 id="⭐️-什么是-Lifecycle？请分析其内部原理和使用场景？ViewModel-的出现是为了解决什么问题？并简要说说它的内部原理？（Jetpack-组件）"><a href="#⭐️-什么是-Lifecycle？请分析其内部原理和使用场景？ViewModel-的出现是为了解决什么问题？并简要说说它的内部原理？（Jetpack-组件）" class="headerlink" title="⭐️ 什么是 Lifecycle？请分析其内部原理和使用场景？ViewModel 的出现是为了解决什么问题？并简要说说它的内部原理？（Jetpack 组件）"></a>⭐️ 什么是 <code>Lifecycle</code>？请分析其内部原理和使用场景？<code>ViewModel</code> 的出现是为了解决什么问题？并简要说说它的内部原理？（Jetpack 组件）</h4><ul>
<li><code>Lifecycle</code> 是 Android Architecture Components 的一个组件，用于将系统组件（Activity、Fragment等等）的生命周期分离到 <code>Lifecycle</code> 类，<code>Lifecycle</code> 允许其他类作为观察者，观察组件生命周期的变化。</li>
<li><code>ViewModel</code> 类旨在以注重生命周期的方式存储和管理界面相关的数据。ViewModel 类让数据可在发生屏幕旋转等配置更改后继续留存。</li>
<li><code>LiveData</code> 是一种可观察的数据存储器类。与常规的可观察类不同，<code>LiveData</code> 具有生命周期感知能力，意指它遵循其他应用组件（如 Activity、Fragment 或 Service）的生命周期。这种感知能力可确保 <code>LiveData</code> 仅更新处于活跃生命周期状态的应用组件观察者。</li>
</ul>
<p>要看下源码，不复杂。</p>
<h4 id="⭐️-Java-与-JS-代码如何互调？有做过相关优化吗？"><a href="#⭐️-Java-与-JS-代码如何互调？有做过相关优化吗？" class="headerlink" title="⭐️ Java 与 JS 代码如何互调？有做过相关优化吗？"></a>⭐️ Java 与 JS 代码如何互调？有做过相关优化吗？</h4><ul>
<li>Java 调用 JS<ul>
<li>通过 <code>WebView</code> 的 <code>loadUrl()</code></li>
<li>通过 <code>WebView</code> 的 <code>evaluateJavascript()</code></li>
</ul>
</li>
<li>JS 调用 Java<ul>
<li>通过 <code>WebView</code> 的 <code>JavascriptInterface</code> 注解</li>
<li>通过 <code>WebViewClient.shouldOverrideUrlLoading()</code>，拦截加载信息</li>
<li>通过 <code>WebChromeClient.onConsoleMessage()</code>，拦截控制台信息</li>
<li>通过 <code>WebChromeClient.onJsPrompt()</code>，<code>onJsAlert()</code>、<code>onJsConfirm()</code> 拦截 Web 相应弹框的事件</li>
</ul>
</li>
</ul>
<h4 id="⭐️-什么是-JNI？具体说说如何实现-Java-与-C-的互调？"><a href="#⭐️-什么是-JNI？具体说说如何实现-Java-与-C-的互调？" class="headerlink" title="⭐️ 什么是 JNI？具体说说如何实现 Java 与 C++ 的互调？"></a>⭐️ 什么是 JNI？具体说说如何实现 Java 与 C++ 的互调？</h4><p>JNI（Java Native Interface）是 Java 提供的一组工具和机制，用于实现 Java 代码与本地代码（如 C、C++）之间的互调。它允许 Java 程序通过 JNI 接口调用本地代码，同时也允许本地代码调用 Java 方法和访问 Java 对象。</p>
<p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/afei__/article/details/81031965">JNI 静态注册和动态注册</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41540355/article/details/121985544">Java和C++通过JNI实现互相调用</a></li>
</ol>
<h4 id="⭐️-有没有看过-AsyncTask-的源码？（似乎还挺常见的）"><a href="#⭐️-有没有看过-AsyncTask-的源码？（似乎还挺常见的）" class="headerlink" title="⭐️ 有没有看过 AsyncTask 的源码？（似乎还挺常见的）"></a>⭐️ 有没有看过 <code>AsyncTask</code> 的源码？（似乎还挺常见的）</h4><p>Deprecated in API level 30。</p>
<h4 id="是否可以加载任意目录下的-so-文件，so-文件有几种加载方式？加载-so-时如何考虑-32-位和-64-位的不同，如何考虑不同的-arm-平台？"><a href="#是否可以加载任意目录下的-so-文件，so-文件有几种加载方式？加载-so-时如何考虑-32-位和-64-位的不同，如何考虑不同的-arm-平台？" class="headerlink" title="是否可以加载任意目录下的 so 文件，so 文件有几种加载方式？加载 so 时如何考虑 32 位和 64 位的不同，如何考虑不同的 arm 平台？"></a>是否可以加载任意目录下的 so 文件，so 文件有几种加载方式？加载 so 时如何考虑 32 位和 64 位的不同，如何考虑不同的 arm 平台？</h4><p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/skykingf/article/details/52371313">Android中so使用知识和问题总结以及插件开发过程中加载so的方案解析</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/dasusu/p/9810673.html">Android 的 so 文件加载机制</a></li>
</ol>
<h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><h4 id="⭐️-Android-进程间的通信方式"><a href="#⭐️-Android-进程间的通信方式" class="headerlink" title="⭐️ Android 进程间的通信方式"></a>⭐️ Android 进程间的通信方式</h4><ol>
<li>Binder</li>
<li>Socket</li>
<li>共享内存</li>
</ol>
<h4 id="⭐️-Binder-机制是如何跨进程的📚"><a href="#⭐️-Binder-机制是如何跨进程的📚" class="headerlink" title="⭐️ Binder 机制是如何跨进程的📚"></a>⭐️ Binder 机制是如何跨进程的📚</h4><h4 id="⭐️-Binder-是如何做到一次拷贝的？mmap-的内存映射原理了解吗📚"><a href="#⭐️-Binder-是如何做到一次拷贝的？mmap-的内存映射原理了解吗📚" class="headerlink" title="⭐️ Binder 是如何做到一次拷贝的？mmap 的内存映射原理了解吗📚"></a>⭐️ Binder 是如何做到一次拷贝的？<code>mmap</code> 的内存映射原理了解吗📚</h4><h4 id="⭐️-谈一谈屏幕刷新机制？📚"><a href="#⭐️-谈一谈屏幕刷新机制？📚" class="headerlink" title="⭐️ 谈一谈屏幕刷新机制？📚"></a>⭐️ 谈一谈屏幕刷新机制？📚</h4><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="⭐️-App-启动流程（Activity-的冷启动流程）📚"><a href="#⭐️-App-启动流程（Activity-的冷启动流程）📚" class="headerlink" title="⭐️ App 启动流程（Activity 的冷启动流程）📚"></a>⭐️ App 启动流程（Activity 的冷启动流程）📚</h4><h4 id="⭐️-大体说清一个应用程序安装到手机上时发生了什么？📚"><a href="#⭐️-大体说清一个应用程序安装到手机上时发生了什么？📚" class="headerlink" title="⭐️ 大体说清一个应用程序安装到手机上时发生了什么？📚"></a>⭐️ 大体说清一个应用程序安装到手机上时发生了什么？📚</h4><h3 id="系统-Service"><a href="#系统-Service" class="headerlink" title="系统 Service"></a>系统 Service</h3><h4 id="⭐️-ActivityManagerService-是什么？什么时候初始化的？有什么作用？📚"><a href="#⭐️-ActivityManagerService-是什么？什么时候初始化的？有什么作用？📚" class="headerlink" title="⭐️ ActivityManagerService 是什么？什么时候初始化的？有什么作用？📚"></a>⭐️ <code>ActivityManagerService</code> 是什么？什么时候初始化的？有什么作用？📚</h4><h4 id="AMS-是如何管理-Activity-的？"><a href="#AMS-是如何管理-Activity-的？" class="headerlink" title="AMS 是如何管理 Activity 的？"></a>AMS 是如何管理 Activity 的？</h4><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h3><h4 id="⭐️-ActivityThread-是什么？ApplicationThread-是什么？📚"><a href="#⭐️-ActivityThread-是什么？ApplicationThread-是什么？📚" class="headerlink" title="⭐️ ActivityThread 是什么？ApplicationThread 是什么？📚"></a>⭐️ <code>ActivityThread</code> 是什么？<code>ApplicationThread</code> 是什么？📚</h4><h4 id="⭐️-Instrumentation-是什么？和-ActivityThread-是什么关系？📚"><a href="#⭐️-Instrumentation-是什么？和-ActivityThread-是什么关系？📚" class="headerlink" title="⭐️ Instrumentation 是什么？和 ActivityThread 是什么关系？📚"></a>⭐️ <code>Instrumentation</code> 是什么？和 <code>ActivityThread</code> 是什么关系？📚</h4><h4 id="⭐️-ActivityManagerService-和-zygote-进程通信是如何实现的📚"><a href="#⭐️-ActivityManagerService-和-zygote-进程通信是如何实现的📚" class="headerlink" title="⭐️ ActivityManagerService 和 zygote 进程通信是如何实现的📚"></a>⭐️ <code>ActivityManagerService</code> 和 zygote 进程通信是如何实现的📚</h4><h4 id="⭐️-简述-Activity、Window、WindowManager、WindowManagerImpl、View、ViewRootImpl-的作用和相互之间的关系📚"><a href="#⭐️-简述-Activity、Window、WindowManager、WindowManagerImpl、View、ViewRootImpl-的作用和相互之间的关系📚" class="headerlink" title="⭐️ 简述 Activity、Window、WindowManager、WindowManagerImpl、View、ViewRootImpl 的作用和相互之间的关系📚"></a>⭐️ 简述 <code>Activity</code>、<code>Window</code>、<code>WindowManager</code>、<code>WindowManagerImpl</code>、<code>View</code>、<code>ViewRootImpl</code> 的作用和相互之间的关系📚</h4><h4 id="⭐️-数据库如何短时间高效批量插入数据？（SQLite）"><a href="#⭐️-数据库如何短时间高效批量插入数据？（SQLite）" class="headerlink" title="⭐️ 数据库如何短时间高效批量插入数据？（SQLite）"></a>⭐️ 数据库如何短时间高效批量插入数据？（SQLite）</h4><p>事务 + 批量插入语句。SQLite提供了一条特殊的语句可以一次性插入多条数据：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name (column1, column2) <span class="keyword">VALUES</span> (?, ?), (?, ?), ...</span><br></pre></td></tr></table></figure>

<h4 id="⭐️-如何理解-Context？ApplicationContext-和-ActivityContext-的区别-📚"><a href="#⭐️-如何理解-Context？ApplicationContext-和-ActivityContext-的区别-📚" class="headerlink" title="⭐️ 如何理解 Context？ApplicationContext 和 ActivityContext 的区别 📚"></a>⭐️ 如何理解 Context？<code>ApplicationContext</code> 和 <code>ActivityContext</code> 的区别 📚</h4><h4 id="⭐️-是否了解硬件加速？📚"><a href="#⭐️-是否了解硬件加速？📚" class="headerlink" title="⭐️ 是否了解硬件加速？📚"></a>⭐️ 是否了解硬件加速？📚</h4><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h4 id="⭐️-如何对-APK-瘦身？请提出不少于-5-个方案-📚"><a href="#⭐️-如何对-APK-瘦身？请提出不少于-5-个方案-📚" class="headerlink" title="⭐️ 如何对 APK 瘦身？请提出不少于 5 个方案 📚"></a>⭐️ 如何对 APK 瘦身？请提出不少于 5 个方案 📚</h4><h4 id="⭐️-谈谈你对-Android-性能优化方面的了解？"><a href="#⭐️-谈谈你对-Android-性能优化方面的了解？" class="headerlink" title="⭐️ 谈谈你对 Android 性能优化方面的了解？"></a>⭐️ 谈谈你对 Android 性能优化方面的了解？</h4><h4 id="⭐️-App-启动速度优化"><a href="#⭐️-App-启动速度优化" class="headerlink" title="⭐️ App 启动速度优化"></a>⭐️ App 启动速度优化</h4><p>参考：<a target="_blank" rel="noopener" href="https://androidperformance.com/2019/11/18/Android-App-Lunch-Optimize/#/%E5%BA%94%E7%94%A8%E5%90%AF%E5%8A%A8%E6%A6%82%E8%BF%B0">Android App 启动优化全记录</a></p>
<h4 id="⭐️-一般什么情况下会导致内存泄漏问题？"><a href="#⭐️-一般什么情况下会导致内存泄漏问题？" class="headerlink" title="⭐️ 一般什么情况下会导致内存泄漏问题？"></a>⭐️ 一般什么情况下会导致内存泄漏问题？</h4><ol>
<li>Context（非 Application）被持有；</li>
<li>单例；</li>
<li>非静态内部类（持有外部类的引用）：典型的如 Handler，向 Handler 里面 Post 一个消息，消息的 Target 是 Handler，Handler 又持有外部 Activity 的引用，造成泄露；</li>
<li>注册后忘记取消注册；</li>
<li>未关闭的资源，比如数据库连接，FD 等；</li>
</ol>
<p>Android Studio 提供了一些工具，可以帮助开发者检测内存泄漏问题。例如：</p>
<ul>
<li><code>Memory Profiler</code>：可用于分析应用程序的内存使用情况，并查看对象的实例数、生命周期和内存泄漏情况。</li>
<li><code>Allocation Tracker</code>：可用于跟踪对象的创建和释放，帮助开发者识别内存泄漏问题。</li>
</ul>
<p>另外开源库 <code>LeakCanary</code> 专门用于检测和记录内存泄漏情况，并提供详细的堆转储（heap dump）和内存泄漏分析。</p>
<h4 id="⭐️-自定义-Handler-时如何有效地避免内存泄漏问题？"><a href="#⭐️-自定义-Handler-时如何有效地避免内存泄漏问题？" class="headerlink" title="⭐️ 自定义 Handler 时如何有效地避免内存泄漏问题？"></a>⭐️ 自定义 Handler 时如何有效地避免内存泄漏问题？</h4><p>静态内部类 + <code>WeakReference</code></p>
<h4 id="⭐️-谈谈-Android-中内存优化的方式？"><a href="#⭐️-谈谈-Android-中内存优化的方式？" class="headerlink" title="⭐️ 谈谈 Android 中内存优化的方式？"></a>⭐️ 谈谈 Android 中内存优化的方式？</h4><p>参考 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904099998089230">深入探索 Android 内存优化</a></p>
<h4 id="⭐️-谈谈布局优化的技巧？"><a href="#⭐️-谈谈布局优化的技巧？" class="headerlink" title="⭐️ 谈谈布局优化的技巧？"></a>⭐️ 谈谈布局优化的技巧？</h4><p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45112340/article/details/128529240">一篇文章搞定《Android布局优化》</a></li>
<li><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903657310257159">Android 优化之路(一)布局优化</a></li>
</ol>
<h4 id="⭐️-谈谈-App-的电量优化？📚"><a href="#⭐️-谈谈-App-的电量优化？📚" class="headerlink" title="⭐️ 谈谈 App 的电量优化？📚"></a>⭐️ 谈谈 App 的电量优化？📚</h4><p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904195523346439">深入探索 Android 电量优化</a></p>
<p>关键点：</p>
<ol>
<li><p>Alarm wakeup</p>
</li>
<li><p>WakeLock</p>
</li>
<li><p>WiFi scans</p>
</li>
<li><p>Network</p>
</li>
<li><p>线上：通过广播通知，监控实际耗电速度；</p>
</li>
<li><p>注意上述关键点，遵循最佳实践；</p>
</li>
<li><p>线下：结合 Battery Historian 做好测试和分析工作；</p>
</li>
</ol>
<h4 id="⭐️-谈谈如何对-WebView-进行优化？"><a href="#⭐️-谈谈如何对-WebView-进行优化？" class="headerlink" title="⭐️ 谈谈如何对 WebView 进行优化？"></a>⭐️ 谈谈如何对 WebView 进行优化？</h4><p>参考：<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1058290">WebView性能、体验分析与优化</a></p>
<h4 id="⭐️-Android-Native-Crash-问题如何分析定位？📚"><a href="#⭐️-Android-Native-Crash-问题如何分析定位？📚" class="headerlink" title="⭐️ Android Native Crash 问题如何分析定位？📚"></a>⭐️ Android Native Crash 问题如何分析定位？📚</h4><h4 id="⭐️-Bitmap-使用时候注意什么？如何计算一个-Bitmap-占用内存的大小，怎么保证加载-Bitmap-不产生内存溢出？"><a href="#⭐️-Bitmap-使用时候注意什么？如何计算一个-Bitmap-占用内存的大小，怎么保证加载-Bitmap-不产生内存溢出？" class="headerlink" title="⭐️ Bitmap 使用时候注意什么？如何计算一个 Bitmap 占用内存的大小，怎么保证加载 Bitmap 不产生内存溢出？"></a>⭐️ Bitmap 使用时候注意什么？如何计算一个 Bitmap 占用内存的大小，怎么保证加载 Bitmap 不产生内存溢出？</h4><p>为了保证在加载 Bitmap 的时候不产生内存溢出，可以使用 <code>BitmapFactory</code> 进行图片压缩，主要有以下几个参数：</p>
<ul>
<li><code>BitmapFactory.Options.inJustDecodeBounds</code>：只解析长宽，方便预估图片大小 &amp; 计算缩放比例</li>
<li><code>BitmapFactory.Options.inPreferredConfig</code>：将 <code>ARGB_8888</code> 改为 <code>RGB_565</code>，改变编码方式，节约内存。</li>
<li><code>BitmapFactory.Options.inSampleSize</code>：缩放比例，根据图片宽高计算出合适的缩放比例。</li>
<li><code>BitmapFactory.Options.inBitmap</code>：Bitmap 内存复用</li>
<li><code>BitmapFactory.Options.inPurgeable</code>：让系统可以内存不足时回收内存。（This field was deprecated in API level 21.）</li>
</ul>
<p>其他重点参考 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/graphics/BitmapFactory.Options">BitmapFactory.Options</a> 本身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BitmapFactory.<span class="type">Options</span> <span class="variable">options</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BitmapFactory</span>.Options();</span><br><span class="line">options.inJustDecodeBounds = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 加载图片</span></span><br><span class="line">BitmapFactory.decodeResource(res,resId,options);</span><br><span class="line"><span class="comment">// 计算缩放比</span></span><br><span class="line">options.inSampleSize = calculateInSampleSize(options,reqHeight,reqWidth);</span><br><span class="line"><span class="comment">// 重新加载图片</span></span><br><span class="line">options.inJustDecodeBounds =<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">return</span> BitmapFactory.decodeResource(res,resId,options);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ChenYiRan123456/article/details/131310826">Android 如何加载高清大图</a>？使用 <code>BitmapRegionDecoder</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">newInstance(InputStream is) <span class="comment">// 从输入流加载</span></span><br><span class="line">newInstance(String pathName) <span class="comment">// 从文件名加载</span></span><br><span class="line">decodeRegion(Rect rect, BitmapFactory.Options options) <span class="comment">// 解码某个区域</span></span><br></pre></td></tr></table></figure>

<p>备注：<br><strong>Bitamp 占用内存大小 &#x3D; 宽度像素 x （inTargetDensity &#x2F; inDensity） x 高度像素 x （inTargetDensity &#x2F; inDensity）x 一个像素所占的内存</strong><br>注：这里 <code>inDensity</code> 表示目标图片的 dpi（放在哪个资源文件夹下），<code>inTargetDensity</code> 表示目标屏幕的 dpi，所以你可以发现 inDensity 和 <code>inTargetDensity</code> 会对 Bitmap 的宽高进行拉伸，进而改变 Bitmap 占用内存的大小。可以通过设置 <code>BitmapFactory.Options.inJustDecodeBounds</code> 参数为 true，直接获取读入的宽高。</p>
<p>在 Bitmap 里有两个获取内存占用大小的方法：</p>
<ul>
<li><code>getByteCount()</code>：API12 加入，代表存储 Bitmap 的像素需要的最少内存。</li>
<li><code>getAllocationByteCount()</code>：API19 加入，代表在内存中为 Bitmap 分配的内存大小，代替了 <code>getByteCount()</code> 方法。<br>在不复用 Bitmap 时，<code>getByteCount()</code> 和 <code>getAllocationByteCount()</code> 返回的结果是一样的。在通过复用 Bitmap 来解码图片时，那么 <code>getByteCount()</code> 表示新解码图片占用内存的大<br>小，<code>getAllocationByteCount()</code> 表示被复用 Bitmap真实占用的内存大小（即 mBuffer 的长度）。</li>
</ul>
<h4 id="⭐️-谈谈如何对网络请求进行优化？📚"><a href="#⭐️-谈谈如何对网络请求进行优化？📚" class="headerlink" title="⭐️ 谈谈如何对网络请求进行优化？📚"></a>⭐️ 谈谈如何对网络请求进行优化？📚</h4><h4 id="⭐️-针对-RecyclerView-你做了哪些优化？（列表卡顿怎么优化？）"><a href="#⭐️-针对-RecyclerView-你做了哪些优化？（列表卡顿怎么优化？）" class="headerlink" title="⭐️ 针对 RecyclerView 你做了哪些优化？（列表卡顿怎么优化？）"></a>⭐️ 针对 <code>RecyclerView</code> 你做了哪些优化？（列表卡顿怎么优化？）</h4><ol>
<li>在 <code>Adapter</code> 中最好不要进行任何的逻辑操作，比如日期转换，字符串切割等等，可以在 model 内部自行添加一个参数使用 <code>by lazy</code> 来存储数据转换后的结果，这样数据逻辑操作就只执行一次，而不会随着数据回收重复计算</li>
<li>新增删除数据不刷线全部，而是刷新局部</li>
<li>布局优化，尽量少的布局嵌套，尽量少的控件</li>
<li>资源文件的读取，初始化的时候使用 <code>by lazy</code> 生成</li>
<li>如果 <code>RecyclerView</code> 条目高度固定，使用 <code>setHasFixedSize（true）</code>，避免多次测量条目高度</li>
<li>对于 <code>RecyclerView</code>，如果不需要动画，就把条目显示动画取消 <code>setSupportsChangeAnimations（false）</code></li>
<li>在 <code>RecyclerView</code> 添加滑动监听，一些图片加载可以在 <code>RecyclerView</code> 快速滑动的时候不进行加载图片</li>
<li>对于一个页面中的多个 <code>RecyclerView</code>，如果使用同一个 Adapter，可以使用 <code>setRecycledViewPool（pool）</code>，共用回收池，<br>避免来每一个 <code>RecyclerView</code> 都创建一个回收池，特别是 <code>RecyclerView</code> 嵌套 <code>RecyclerView</code> 时候，<br>内部的 <code>RecyclerView</code> 必定使用的都是同一个 Adapter，这个时候就很有必要使用回收池了</li>
<li>视情况使用 <code>setItemViewCacheSize（size）</code> 来加大 <code>RecyclerView</code> 缓存数目，用空间换取时间提高流畅度</li>
<li>对于条目点击时间不要在复用部分进行 <code>setOnClickListener</code>，这样会重复设置点击监听，而是应该创建一个 listener 对象，<br>传入控件的 id，和当前的条目 position，通过 id 和 position 判断处理点击监听</li>
<li>可以进行预加载，重写 <code>LayoutManager</code> 的 <code>getExtraLayoutSpace()</code> 方法，可以返回屏幕高度，预先加载一屏幕高度的数据，<br>视情况，例如：一个 item 就占据一个页面，<code>RecyclerView</code> 滑动到第二张，此时第一张可见，<code>RecyclerView</code> 无法找到可复用<br>的 View，此时会重新 new 一个出来，滑动卡顿，第三张及以后可以找到复用的 View，滑动流畅</li>
</ol>
<h2 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h2><h4 id="⭐️-LeakCanary-原理-📚"><a href="#⭐️-LeakCanary-原理-📚" class="headerlink" title="⭐️ LeakCanary 原理 📚"></a>⭐️ LeakCanary 原理 📚</h4><h4 id="⭐️-用到的一些开源框架，介绍一个看过源码的，内部实现过程"><a href="#⭐️-用到的一些开源框架，介绍一个看过源码的，内部实现过程" class="headerlink" title="⭐️ 用到的一些开源框架，介绍一个看过源码的，内部实现过程"></a>⭐️ 用到的一些开源框架，介绍一个看过源码的，内部实现过程</h4><p>参见 <a target="_blank" rel="noopener" href="https://www.codekk.com/blogs/detail/54cfab086c4761e5001b2542">Volley 源码解析</a></p>
<h4 id="App-路由设计"><a href="#App-路由设计" class="headerlink" title="App 路由设计"></a>App 路由设计</h4><h4 id="介绍下-okhttp-中的设计模式-x2F-拦截器-x2F-连接池"><a href="#介绍下-okhttp-中的设计模式-x2F-拦截器-x2F-连接池" class="headerlink" title="介绍下 okhttp 中的设计模式&#x2F;拦截器&#x2F;连接池"></a>介绍下 okhttp 中的设计模式&#x2F;拦截器&#x2F;连接池</h4><h4 id="⭐️-请说说依赖注入框架-ButterKnife-的实现原理？"><a href="#⭐️-请说说依赖注入框架-ButterKnife-的实现原理？" class="headerlink" title="⭐️ 请说说依赖注入框架 ButterKnife 的实现原理？"></a>⭐️ 请说说依赖注入框架 <code>ButterKnife</code> 的实现原理？</h4><p>参见 <a target="_blank" rel="noopener" href="https://www.jianshu.com/p/b82ef05f3e8a">一篇文章让你搞懂 ButterKnife 使用和原理</a>。</p>
<h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h4 id="⭐️-请谈谈你对-MVC-和-MVP-的理解？📚"><a href="#⭐️-请谈谈你对-MVC-和-MVP-的理解？📚" class="headerlink" title="⭐️ 请谈谈你对 MVC 和 MVP 的理解？📚"></a>⭐️ 请谈谈你对 MVC 和 MVP 的理解？📚</h4><h4 id="⭐️-对于面向对象的六大基本原则了解多少？📚"><a href="#⭐️-对于面向对象的六大基本原则了解多少？📚" class="headerlink" title="⭐️ 对于面向对象的六大基本原则了解多少？📚"></a>⭐️ 对于面向对象的六大基本原则了解多少？📚</h4><p>SOLID + 迪米特原则</p>
<h4 id="⭐️-请列出几种常见的工厂模式并说明它们的用法？（策略-x2F-单例-x2F-工厂-x2F-建造者-x2F-责任链-x2F-代理）"><a href="#⭐️-请列出几种常见的工厂模式并说明它们的用法？（策略-x2F-单例-x2F-工厂-x2F-建造者-x2F-责任链-x2F-代理）" class="headerlink" title="⭐️ 请列出几种常见的工厂模式并说明它们的用法？（策略&#x2F;单例&#x2F;工厂&#x2F;建造者&#x2F;责任链&#x2F;代理）"></a>⭐️ 请列出几种常见的工厂模式并说明它们的用法？（策略&#x2F;单例&#x2F;工厂&#x2F;建造者&#x2F;责任链&#x2F;代理）</h4><p>参见 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000030850326">图解九种常见的设计模式</a></p>
<h4 id="⭐️-静态代理和动态代理的区别，什么场景使用？"><a href="#⭐️-静态代理和动态代理的区别，什么场景使用？" class="headerlink" title="⭐️ 静态代理和动态代理的区别，什么场景使用？"></a>⭐️ 静态代理和动态代理的区别，什么场景使用？</h4><p>参考 <a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000011291179">Java 三种代理模式：静态代理、动态代理和 cglib 代理</a></p>
<p>在 Java 中，静态代理和动态代理是实现代理模式的两种方式，它们在实现机制和使用场景上有一些区别。</p>
<p>静态代理是在编译时期就已经确定代理类的代码，并在编译时期生成代理类的字节码文件。在静态代理中，代理类和被代理类需要实现同一个接口或继承同一个父类。代理类在编译时期就已经存在，开发者需要编写代理类的代码，并在代码中显式地调用被代理类的方法。静态代理的优点是简单易懂，对被代理类的方法调用进行了封装和控制，可以在不修改原有代码的情况下增加额外的功能。但缺点是每个被代理类都需要一个对应的代理类，如果被代理类过多，代码会变得冗长且维护困难。</p>
<p>动态代理是在运行时动态生成代理类的字节码文件，并在运行时通过反射机制来动态创建代理对象。在动态代理中，代理类不需要显式地实现接口或继承父类，而是通过实现 <code>InvocationHandler</code> 接口来拦截对被代理类方法的调用。动态代理的优点是可以减少代理类的数量，通过统一的代理类可以代理多个类的方法调用，增强了代码的复用性。它还可以在运行时动态地添加、修改或删除代理类的行为。常见的动态代理实现方式有 JDK 动态代理和 CGLIB 动态代理。缺点是由于运行时生成代理类的字节码，相比静态代理，动态代理的性能会稍微差一些。</p>
<p>根据使用场景的不同，可以考虑使用静态代理或动态代理：</p>
<ul>
<li><p>静态代理适用于对特定对象的方法进行封装和控制，例如添加日志、权限验证、事务管理等。当被代理类数量较少且稳定时，静态代理是一种简单有效的选择。</p>
</li>
<li><p>动态代理适用于需要在运行时动态地代理多个类的方法调用，例如 AOP（面向切面编程）框架、远程方法调用（RMI）等。当被代理类数量较多或需要在运行时动态地增加、修改代理行为时，动态代理是更加灵活和可扩展的选择。</p>
</li>
</ul>
<p>总结：静态代理和动态代理都是实现代理模式的方式，静态代理在编译时期确定代理类，动态代理在运行时动态生成代理类。静态代理适用于对特定对象的方法进行封装和控制，而动态代理适用于动态地代理多个类的方法调用。选择使用哪种代理方式取决于具体的需求和场景。</p>
<h1 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h1><h4 id="⭐️-谈一谈-Android-的签名机制？"><a href="#⭐️-谈一谈-Android-的签名机制？" class="headerlink" title="⭐️ 谈一谈 Android 的签名机制？"></a>⭐️ 谈一谈 Android 的签名机制？</h4><p>参考：<a target="_blank" rel="noopener" href="https://source.android.com/docs/security/features/apksigning?hl=zh-cn">应用签名</a></p>
<h4 id="⭐️-安卓的-app-加固如何做"><a href="#⭐️-安卓的-app-加固如何做" class="headerlink" title="⭐️ 安卓的 app 加固如何做"></a>⭐️ 安卓的 app 加固如何做</h4><p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903952345989134">Android 应用加固原理</a></p>
<h4 id="⭐️-安卓的混淆步骤和原理是什么？"><a href="#⭐️-安卓的混淆步骤和原理是什么？" class="headerlink" title="⭐️ 安卓的混淆步骤和原理是什么？"></a>⭐️ 安卓的混淆步骤和原理是什么？</h4><p>参考：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27582991">Android 混淆那些事儿</a></p>
<h4 id="⭐️-插件化-组件化-热修复"><a href="#⭐️-插件化-组件化-热修复" class="headerlink" title="⭐️ 插件化+组件化+热修复"></a>⭐️ 插件化+组件化+热修复</h4><h4 id="⭐️-Android-的打包流程？如何实现多渠道打包？📚"><a href="#⭐️-Android-的打包流程？如何实现多渠道打包？📚" class="headerlink" title="⭐️ Android 的打包流程？如何实现多渠道打包？📚"></a>⭐️ Android 的打包流程？如何实现多渠道打包？📚</h4><h4 id="⭐️-Android-中-App-是如何沙箱化的？为何要这么做？"><a href="#⭐️-Android-中-App-是如何沙箱化的？为何要这么做？" class="headerlink" title="⭐️ Android 中 App 是如何沙箱化的？为何要这么做？"></a>⭐️ Android 中 App 是如何沙箱化的？为何要这么做？</h4><ul>
<li>Android 顺其自然地继承了 Linux 内核的安全机制，同时结合移动终端的具体应用特点，进行了许多有益的改进与提升；</li>
<li>window 与 unix&#x2F;linux 等传统操作系统以用户为中心，假设用户之间是不可信的，更多考虑如何隔离不同用户对资源（存储区域与用户文件，内存区域与用户进程，底层设备等）的访问；</li>
<li>在 Android 系统中，假设应用软件之间是不可信的，甚至用户自行安装的应用程序也是不可信的，因此，首先需要限制应用程序的功能，也就是将应用程序置于“沙箱”之内，实现应用程序之间的隔离，并且设定允许或拒绝 API 调用的权限，控制应用程序对资源的访问，如访问文件，目录，网络，传感器等；</li>
<li>Android 扩展了 Linux 内核安全模型的用户与权限机制，将多用户操作系统的用户隔离机制巧妙地移植为应用程序隔离。在 Linux 中，一个用户标识（UID）识别一个给定用户；在 Android 上，一个 UID 则识别一个应用程序。在安装应用程序时向其分配 UID。应用程序在设备上存续期间内，其 UID 保持不变。仅限用于允许或限制应用程序（而非用户）对设备资源的访问。如此，Android 的安全机制与 Linux 内核的安全模型完美衔接！不同的应用程序分别属于不同的用户，因此，应用程序运行于自己独立的进程空间，与 UID 不同的应用程序自然形成资源隔离，如此便形成了一个操作系统级别的应用程序“沙箱”；</li>
<li>应用程序进程之间，应用程序与操作系统之间的安全性由 Linux 操作系统的标准进程级安全机制实现。在默认状态下，应用程序之间无法交互，运行在进程沙箱内的应用程序没有被分配权限，无法访问系统或资源。因此，无论是直接运行于操作系统之上的应用程序，还是运行于 Dalvik 虚拟机的应用程序都得到同样的安全隔离与保护，被限制在各自“沙箱”内的应用程序互不干扰，对系统与其他应用程序的损害可降至最低；</li>
</ul>
<h4 id="⭐️-请简述-Apk-的安装过程？📚"><a href="#⭐️-请简述-Apk-的安装过程？📚" class="headerlink" title="⭐️ 请简述 Apk 的安装过程？📚"></a>⭐️ 请简述 Apk 的安装过程？📚</h4><p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7028196921143459870">“终于懂了”系列：APK安装过程 完全解析！</a></p>
<h4 id="⭐️-谈谈如何适配更多机型的？"><a href="#⭐️-谈谈如何适配更多机型的？" class="headerlink" title="⭐️ 谈谈如何适配更多机型的？"></a>⭐️ 谈谈如何适配更多机型的？</h4><p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7000329806101348360">Android 最全面的屏幕适配方案</a></p>
<h4 id="⭐️-有没有遇到-64k-问题，应该如何解决？"><a href="#⭐️-有没有遇到-64k-问题，应该如何解决？" class="headerlink" title="⭐️ 有没有遇到 64k 问题，应该如何解决？"></a>⭐️ 有没有遇到 64k 问题，应该如何解决？</h4><p>参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27219939/article/details/78116812">Android 64K限制与解决方案</a><br>Android apk 中包含了 classes.dex 文件，。dex 文件是 Dalvik 可执行的字节码文件，而。dex 文件存放的是编译之后的 Java 代码。单个。dex 文件限制最多能引用的方法数是 65536 个，包含 Android Framework、App 应用的第三方函数库、App 自身的方法。</p>
<p>关键：</p>
<ol>
<li><code>compile &#39;com.android.support:multidex:1.0.1&#39;</code></li>
<li><code>MultiDexApplication</code></li>
<li><code>MultiDex.install(this);</code> 不可继承的时候，可以使用这个方法手动调用</li>
</ol>
<h4 id="⭐️-如何优化-Gradle-的构建速度？"><a href="#⭐️-如何优化-Gradle-的构建速度？" class="headerlink" title="⭐️ 如何优化 Gradle 的构建速度？"></a>⭐️ 如何优化 Gradle 的构建速度？</h4><p>参见：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/c289ba9bfa92">Android 加快你的编译速度</a></p>
<h4 id="⭐️-如何获取-Android-设备唯一ID？"><a href="#⭐️-如何获取-Android-设备唯一ID？" class="headerlink" title="⭐️ 如何获取 Android 设备唯一ID？"></a>⭐️ 如何获取 Android 设备唯一ID？</h4><p>参考：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://source.android.com/docs/core/permissions/immutable-device-ids?hl=zh-cn">不可变的设备 ID</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/359752003">Android 获取设备唯一标识</a></li>
</ol>
<p>几个问题：</p>
<ol>
<li>本身获取就不可信；</li>
<li>Root、重置等方式可以修改 ID；</li>
<li>随着系统版本升级，导致部分 ID 不可获取或者需要权限；</li>
</ol>
<p>问题：如何获取到一个可靠的设备唯一 ID？</p>
<h4 id="⭐️-对于-GIF-图片加载有什么思路和建议？"><a href="#⭐️-对于-GIF-图片加载有什么思路和建议？" class="headerlink" title="⭐️ 对于 GIF 图片加载有什么思路和建议？"></a>⭐️ 对于 GIF 图片加载有什么思路和建议？</h4><p>参考 Glide：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sahadev_/article/details/54934472">探索Glide对Gif图片资源的获取、解析过程</a></p>
<ol>
<li>首先需要区分加载的图片类型，即网络请求拿到输入流后，获取输入流的前三个字节，若为 GIF 文件头，则返回图片类型为 GIF；</li>
<li>确认为 GIF 动图后，会构建一个 GIF 的解码器（<code>StandardGifDecoder</code>），它可以从 GIF 动图中读取每一帧的数据并转换成 Bitmap，然后使用 <code>Canvas</code> 将 <code>Bitmap</code> 绘制到 <code>ImageView</code> 上，下一帧则利用 <code>Handler</code> 发送一个延迟消息实现连续播放，所有 <code>Bitmap</code> 绘制完成后又会重新循环，所以就实现了加载 GIF 动图的效果；</li>
</ol>
<h4 id="⭐️-webp-和-svg-格式的图片各自有什么特点？应该如何在-Android-中使用？"><a href="#⭐️-webp-和-svg-格式的图片各自有什么特点？应该如何在-Android-中使用？" class="headerlink" title="⭐️ webp 和 svg 格式的图片各自有什么特点？应该如何在 Android 中使用？"></a>⭐️ webp 和 svg 格式的图片各自有什么特点？应该如何在 Android 中使用？</h4><p>参考：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7234338259357532216">关于常用JPEG、PNG、GIF、WEBP图片格式的理解</a></p>
<h4 id="⭐️-为什么要将项目迁移到-AndroidX？如何进行迁移？"><a href="#⭐️-为什么要将项目迁移到-AndroidX？如何进行迁移？" class="headerlink" title="⭐️ 为什么要将项目迁移到 AndroidX？如何进行迁移？"></a>⭐️ 为什么要将项目迁移到 AndroidX？如何进行迁移？</h4><p>参考：<a target="_blank" rel="noopener" href="https://blog.51cto.com/u_16175466/6665502">如何实现AndroidX迁移的具体操作步骤</a><br>AndroidX 对原始 Android 支持库进行了重大改进，后者现在已不再维护。androidx 软件包完全取代了支持库，不仅提供与支持库同等的功能，而且还提供了新的库，同时将这些库拆分为更细的模块，可以按需引入。</p>
<p>迁移的步骤：</p>
<ol>
<li>升级 Android Studio；</li>
<li>更新 gradle 配置文件，将对 support 库的依赖改为 androidx；</li>
<li>使用 Android Studio 提供的迁移工具（Refactor -&gt; Migrate to AndroidX），然后按照导向操作即可；</li>
<li>解决冲突；</li>
</ol>
<h4 id="⭐️-什么是-AOP？在-Android-中它有哪些应用场景？"><a href="#⭐️-什么是-AOP？在-Android-中它有哪些应用场景？" class="headerlink" title="⭐️ 什么是 AOP？在 Android 中它有哪些应用场景？"></a>⭐️ 什么是 AOP？在 Android 中它有哪些应用场景？</h4><p>AOP，Aspect Oriented Program，面向切面编程。使用场景：埋点、日志、热修、性能等。</p>
<p>AOP 的初衷：</p>
<ol>
<li>减少重复代码</li>
<li>关注点分离：功能性需求、非功能性需求</li>
</ol>
<p>实现上：</p>
<ol>
<li>AspectJ。参见 <a target="_blank" rel="noopener" href="https://juejin.cn/post/7118644512351584287">关于AOP在Android中应用的一些思考</a>，很强大。</li>
<li>动态代理（<code>InvocationHandler</code> || CGLIB）</li>
<li>APT（Annotation Process Tool）</li>
</ol>
<h4 id="业务稳定性如何保障？如果发生了异常情况，怎么快速止损？（基建、流程方向）"><a href="#业务稳定性如何保障？如果发生了异常情况，怎么快速止损？（基建、流程方向）" class="headerlink" title="业务稳定性如何保障？如果发生了异常情况，怎么快速止损？（基建、流程方向）"></a>业务稳定性如何保障？如果发生了异常情况，怎么快速止损？（基建、流程方向）</h4>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>千越</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://qianyuebits.github.io/2024/01/18/Android-Interview/">https://qianyuebits.github.io/2024/01/18/Android-Interview/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/%E9%9D%A2%E8%AF%95/"># 面试</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2024/01/18/Android-Activity-Lifecycle/">Android Activity Lifecycle</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 千越 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>