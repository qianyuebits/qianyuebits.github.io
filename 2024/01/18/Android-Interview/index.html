<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
<meta name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="千越">





<title>Android 面试（持续 Update） | 千越</title>



    <link rel="icon" href="/image/icon.jpeg">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


<!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body>
    <script>
        // this function is used to check current theme before page loaded.
        (() => {
            const currentTheme = window.localStorage && window.localStorage.getItem('theme') || '';
            const isDark = currentTheme === 'dark';
            const pagebody = document.getElementsByTagName('body')[0]
            if (isDark) {
                pagebody.classList.add('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Dark"
            } else {
                pagebody.classList.remove('dark-theme');
                // mobile
                document.getElementById("mobile-toggle-theme").innerText = "· Light"
            }
        })();
    </script>

    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo"><a href="/">千越的博客</a></div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">千越的博客</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/archives">文章</a>
                
                    <a class="menu-item" href="/category">分类</a>
                
                    <a class="menu-item" href="/tag">标签</a>
                
                    <a class="menu-item" href="/about">关于我</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
            <div class="main">
                <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list">
    </div>
    <div class="tocbot-list-menu">
        <a class="tocbot-toc-expand" onclick="expand_toc()">Expand all</a>
        <a onclick="go_top()">Back to top</a>
        <a onclick="go_bottom()">Go to bottom</a>
    </div>
</div>

<script>
    var tocbot_timer;
    var DEPTH_MAX = 6; // 为 6 时展开所有
    var tocbot_default_config = {
        tocSelector: '.tocbot-list',
        contentSelector: '.post-content',
        headingSelector: 'h1, h2, h3, h4, h5',
        orderedList: false,
        scrollSmooth: true,
        onClick: extend_click,
    };

    function extend_click() {
        clearTimeout(tocbot_timer);
        tocbot_timer = setTimeout(function() {
            tocbot.refresh(obj_merge(tocbot_default_config, {
                hasInnerContainers: true
            }));
        }, 420); // 这个值是由 tocbot 源码里定义的 scrollSmoothDuration 得来的
    }

    document.ready(function() {
        tocbot.init(obj_merge(tocbot_default_config, {
            collapseDepth: 1
        }));
    });

    function expand_toc() {
        var b = document.querySelector('.tocbot-toc-expand');
        var expanded = b.getAttribute('data-expanded');
        expanded ? b.removeAttribute('data-expanded') : b.setAttribute('data-expanded', true);
        tocbot.refresh(obj_merge(tocbot_default_config, {
            collapseDepth: expanded ? 1 : DEPTH_MAX
        }));
        b.innerText = expanded ? 'Expand all' : 'Collapse all';
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

    function obj_merge(target, source) {
        for (var item in source) {
            if (source.hasOwnProperty(item)) {
                target[item] = source[item];
            }
        }
        return target;
    }
</script>
    

    
    <article class="post-wrap">
        <header class="post-header">
            <h1 class="post-title">Android 面试（持续 Update）</h1>
            
                <div class="post-meta">
                    
                        Author: <a itemprop="author" rel="author" href="/">千越</a>
                    

                    
                        <span class="post-time">
                        Date: <a href="#">2024-01-18&nbsp;&nbsp;22:43:03</a>
                        </span>
                    
                    
                </div>
            
        </header>

        <div class="post-content">
            <h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><h2 id="算法-amp-数据结构"><a href="#算法-amp-数据结构" class="headerlink" title="算法 &amp; 数据结构"></a>算法 &amp; 数据结构</h2><h4 id="⭐️-快速排序-amp-amp-冒泡排序"><a href="#⭐️-快速排序-amp-amp-冒泡排序" class="headerlink" title="⭐️ 快速排序 &amp;&amp; 冒泡排序"></a>⭐️ 快速排序 &amp;&amp; 冒泡排序</h4><p>参考：<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/ten-sorting-algorithm.html">十大经典排序算法</a><br>关键点：</p>
<ol>
<li>快速排序是不稳定的，平均复杂度 O(nlogn)，冒泡排序是稳定的，平均复杂度 O(n^2)；</li>
<li>快速排序又是一种分而治之思想在排序算法上的典型应用，使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）；</li>
<li>手写快排：<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/sort-an-array/description/">Leetcode</a>；</li>
</ol>
<blockquote>
<p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p>
</blockquote>
<h4 id="⭐️-链表？"><a href="#⭐️-链表？" class="headerlink" title="⭐️ 链表？"></a>⭐️ 链表？</h4><p>相关问题：在 Leetcode 上均可找到对应题目。</p>
<ol>
<li>环形链表判断；</li>
<li>链表相交判断；</li>
<li>反转单链表；</li>
<li>移除链单&#x2F;双表节点；</li>
<li>链表中间节点；</li>
</ol>
<p>注意活用双指针。</p>
<h4 id="⭐️-谈谈你对时间复杂度和空间复杂度的理解？"><a href="#⭐️-谈谈你对时间复杂度和空间复杂度的理解？" class="headerlink" title="⭐️ 谈谈你对时间复杂度和空间复杂度的理解？"></a>⭐️ 谈谈你对时间复杂度和空间复杂度的理解？</h4><p>针对同一问题，可以有很多种算法来解决，但不同的算法在效率和占用存储空间上的区别可能会很大。那么，通过什么指标来衡量算法的优劣呢？其中，上面提到的效率可以用算法的时间复杂度来描述，而所占用的存储空间可以用算法的空间复杂度来描述。</p>
<ul>
<li>时间复杂度：用于评估执行程序所消耗的时间，可以估算出程序对处理器的使用程度。</li>
<li>空间复杂度：用于评估执行程序所占用的内存空间，可以估算出程序对计算机内存的使用程度。</li>
</ul>
<h4 id="⭐️-什么是红黑树？为什么要用红黑树？"><a href="#⭐️-什么是红黑树？为什么要用红黑树？" class="headerlink" title="⭐️ 什么是红黑树？为什么要用红黑树？"></a>⭐️ 什么是红黑树？为什么要用红黑树？</h4><p><strong>一种自平衡二叉查找树</strong>。它的性质参见 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91">Wiki</a>：</p>
<ol>
<li>根是黑色</li>
<li>节点是红色或黑色</li>
<li>所有叶子都是黑色（叶子是NIL节点）</li>
<li>每个红色节点必须有两个黑色的子节点。（或者说从每个叶子到根的所有路径上不能有两个连续的红色节点。）（或者说不存在两个相邻的红色节点，相邻指两个节点是父子关系。）（或者说红色节点的父节点和子节点均是黑色的。）</li>
<li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点</li>
</ol>
<p>红黑树并不是一颗 AVL 平衡二叉搜索树：平衡二叉搜索树（英语：Balanced Binary Search Tree）是一种结构平衡的二叉搜索树，它是一种每个节点的左右两子树高度差都不超过 1 的二叉树。但是根据性质 5，它的黑色节点满足平衡，又被称为<strong>黑色完美平衡</strong>。</p>
<p><strong>红黑树相对于 AVL 树来说，牺牲了部分平衡性以换取插入和删除操作时少量的旋转操作，整体来说性能要优于AVL树。</strong></p>
<h4 id="⭐️-如何从一百万个数里面找到最小的一百个数，考虑算法的时间复杂度和空间复杂度"><a href="#⭐️-如何从一百万个数里面找到最小的一百个数，考虑算法的时间复杂度和空间复杂度" class="headerlink" title="⭐️ 如何从一百万个数里面找到最小的一百个数，考虑算法的时间复杂度和空间复杂度"></a>⭐️ 如何从一百万个数里面找到最小的一百个数，考虑算法的时间复杂度和空间复杂度</h4><p>TopK 问题，类似的有：</p>
<ol>
<li>最小的 k 个数；</li>
<li>数组中的第 K 个最大元素；</li>
</ol>
<p>常见解决方法：</p>
<ol>
<li>整体排序：O(nlogn)；</li>
<li>局部排序：只冒泡排序前 k 个最大值，O(n*k)；</li>
<li>利用堆：O(nlogk)</li>
<li>优化：快速选择（quickselect）算法</li>
<li>分治法</li>
</ol>
<h4 id="⭐️-二叉树前序-x2F-中序-x2F-后序-x2F-层次遍历"><a href="#⭐️-二叉树前序-x2F-中序-x2F-后序-x2F-层次遍历" class="headerlink" title="⭐️ 二叉树前序&#x2F;中序&#x2F;后序&#x2F;层次遍历"></a>⭐️ 二叉树前序&#x2F;中序&#x2F;后序&#x2F;层次遍历</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/binary-tree-inorder-traversal/description/">Leetcode</a></p>
<ol>
<li>前序&#x2F;中序&#x2F;后序 三者属于深度优先搜索，均可使用递归来实现；</li>
<li>层次遍历属于广度优先搜索（BFS）的方法，可用队列实现；</li>
</ol>
<h4 id="⭐️-判断平衡二叉树"><a href="#⭐️-判断平衡二叉树" class="headerlink" title="⭐️ 判断平衡二叉树"></a>⭐️ 判断平衡二叉树</h4><p><a target="_blank" rel="noopener" href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/description/">Leetcode</a><br>关键点：双层递归</p>
<ol>
<li>按照 AVL 的定义，递归判断树的每个节点是否符合要求；</li>
<li>在判断每个节点是否符合要求时，需要递归获取它左右节点的子树高度；</li>
</ol>
<h4 id="手写生产者-x2F-消费者模式（并发同步问题）"><a href="#手写生产者-x2F-消费者模式（并发同步问题）" class="headerlink" title="手写生产者&#x2F;消费者模式（并发同步问题）"></a>手写生产者&#x2F;消费者模式（并发同步问题）</h4><ol>
<li>关键：两把锁，一把用于表示队列是否满，一把用于表示队列是否空；</li>
<li>手撸代码，变种在于使用不同的加锁方式，比如 <code>BlockingQueue</code>，信号量；</li>
</ol>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h4 id="TCP-三次握手、四次挥手（为什么是三次握手不是两次握手？）"><a href="#TCP-三次握手、四次挥手（为什么是三次握手不是两次握手？）" class="headerlink" title="TCP 三次握手、四次挥手（为什么是三次握手不是两次握手？）"></a>TCP 三次握手、四次挥手（为什么是三次握手不是两次握手？）</h4><h4 id="介绍一下-http-协议"><a href="#介绍一下-http-协议" class="headerlink" title="介绍一下 http 协议"></a>介绍一下 http 协议</h4><h4 id="请简述-Http-与-Https-的区别？"><a href="#请简述-Http-与-Https-的区别？" class="headerlink" title="请简述 Http 与 Https 的区别？"></a>请简述 Http 与 Https 的区别？</h4><h4 id="请简述一次-Http-网络请求的过程？"><a href="#请简述一次-Http-网络请求的过程？" class="headerlink" title="请简述一次 Http 网络请求的过程？"></a>请简述一次 Http 网络请求的过程？</h4><h4 id="计算机网络中的重定向是什么"><a href="#计算机网络中的重定向是什么" class="headerlink" title="计算机网络中的重定向是什么"></a>计算机网络中的重定向是什么</h4><h4 id="断点续传和断点下载"><a href="#断点续传和断点下载" class="headerlink" title="断点续传和断点下载"></a>断点续传和断点下载</h4><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h4 id="⭐️-数据库索引、事务的概念"><a href="#⭐️-数据库索引、事务的概念" class="headerlink" title="⭐️ 数据库索引、事务的概念"></a>⭐️ 数据库索引、事务的概念</h4><p>索引是一种特殊的文件，包含着对数据表里所有记录的引用指针，可以对表中的一列或者多列创建索引，并指定索引的类型，各类索引有各自的数据结构实现，比如 B+ 树。使用索引后可以不用扫描全表来定位某行的数据，而是先通过索引表找到该行数据对应的物理地址然后访问相应的数据，因此能加快数据库的查询速度。</p>
<p>数据库事务通常包含了一个序列的对数据库的读&#x2F;写操作，这些操作要么一起成功，要么一起失败（中间异常会回滚）。数据库事务拥有以下四个特性，习惯上被称之为 ACID 特性：</p>
<ol>
<li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行；</li>
<li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束；</li>
<li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行；</li>
<li>持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中；</li>
</ol>
<h4 id="⭐️-关系型数据库中的主键是什么"><a href="#⭐️-关系型数据库中的主键是什么" class="headerlink" title="⭐️ 关系型数据库中的主键是什么"></a>⭐️ 关系型数据库中的主键是什么</h4><p>在关系型数据库中，主键（Primary Key）能够少数标识数据表中的一行记录。主键可以包含数据表中的一列或者多列，主键不能为空。同时，在同一个数据表中，主键列上不能有两行甚至多行相同的值，也就是说，在同一个数据表中，每行数据对应的主键列的值必须少数。</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h4 id="⭐️-分别讲讲-final，static，synchronized，Java-静态方法是否可以被重写"><a href="#⭐️-分别讲讲-final，static，synchronized，Java-静态方法是否可以被重写" class="headerlink" title="⭐️ 分别讲讲 final，static，synchronized，Java 静态方法是否可以被重写"></a>⭐️ 分别讲讲 <code>final</code>，<code>static</code>，<code>synchronized</code>，Java 静态方法是否可以被重写</h4><p>静态方法不可以被重写</p>
<h4 id="⭐️-Java-中有哪几种变量修饰符，有什么区别，protected-是否是包级可见的"><a href="#⭐️-Java-中有哪几种变量修饰符，有什么区别，protected-是否是包级可见的" class="headerlink" title="⭐️ Java 中有哪几种变量修饰符，有什么区别，protected 是否是包级可见的"></a>⭐️ Java 中有哪几种变量修饰符，有什么区别，<code>protected</code> 是否是包级可见的</h4><p><code>package</code> 才是。</p>
<h4 id="⭐️-synchronized-对普通方法、静态方法加锁有什么区别"><a href="#⭐️-synchronized-对普通方法、静态方法加锁有什么区别" class="headerlink" title="⭐️ synchronized 对普通方法、静态方法加锁有什么区别"></a>⭐️ <code>synchronized</code> 对普通方法、静态方法加锁有什么区别</h4><p>对象锁 VS 类锁</p>
<h4 id="⭐️-抽象类与接口的区别？"><a href="#⭐️-抽象类与接口的区别？" class="headerlink" title="⭐️ 抽象类与接口的区别？"></a>⭐️ 抽象类与接口的区别？</h4><ol>
<li>接口只有定义，不能有方法的实现，java 1.8 中可以定义 <code>default</code> 方法体，而抽象类可以有定义与实现，方法可在抽象类中实现；</li>
<li>实现接口的关键字为 <code>implements</code>，继承抽象类的关键字为 <code>extends</code>。一个类可以实现多个接口，但一个类只能继承一个抽象类；</li>
<li>接口强调特定功能的实现，而抽象类强调所属关系；</li>
<li>接口成员变量默认为 <code>public static final</code>，必须赋初值，不能被修改；其所有的成员方法都是 <code>public</code>、<code>abstract</code> 的。抽象类中除了抽象方法，其余与普通方法无异，而抽象方法被 <code>abstract</code> 修饰，不能被 <code>private</code>、<code>static</code>、<code>synchronized</code> 和 <code>native</code> 等修饰，必须以分号结尾，不带花括号；</li>
</ol>
<p>关于第三点举个例子：比如我们用一个模型来描述雇员，对于公司的雇员来说，他有很多的基本属性和方法，比如走路、讲话、会隶属于某个部门、会有具体的 Base，这些我们可以使用抽象类来描述，强调这个类用来描述雇员。但同时，每个雇员又有不同的职责，比如 Android 开发要求会写 UI，懂 Java 和算法，会读写英语，那这些作为附加能力，可以抽象为接口。</p>
<h4 id="谈谈-Error-和-Exception-的区别？"><a href="#谈谈-Error-和-Exception-的区别？" class="headerlink" title="谈谈 Error 和 Exception 的区别？"></a>谈谈 <code>Error</code> 和 <code>Exception</code> 的区别？</h4><h4 id="什么是反射机制？反射机制的应用场景有哪些？"><a href="#什么是反射机制？反射机制的应用场景有哪些？" class="headerlink" title="什么是反射机制？反射机制的应用场景有哪些？"></a>什么是反射机制？反射机制的应用场景有哪些？</h4><h4 id="谈谈如何重写-equals-方法？为什么还要重写-hashCode-？"><a href="#谈谈如何重写-equals-方法？为什么还要重写-hashCode-？" class="headerlink" title="谈谈如何重写 equals() 方法？为什么还要重写 hashCode()？"></a>谈谈如何重写 <code>equals()</code> 方法？为什么还要重写 <code>hashCode()</code>？</h4><p>重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法是为了正确地实现对象的相等性比较和在散列容器（如哈希表）中正确地存储对象。下面是关于如何重写这两个方法的一些指导和原因：</p>
<p>重写 <code>equals()</code> 方法：</p>
<ul>
<li><code>equals()</code> 方法用于比较两个对象是否相等。默认情况下，<code>equals()</code> 方法在比较对象时使用的是引用相等性（即比较对象的内存地址），但在许多情况下，我们希望比较对象的内容是否相等。重写 <code>equals()</code> 方法时应遵循以下原则：<ul>
<li>自反性：<code>x.equals(x)</code> 应始终返回 true。</li>
<li>对称性：如果 <code>x.equals(y)</code> 返回 true，那么 <code>y.equals(x)</code> 也应返回 true。</li>
<li>传递性：如果 <code>x.equals(y)</code> 和 <code>y.equals(z)</code> 都返回 true，那么 <code>x.equals(z)</code> 也应返回 true。</li>
<li>一致性：在对象未修改的情况下，多次调用 <code>x.equals(y)</code> 应始终返回相同的结果。</li>
<li>非空性：<code>x.equals(null)</code> 应返回 false。</li>
</ul>
</li>
<li>重写 <code>equals()</code> 方法通常需要比较对象的字段值。可以使用 <code>instanceof</code> 运算符检查类型，然后比较字段值是否相等。</li>
</ul>
<p>重写 <code>hashCode()</code> 方法：</p>
<ul>
<li><code>hashCode()</code> 方法返回对象的散列码，用于在散列容器（如哈希表）中定位对象的存储位置。</li>
<li>当重写 <code>equals()</code> 方法时，也应该相应地重写 <code>hashCode()</code> 方法，以保证对象相等的实例具有相等的散列码。<br><code>hashCode()</code> 方法的重写应满足以下原则（JavaDoc）：<ul>
<li>如果两个对象通过 <code>equals()</code> 方法比较是相等的，那么它们的 <code>hashCode()</code> 必须一致；</li>
<li>如果两个对象通过 <code>equals()</code> 方法比较是不相等的，那么它们的 <code>hashCode()</code> 最好不一致（不强求），这样可以提高性能，比如在 Hash 时不会集中到个别桶中；</li>
</ul>
</li>
<li>通常，可以使用对象的字段值来计算散列码。可以选择使用某些字段的散列码进行异或操作，以生成最终的散列码。</li>
</ul>
<p>为什么还要重写 <code>hashCode()</code> 方法？</p>
<ul>
<li>在散列容器中存储对象时，为了能够正确地定位和访问对象，需要使用散列码。如果不重写 <code>hashCode()</code> 方法，那么每次调用默认的 <code>hashCode()</code> 方法时，都会返回不同的散列码，导致对象无法正确地存储和检索；</li>
<li>重写 <code>hashCode()</code> 方法保证了对象相等的实例具有相等的散列码，这在散列容器中尤为重要。如果两个对象通过 equals() 方法比较是相等的，但它们具有不同的散列码，那么在散列容器中它们被视为不同的对象，可能会导致数据结构的不一致和错误的结果（相等却找不到）；</li>
</ul>
<p>综上所述，重写 <code>equals()</code> 方法和 <code>hashCode()</code> 方法是为了确保对象的相等性比较和散列码计算的一致性和正确性，从而保证对象在比较和存储时的预期行为。</p>
<h4 id="⭐️-谈谈你对-Java-泛型中类型擦除的理解，并说说其局限性？"><a href="#⭐️-谈谈你对-Java-泛型中类型擦除的理解，并说说其局限性？" class="headerlink" title="⭐️ 谈谈你对 Java 泛型中类型擦除的理解，并说说其局限性？"></a>⭐️ 谈谈你对 Java 泛型中类型擦除的理解，并说说其局限性？</h4><p>参考：<a href="https://qianyuebits.github.io/2024/01/18/Java-Generics/">Java 泛型</a></p>
<h4 id="⭐️-String-为什么要设计成不可变的？其如何实现不可变性的？"><a href="#⭐️-String-为什么要设计成不可变的？其如何实现不可变性的？" class="headerlink" title="⭐️ String 为什么要设计成不可变的？其如何实现不可变性的？"></a>⭐️ String 为什么要设计成不可变的？其如何实现不可变性的？</h4><p>从技术层面：</p>
<ol>
<li>保存字符串的数组 value 被 <code>private</code> 和 <code>final</code> 修饰，并且 <code>String</code> 类没有提供修改 value 的方法；</li>
<li>String 类被 final 修饰，不能被继承修改；</li>
</ol>
<p>Java 的字符串被设计为不可变的（Immutable）有以下几个原因：</p>
<ul>
<li>性能优化：字符串常常被用作散列键（如在哈希表中使用），因此如果字符串是可变的，那么当字符串的值发生变化时，需要重新计算哈希值。而不可变字符串可以缓存其哈希值，提高散列性能；</li>
<li>线程安全：不可变字符串是线程安全的，因为多个线程可以共享相同的字符串实例而无需担心数据竞争或并发修改问题。这简化了多线程环境下的编程和调试；</li>
<li>安全性：字符串常常被用于表示敏感信息（如密码），如果字符串是可变的，那么它的值可以在不知情的情况下被修改。通过设计字符串为不可变，可以提高安全性，防止数据被意外修改；</li>
<li>缓存和重用：由于字符串是不可变的，可以被安全地作为缓存键或常量池中的键使用。这样可以提高性能，避免创建重复的字符串对象，节省内存开销；</li>
<li>API 设计和可预测性：字符串不可变性使得字符串操作的 API 更加简单和可靠。不可变性确保了字符串的值不会在操作期间发生变化，使得代码更易于理解、调试和维护；</li>
</ul>
<p>尽管字符串是不可变的，但是 Java 提供了一些字符串操作的方法，如拼接、替换、截取等，这些操作并不直接修改原始字符串，而是返回一个新的字符串对象。这样既保持了字符串的不可变性，又提供了方便的操作接口。</p>
<h4 id="说说你对-Java-注解的理解？编译期注解-VS-运行时注解？"><a href="#说说你对-Java-注解的理解？编译期注解-VS-运行时注解？" class="headerlink" title="说说你对 Java 注解的理解？编译期注解 VS 运行时注解？"></a>说说你对 Java 注解的理解？编译期注解 VS 运行时注解？</h4><h4 id="⭐️-HashMap-的实现原理？"><a href="#⭐️-HashMap-的实现原理？" class="headerlink" title="⭐️ HashMap 的实现原理？"></a>⭐️ <code>HashMap</code> 的实现原理？</h4><p>数组 + 链表&#x2F;红黑树</p>
<h4 id="谈谈对于-ConcurrentHashMap-的理解"><a href="#谈谈对于-ConcurrentHashMap-的理解" class="headerlink" title="谈谈对于 ConcurrentHashMap 的理解?"></a>谈谈对于 <code>ConcurrentHashMap</code> 的理解?</h4><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h4 id="⭐️-Java-中使用多线程的方式有哪些？"><a href="#⭐️-Java-中使用多线程的方式有哪些？" class="headerlink" title="⭐️ Java 中使用多线程的方式有哪些？"></a>⭐️ Java 中使用多线程的方式有哪些？</h4><ol>
<li>线程创建方面，可以自己创建 Thread 或者使用线程池；</li>
<li>任务创建方面，可以继承 <code>Runnable</code> 或者 <code>Callable</code> 或者 <code>FutureTask</code> 来创建；</li>
</ol>
<h4 id="⭐️-说一下线程的几种状态？"><a href="#⭐️-说一下线程的几种状态？" class="headerlink" title="⭐️ 说一下线程的几种状态？"></a>⭐️ 说一下线程的几种状态？</h4><p>参见：<a href="https://qianyuebits.github.io/2024/01/17/Java-Thread-State/">Java Thread 状态</a></p>
<p>总结下：</p>
<ol>
<li>初始化</li>
<li>可运行&#x2F;就绪状态</li>
<li>等待（Waiting）</li>
<li>阻塞（Blocked）</li>
<li>终止状态</li>
</ol>
<h4 id="⭐️-谈谈线程阻塞的原因？"><a href="#⭐️-谈谈线程阻塞的原因？" class="headerlink" title="⭐️ 谈谈线程阻塞的原因？"></a>⭐️ 谈谈线程阻塞的原因？</h4><ol>
<li>等待外部资源：线程可能因为等待外部资源的可用性而被阻塞。这包括等待用户输入、等待磁盘I&#x2F;O、等待网络数据等。当线程需要依赖外部资源的时候，如果资源不可用，线程将被阻塞，直到资源准备就绪；</li>
<li>线程同步：在多线程编程中，线程之间可能需要协调和同步执行。当线程需要访问某个共享资源时，可能需要获取锁或等待其他线程释放锁才能继续执行。当线程无法获取到所需的锁时，它将被阻塞，直到锁可用；</li>
<li>等待条件满足：线程可能因为等待某个条件满足而被阻塞。这通常通过调用对象的等待方法（如 wait()）来实现。线程在等待条件满足之前会被阻塞，并释放对象的锁，允许其他线程访问该对象。当条件满足时，线程会被唤醒并重新竞争获取锁；</li>
</ol>
<h4 id="⭐️-如何实现多线程中的同步？谈一谈-Java-线程常见的几种锁？"><a href="#⭐️-如何实现多线程中的同步？谈一谈-Java-线程常见的几种锁？" class="headerlink" title="⭐️ 如何实现多线程中的同步？谈一谈 Java 线程常见的几种锁？"></a>⭐️ 如何实现多线程中的同步？谈一谈 Java 线程常见的几种锁？</h4><p>参见：<a href="https://qianyuebits.github.io/2024/01/17/Java-Thread-Programming/">Java 并发编程</a></p>
<ol>
<li><code>synchronized</code></li>
<li><code>ReentrantLock</code>（建议研究下这个类）</li>
<li>Java 提供了一些并发工具类，如 <code>CountDownLatch</code>、<code>Semaphore</code>、<code>CyclicBarrier</code>、<code>Lock</code> 等</li>
</ol>
<h4 id="⭐️-谈谈线程死锁，如何有效的避免线程死锁？"><a href="#⭐️-谈谈线程死锁，如何有效的避免线程死锁？" class="headerlink" title="⭐️ 谈谈线程死锁，如何有效的避免线程死锁？"></a>⭐️ 谈谈线程死锁，如何有效的避免线程死锁？</h4><p>死锁的概念：在两个或多个并发进程中，如果每个进程持有某种资源而又都等待别的进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗地讲，就是两个或多个进程被无限期地阻塞、相互等待的一种状态。产生死锁的必要条件：</p>
<ol>
<li>互斥（mutual exclusion），一个资源每次只能被一个进程使用；</li>
<li>不可抢占（no preemption），进程已获得的资源，在未使用完之前，不能强行剥夺；</li>
<li>占有并等待（hold andwait），一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li>
<li>环形等待（circular wait），若干进程之间形成一种首尾相接的循环等待资源关系；</li>
</ol>
<p>死锁的解除与预防：理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源。因此，对资源的分配要给予合理的规划。</p>
<p>比如哲学家问题，可以让其中一个哲学家先拿左边的筷子，后拿右边的，而其余的哲学家则相反，这样就破坏了最后一个条件，也就不会造成死锁。</p>
<h4 id="⭐️-synchronized-和-ReentrantLock-有什么区别"><a href="#⭐️-synchronized-和-ReentrantLock-有什么区别" class="headerlink" title="⭐️ synchronized 和 ReentrantLock 有什么区别"></a>⭐️ <code>synchronized</code> 和 <code>ReentrantLock</code> 有什么区别</h4><ul>
<li><code>synchronized</code> 是 Java 语言内置的关键字，通过隐式地获取和释放锁来实现同步，功能相对简单，适用于大多数的线程同步需求；</li>
<li><code>ReentrantLock</code> 是一个显示锁，需要显式地调用 <code>lock()</code> 方法来获取锁，并提供了更多高级的特性，如可重入性、公平性、条件变量等，适用于更复杂的线程同步需求。但使用时需要注意避免死锁和正确释放锁的问题；</li>
</ul>
<h4 id="⭐️-synchronized-和-volatile-关键字的区别？"><a href="#⭐️-synchronized-和-volatile-关键字的区别？" class="headerlink" title="⭐️ synchronized 和 volatile 关键字的区别？"></a>⭐️ <code>synchronized</code> 和 <code>volatile</code> 关键字的区别？</h4><ul>
<li><code>synchronized</code> 关键字用于实现互斥访问共享资源，保证同一时刻只有一个线程能够执行被修饰的代码块或方法，并提供了可见性和有序性的特性；</li>
<li><code>volatile</code> 关键字用于实现变量的可见性，保证对 <code>volatile</code> 变量的修改对其他线程立即可见，但不提供互斥访问的功能；</li>
</ul>
<h4 id="⭐️-谈谈-ThreadLocal-用法和原理？"><a href="#⭐️-谈谈-ThreadLocal-用法和原理？" class="headerlink" title="⭐️ 谈谈 ThreadLocal 用法和原理？"></a>⭐️ 谈谈 <code>ThreadLocal</code> 用法和原理？</h4><p>参考：<a href="https://qianyuebits.github.io/2014/05/25/Java-ThreadLocal/">Java ThreadLocal</a></p>
<h4 id="⭐️-谈一谈线程-sleep-和-wait-的区别？"><a href="#⭐️-谈一谈线程-sleep-和-wait-的区别？" class="headerlink" title="⭐️ 谈一谈线程 sleep() 和 wait() 的区别？"></a>⭐️ 谈一谈线程 <code>sleep()</code> 和 <code>wait()</code> 的区别？</h4><ul>
<li><code>sleep()</code> 方法是线程类的静态方法，用于暂停当前线程的执行一段时间；</li>
<li><code>wait()</code> 方法是对象实例方法，用于将当前线程置于等待状态，直到其他线程唤醒；</li>
<li><code>sleep()</code> 方法在暂停期间不会释放锁，<code>wait()</code> 方法会释放锁（只能在同步代码块或同步方法中调用，否则会抛出 <code>IllegalMonitorStateException</code> 异常）；</li>
<li><code>sleep()</code> 方法的唤醒只能等待指定时间过去后自动唤醒，而 <code>wait()</code> 方法的唤醒需要其他线程显式调用 <code>notify()</code> 或 <code>notifyAll()</code> 方法；</li>
</ul>
<h4 id="⭐️-Java-线程中-notify-和-notifyAll-有什么区别？"><a href="#⭐️-Java-线程中-notify-和-notifyAll-有什么区别？" class="headerlink" title="⭐️ Java 线程中 notify 和 notifyAll 有什么区别？"></a>⭐️ Java 线程中 <code>notify</code> 和 <code>notifyAll</code> 有什么区别？</h4><p>都会导致某个对象锁上的等待线程进入可运行状态，前者随机唤醒一个，后者唤醒全部。</p>
<h4 id="⭐️-什么是线程池？如何创建一个线程池？"><a href="#⭐️-什么是线程池？如何创建一个线程池？" class="headerlink" title="⭐️ 什么是线程池？如何创建一个线程池？"></a>⭐️ 什么是线程池？如何创建一个线程池？</h4><p>线程组件，负责线程的创建、销毁和任务的调度。可见<a href="https://qianyuebits.github.io/2024/01/17/Java-ThreadPool/">Java ThreadPool</a>。</p>
<h2 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h2><h4 id="⭐️-谈一谈-JAVA-垃圾回收机制？"><a href="#⭐️-谈一谈-JAVA-垃圾回收机制？" class="headerlink" title="⭐️ 谈一谈 JAVA 垃圾回收机制？"></a>⭐️ 谈一谈 JAVA 垃圾回收机制？</h4><p>关键：</p>
<ol>
<li>内存分区；</li>
<li>垃圾回收算法；</li>
<li>垃圾回收器；</li>
</ol>
<p>参考：<a href="https://qianyuebits.github.io/2024/01/17/Java-Memory-Management/">Java 内存管理</a></p>
<h4 id="⭐️-回答一下什么是强、软、弱、虚引用以及它们之间的区别？"><a href="#⭐️-回答一下什么是强、软、弱、虚引用以及它们之间的区别？" class="headerlink" title="⭐️ 回答一下什么是强、软、弱、虚引用以及它们之间的区别？"></a>⭐️ 回答一下什么是强、软、弱、虚引用以及它们之间的区别？</h4><p>强弱软虚</p>
<h4 id="⭐️-JMM-是什么？它存在哪些问题？该如何解决？"><a href="#⭐️-JMM-是什么？它存在哪些问题？该如何解决？" class="headerlink" title="⭐️ JMM 是什么？它存在哪些问题？该如何解决？"></a>⭐️ JMM 是什么？它存在哪些问题？该如何解决？</h4><p>参考：<a href="https://qianyuebits.github.io/2024/01/17/JMM/">JMM（Java 内存模型）</a></p>
<p><strong>JMM（Java内存模型）是 Java 编程语言中定义了多线程并发访问内存的规范。它定义了线程如何与主内存和各自的工作内存进行交互，以及如何保证多线程之间的数据可见性、有序性和原子性。</strong></p>
<p>JMM 存在以下几个问题：</p>
<ul>
<li><strong>可见性问题</strong> 可见性问题指的是当一个线程修改了共享变量的值后，其他线程可能无法立即看到最新的值。这是因为线程在工作内存中进行操作，对主内存的修改可能不会立即同步到其他线程的工作内存中，从而导致数据不一致。</li>
<li><strong>有序性问题</strong> 有序性问题指的是程序的执行顺序可能与我们期望的不一致。由于编译器和处理器的优化，指令可能会被重排序，这可能导致某些操作的执行顺序与程序代码的顺序不一致。</li>
<li><strong>原子性问题</strong> 原子性问题指的是一个操作的执行过程中可能被其他线程的操作所中断，从而导致操作没有完全执行或者执行部分结果，违背了原子性的要求。</li>
</ul>
<p>为了解决 JMM 存在的问题，可以采取以下方法：</p>
<ol>
<li>使用 <code>volatile</code> 关键字：<code>volatile</code> 关键字可以确保被修饰的变量对所有线程可见，并且禁止了对该变量的重排序；</li>
<li>使用 <code>synchronized</code> 关键字或者 Lock 等其他同步方法：<code>synchronized</code> 关键字可以保证线程对同步块或方法的访问是互斥的，即同一时刻只有一个线程可以执行同步代码块，从而解决可见性、有序性和原子性问题；</li>
<li>使用原子类：Java 提供了一系列的原子类，如 <code>AtomicInteger</code>、<code>AtomicLong</code> 等，它们提供了原子性的操作，可以解决原子性问题；</li>
</ol>
<p>通过合理地使用上述方法，可以解决 JMM 存在的可见性、有序性和原子性问题，从而保证多线程程序的正确性和可靠性。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="⭐️-简述-JVM-中类的加载机制与加载过程？（Classloader-工作原理）"><a href="#⭐️-简述-JVM-中类的加载机制与加载过程？（Classloader-工作原理）" class="headerlink" title="⭐️ 简述 JVM 中类的加载机制与加载过程？（Classloader 工作原理）"></a>⭐️ 简述 JVM 中类的加载机制与加载过程？（<code>Classloader</code> 工作原理）</h4><p>JVM（Java 虚拟机）在运行 Java 程序时，采用了类的动态加载机制。类的加载过程包括加载、验证、准备、解析和初始化等阶段。以下是对这些阶段的简要描述：</p>
<ol>
<li><strong>加载（Loading）</strong>：</li>
</ol>
<ul>
<li>类加载是将类的二进制数据从磁盘或网络加载到内存中的过程。</li>
<li>类加载器负责加载类，并生成对应的 Class 对象。</li>
<li>加载阶段包括三个步骤：通过类的全限定名获取类的字节码数据，创建一个对应的 Class 对象，并将 Class 对象放入方法区的运行时常量池中。</li>
</ul>
<ol start="2">
<li><strong>验证（Verification）</strong>：</li>
</ol>
<ul>
<li>验证阶段用于确保类的字节码符合 JVM 规范，并且不会危害 JVM 本身的安全。</li>
<li>验证过程包括文件格式验证、元数据验证、字节码验证和符号引用验证等。</li>
</ul>
<ol start="3">
<li><strong>准备（Preparation）</strong>：</li>
</ol>
<ul>
<li>在准备阶段，JVM 为类的静态变量分配内存，并设置默认初始值。</li>
<li>静态变量会被分配在方法区中的静态变量区域。</li>
</ul>
<ol start="4">
<li><strong>解析（Resolution</strong>）：</li>
</ol>
<ul>
<li>解析阶段将常量池中的符号引用替换为直接引用，即将类、方法、字段等符号引用解析为具体的内存地址。</li>
<li>解析可以在加载阶段后进行，也可以在初始化阶段之前进行。</li>
</ul>
<ol start="5">
<li><strong>初始化（Initialization）</strong>：</li>
</ol>
<ul>
<li>初始化阶段是类加载的最后一步，是类中静态变量赋予正确初始值的过程。</li>
<li>在初始化阶段，会执行类的静态初始化器（<code>&lt;clinit&gt;</code>方法）的代码，静态变量会被赋予程序中指定的值。<br>需要注意的是，类的加载过程是按需进行的，即在首次使用类时才会进行加载。同时，JVM 还提供了类的卸载机制，当类不再被使用时，会被卸载并释放内存。<br>类的加载机制和加载过程是 JVM 实现 Java 语言跨平台特性的重要组成部分，它们确保了类的正确加载和初始化，使得 Java 程序能够在不同的平台上运行。</li>
</ul>
<h4 id="JVM、Dalvik、ART-三者的原理和区别？"><a href="#JVM、Dalvik、ART-三者的原理和区别？" class="headerlink" title="JVM、Dalvik、ART 三者的原理和区别？"></a>JVM、Dalvik、ART 三者的原理和区别？</h4><h4 id="饿汉单例为什么是线程安全的？（kotlin-怎么写单例？）静态内部类单例？"><a href="#饿汉单例为什么是线程安全的？（kotlin-怎么写单例？）静态内部类单例？" class="headerlink" title="饿汉单例为什么是线程安全的？（kotlin 怎么写单例？）静态内部类单例？"></a>饿汉单例为什么是线程安全的？（kotlin 怎么写单例？）静态内部类单例？</h4><h1 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h1><h4 id="请简述一下什么是-Kotlin？它有哪些特性？"><a href="#请简述一下什么是-Kotlin？它有哪些特性？" class="headerlink" title="请简述一下什么是 Kotlin？它有哪些特性？"></a>请简述一下什么是 Kotlin？它有哪些特性？</h4><h4 id="Kotlin-中注解-JvmOverloads-的作用？"><a href="#Kotlin-中注解-JvmOverloads-的作用？" class="headerlink" title="Kotlin 中注解 @JvmOverloads 的作用？"></a>Kotlin 中注解 <code>@JvmOverloads</code> 的作用？</h4><h4 id="Kotlin中-List-与-MutableList-的区别？"><a href="#Kotlin中-List-与-MutableList-的区别？" class="headerlink" title="Kotlin中 List 与 MutableList 的区别？"></a>Kotlin中 <code>List</code> 与 <code>MutableList</code> 的区别？</h4><h4 id="谈谈你对-Kotlin-中的-data-关键字的理解？相比于普通类有哪些特点？"><a href="#谈谈你对-Kotlin-中的-data-关键字的理解？相比于普通类有哪些特点？" class="headerlink" title="谈谈你对 Kotlin 中的 data 关键字的理解？相比于普通类有哪些特点？"></a>谈谈你对 Kotlin 中的 data 关键字的理解？相比于普通类有哪些特点？</h4><h4 id="什么是委托属性？请简要说说其使用场景和原理？"><a href="#什么是委托属性？请简要说说其使用场景和原理？" class="headerlink" title="什么是委托属性？请简要说说其使用场景和原理？"></a>什么是委托属性？请简要说说其使用场景和原理？</h4><h4 id="请举例说明-Kotlin-中-with-与-apply-函数的应用场景和区别？"><a href="#请举例说明-Kotlin-中-with-与-apply-函数的应用场景和区别？" class="headerlink" title="请举例说明 Kotlin 中 with 与 apply 函数的应用场景和区别？"></a>请举例说明 Kotlin 中 with 与 apply 函数的应用场景和区别？</h4><h4 id="Kotlin-中-Unit-类型的作用以及与-Java-中-Void-的区别？"><a href="#Kotlin-中-Unit-类型的作用以及与-Java-中-Void-的区别？" class="headerlink" title="Kotlin 中 Unit 类型的作用以及与 Java 中 Void 的区别？"></a>Kotlin 中 <code>Unit</code> 类型的作用以及与 Java 中 Void 的区别？</h4><h4 id="Kotlin-中-infix-关键字的原理和使用场景？"><a href="#Kotlin-中-infix-关键字的原理和使用场景？" class="headerlink" title="Kotlin 中 infix 关键字的原理和使用场景？"></a>Kotlin 中 infix 关键字的原理和使用场景？</h4><h4 id="Kotlin-中的可见性修饰符有哪些？相比于-Java-有什么区别？"><a href="#Kotlin-中的可见性修饰符有哪些？相比于-Java-有什么区别？" class="headerlink" title="Kotlin 中的可见性修饰符有哪些？相比于 Java 有什么区别？"></a>Kotlin 中的可见性修饰符有哪些？相比于 Java 有什么区别？</h4><h4 id="你觉得-Kotlin-与-Java-混合开发时需要注意哪些问题？"><a href="#你觉得-Kotlin-与-Java-混合开发时需要注意哪些问题？" class="headerlink" title="你觉得 Kotlin 与 Java 混合开发时需要注意哪些问题？"></a>你觉得 Kotlin 与 Java 混合开发时需要注意哪些问题？</h4><h4 id="在-Kotlin-中，何为解构？该如何使用？"><a href="#在-Kotlin-中，何为解构？该如何使用？" class="headerlink" title="在 Kotlin 中，何为解构？该如何使用？"></a>在 Kotlin 中，何为解构？该如何使用？</h4><h4 id="谈谈-Kotlin-中的构造方法？有哪些注意事项？"><a href="#谈谈-Kotlin-中的构造方法？有哪些注意事项？" class="headerlink" title="谈谈 Kotlin 中的构造方法？有哪些注意事项？"></a>谈谈 Kotlin 中的构造方法？有哪些注意事项？</h4><h4 id="谈谈-Kotlin-中的-Sequence，为什么它处理集合操作更加高效？"><a href="#谈谈-Kotlin-中的-Sequence，为什么它处理集合操作更加高效？" class="headerlink" title="谈谈 Kotlin 中的 Sequence，为什么它处理集合操作更加高效？"></a>谈谈 Kotlin 中的 <code>Sequence</code>，为什么它处理集合操作更加高效？</h4><h4 id="Kotlin-中该如何安全地处理可空类型？"><a href="#Kotlin-中该如何安全地处理可空类型？" class="headerlink" title="Kotlin 中该如何安全地处理可空类型？"></a>Kotlin 中该如何安全地处理可空类型？</h4><h4 id="Kotlin中的数据类型有隐式转换吗？为什么？"><a href="#Kotlin中的数据类型有隐式转换吗？为什么？" class="headerlink" title="Kotlin中的数据类型有隐式转换吗？为什么？"></a>Kotlin中的数据类型有隐式转换吗？为什么？</h4><h4 id="Kotlin-中集合遍历有哪几种方式？"><a href="#Kotlin-中集合遍历有哪几种方式？" class="headerlink" title="Kotlin 中集合遍历有哪几种方式？"></a>Kotlin 中集合遍历有哪几种方式？</h4><h4 id="请简述一下什么是-Kotlin？它有哪些特性？-1"><a href="#请简述一下什么是-Kotlin？它有哪些特性？-1" class="headerlink" title="请简述一下什么是 Kotlin？它有哪些特性？"></a>请简述一下什么是 Kotlin？它有哪些特性？</h4><h4 id="Kotlin-中实现单例的几种常见方式？"><a href="#Kotlin-中实现单例的几种常见方式？" class="headerlink" title="Kotlin 中实现单例的几种常见方式？"></a>Kotlin 中实现单例的几种常见方式？</h4><h4 id="在-Kotlin-中，什么是内联函数？有什么作用？"><a href="#在-Kotlin-中，什么是内联函数？有什么作用？" class="headerlink" title="在 Kotlin 中，什么是内联函数？有什么作用？"></a>在 Kotlin 中，什么是内联函数？有什么作用？</h4><h4 id="请谈谈-Kotlin-中的-Coroutines，它与线程有什么区别？有哪些优点？"><a href="#请谈谈-Kotlin-中的-Coroutines，它与线程有什么区别？有哪些优点？" class="headerlink" title="请谈谈 Kotlin 中的 Coroutines，它与线程有什么区别？有哪些优点？"></a>请谈谈 Kotlin 中的 <code>Coroutines</code>，它与线程有什么区别？有哪些优点？</h4><h4 id="说说-Kotlin-中的-Any-与-Java-中的-Object-有何异同？"><a href="#说说-Kotlin-中的-Any-与-Java-中的-Object-有何异同？" class="headerlink" title="说说 Kotlin 中的 Any 与 Java 中的 Object 有何异同？"></a>说说 Kotlin 中的 Any 与 Java 中的 Object 有何异同？</h4><h4 id="Kotlin-中的数据类型有隐式转换吗？为什么？"><a href="#Kotlin-中的数据类型有隐式转换吗？为什么？" class="headerlink" title="Kotlin 中的数据类型有隐式转换吗？为什么？"></a>Kotlin 中的数据类型有隐式转换吗？为什么？</h4><h4 id="Kotlin-中集合遍历有哪几种方式"><a href="#Kotlin-中集合遍历有哪几种方式" class="headerlink" title="Kotlin 中集合遍历有哪几种方式"></a>Kotlin 中集合遍历有哪几种方式</h4><h4 id="Kotlin-内置标准函数-let-的原理是什么？"><a href="#Kotlin-内置标准函数-let-的原理是什么？" class="headerlink" title="Kotlin 内置标准函数 let 的原理是什么？"></a>Kotlin 内置标准函数 let 的原理是什么？</h4><h4 id="Kotlin-语言的-run-高阶函数的原理是什么？"><a href="#Kotlin-语言的-run-高阶函数的原理是什么？" class="headerlink" title="Kotlin 语言的 run 高阶函数的原理是什么？"></a>Kotlin 语言的 run 高阶函数的原理是什么？</h4><h1 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><h4 id="⭐️-简述下-Handler-机制的总体原理？一个线程中可以有几个-Handler？几个-Looper？几个-MessageQueue？"><a href="#⭐️-简述下-Handler-机制的总体原理？一个线程中可以有几个-Handler？几个-Looper？几个-MessageQueue？" class="headerlink" title="⭐️ 简述下 Handler 机制的总体原理？一个线程中可以有几个 Handler？几个 Looper？几个 MessageQueue？"></a>⭐️ 简述下 Handler 机制的总体原理？一个线程中可以有几个 <code>Handler</code>？几个 <code>Looper</code>？几个 <code>MessageQueue</code>？</h4><p>参考：<a href="https://qianyuebits.github.io/2014/05/25/Android-Handler/">Android Handler</a></p>
<h4 id="⭐️-谈谈你对-Activity-runOnUiThread-的理解？"><a href="#⭐️-谈谈你对-Activity-runOnUiThread-的理解？" class="headerlink" title="⭐️ 谈谈你对 Activity.runOnUiThread 的理解？"></a>⭐️ 谈谈你对 <code>Activity.runOnUiThread</code> 的理解？</h4><p>直接看源代码好了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">Handler</span> <span class="variable">mHandler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Handler</span>();</span><br><span class="line"><span class="keyword">private</span> Thread mUiThread;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">runOnUiThread</span><span class="params">(Runnable action)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">        mHandler.post(action);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         action.run();</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="⭐️-HandlerThread-的使用场景和用法？"><a href="#⭐️-HandlerThread-的使用场景和用法？" class="headerlink" title="⭐️ HandlerThread 的使用场景和用法？"></a>⭐️ <code>HandlerThread</code> 的使用场景和用法？</h4><p>封装了 Handler 的 Thread，避免写模板代码。在功能上，类似 <code>newSingleThreadExecutor</code> 线程池，只不过是用 Android 相关概念和机制实现的。</p>
<h4 id="⭐️-Handler-中有-Loop-死循环，为什么没有阻塞主线程，原理是什么"><a href="#⭐️-Handler-中有-Loop-死循环，为什么没有阻塞主线程，原理是什么" class="headerlink" title="⭐️ Handler 中有 Loop 死循环，为什么没有阻塞主线程，原理是什么?"></a>⭐️ Handler 中有 Loop 死循环，为什么没有阻塞主线程，原理是什么?</h4><p>当然阻塞住了，只不过阻塞的时候，主线程没有任务需要执行。当其余线程向主线程 <code>MessageQueue</code> 添加任务后，Looper 的阻塞会被唤醒。</p>
<h4 id="延迟消息是怎么实现的？"><a href="#延迟消息是怎么实现的？" class="headerlink" title="延迟消息是怎么实现的？"></a>延迟消息是怎么实现的？</h4><h4 id="Looper-的等待是如何能够准确唤醒的？"><a href="#Looper-的等待是如何能够准确唤醒的？" class="headerlink" title="Looper 的等待是如何能够准确唤醒的？"></a>Looper 的等待是如何能够准确唤醒的？</h4><h4 id="同步屏障和异步消息是怎么实现的？"><a href="#同步屏障和异步消息是怎么实现的？" class="headerlink" title="同步屏障和异步消息是怎么实现的？"></a>同步屏障和异步消息是怎么实现的？</h4><h4 id="Looper-中的-quitAllowed-字段是啥？有什么用？"><a href="#Looper-中的-quitAllowed-字段是啥？有什么用？" class="headerlink" title="Looper 中的 quitAllowed 字段是啥？有什么用？"></a>Looper 中的 <code>quitAllowed</code> 字段是啥？有什么用？</h4><h3 id="四大组件"><a href="#四大组件" class="headerlink" title="四大组件"></a>四大组件</h3><h4 id="⭐️-Activity-与-Fragment-之间常见的几种通信方式？"><a href="#⭐️-Activity-与-Fragment-之间常见的几种通信方式？" class="headerlink" title="⭐️ Activity 与 Fragment 之间常见的几种通信方式？"></a>⭐️ Activity 与 Fragment 之间常见的几种通信方式？</h4><p>注意下传参方式吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FragmentOne</span> <span class="variable">fragmentOne</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FragmentOne</span>();</span><br><span class="line"><span class="type">Bundle</span> <span class="variable">bundle</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bundle</span>();</span><br><span class="line">bundle.putString(<span class="string">&quot;name&quot;</span>, text);</span><br><span class="line">fragmentOne.setArguments(bundle);</span><br><span class="line"><span class="keyword">return</span> fragmentOne;</span><br></pre></td></tr></table></figure>

<h4 id="⭐️-LaunchMode-的应用场景？"><a href="#⭐️-LaunchMode-的应用场景？" class="headerlink" title="⭐️ LaunchMode 的应用场景？"></a>⭐️ LaunchMode 的应用场景？</h4><p>参见：<a href="https://qianyuebits.github.io/2018/12/04/Android-Intent-FLAG/">Android Activity 启动模式</a></p>
<h4 id="⭐️-BroadcastReceiver，LocalBroadcastReceiver-区别？"><a href="#⭐️-BroadcastReceiver，LocalBroadcastReceiver-区别？" class="headerlink" title="⭐️ BroadcastReceiver，LocalBroadcastReceiver 区别？"></a>⭐️ <code>BroadcastReceiver</code>，<code>LocalBroadcastReceiver</code> 区别？</h4><p><code>BroadcastReceiver</code> 和 <code>LocalBroadcastManager</code> 是 Android 中用于接收广播消息的两个类，它们之间有以下区别：</p>
<ul>
<li>范围：<code>BroadcastReceiver</code> 可以接收全局广播（Global Broadcast），即由任何应用程序发送的广播消息。它可以接收系统级别的广播（如网络变化、电量变化等）以及其他应用程序发送的广播。<code>LocalBroadcastManager</code> 只能接收本地广播（Local Broadcast），即由本应用程序内部发送的广播消息。它仅在当前应用程序的上下文中进行广播传递，不会离开应用程序边界；</li>
<li>使用方式：<code>BroadcastReceiver</code> 是一个普通的广播接收器类，可以通过在 <code>AndroidManifest.xml</code> 文件中声明来注册全局广播接收器。也可以使用动态注册的方式，在代码中指定接收的广播类型和处理逻辑。<code>LocalBroadcastManager</code> 是一个用于处理本地广播的辅助类。我们可以通过调用 <code>LocalBroadcastManager.getInstance(Context)</code> 来获取 <code>LocalBroadcastManager</code> 的实例，并使用它注册和发送本地广播；</li>
<li>效率和性能：由于 <code>LocalBroadcastManager</code> 只在应用程序内部进行广播传递，不需要经过进程间通信（IPC），因此比全局广播具有更高的效率和性能。<code>LocalBroadcastManager</code> 使用了内存级别的消息传递，避免了序列化和反序列化的开销，同时也减少了系统资源的消耗。</li>
</ul>
<p>综上所述，<code>BroadcastReceiver</code> 适用于接收全局广播，可以接收其他应用程序和系统级别的广播消息。而 <code>LocalBroadcastManager</code> 适用于接收本地广播，只在应用程序内部进行广播传递，具有更高的安全性和性能。根据具体的需求和场景，选择合适的广播接收器类进行使用。</p>
<h4 id="⭐️-注册广播有几种方式，这些方式有何优缺点？"><a href="#⭐️-注册广播有几种方式，这些方式有何优缺点？" class="headerlink" title="⭐️ 注册广播有几种方式，这些方式有何优缺点？"></a>⭐️ 注册广播有几种方式，这些方式有何优缺点？</h4><p>在 Android 中，注册广播接收器有以下几种方式：</p>
<ul>
<li>在清单文件中静态注册：通过在 <code>AndroidManifest.xml</code> 文件中声明广播接收器，并指定接收的广播类型，系统会在应用安装时自动注册和管理广播接收器。这种方式适用于需要在应用未运行时也能接收广播的场景。优点是方便，无需手动注册和注销；缺点是无法动态控制广播接收器的生命周期，广播接收器将在应用安装后一直存在。</li>
<li>动态注册：通过在代码中使用registerReceiver()方法动态注册广播接收器，可以在特定的时机注册和注销广播接收器。这种方式适用于需要动态控制广播接收器生命周期的场景，如在特定页面打开时注册广播接收器，页面关闭时注销广播接收器。优点是灵活性高，可以根据需要控制注册和注销；缺点是需要手动管理广播接收器的生命周期。</li>
<li>本地广播：本地广播是一种只在应用内部传播的广播，通过使用 <code>LocalBroadcastManager</code> 类发送和接收广播。本地广播不会离开应用，因此安全性更高且效率更高。本地广播适用于应用内部的通信，不需要与其他应用共享广播。优点是安全性高、效率高、易于使用；缺点是只能在应用内部传播，无法与其他应用通信。</li>
</ul>
<p>每种方式都有其适用的场景和优缺点，选择合适的方式取决于具体需求：</p>
<ul>
<li>静态注册适用于应用未运行时也需要接收广播的情况，如开机启动广播等。但它无法动态控制广播接收器的生命周期，可能会导致不必要的资源消耗；</li>
<li>动态注册适用于需要在特定时机注册和注销广播接收器的场景，可以灵活地控制广播接收器的生命周期。但需要手动管理广播接收器的注册和注销，增加了一定的代码复杂性；</li>
<li>本地广播适用于应用内部的通信，具有较高的安全性和效率。但它只能在应用内部传播，无法与其他应用共享广播；</li>
</ul>
<h4 id="⭐️-谈一谈-startService-和-bindService-的区别，生命周期以及使用场景？"><a href="#⭐️-谈一谈-startService-和-bindService-的区别，生命周期以及使用场景？" class="headerlink" title="⭐️ 谈一谈 startService 和 bindService 的区别，生命周期以及使用场景？"></a>⭐️ 谈一谈 <code>startService</code> 和 <code>bindService</code> 的区别，生命周期以及使用场景？</h4><p>参见：<a href="https://qianyuebits.github.io/2024/01/18/Android-Service/">Android Service</a></p>
<h4 id="⭐️-IntentService-的应用场景和使用姿势？"><a href="#⭐️-IntentService-的应用场景和使用姿势？" class="headerlink" title="⭐️ IntentService 的应用场景和使用姿势？"></a>⭐️ <code>IntentService</code> 的应用场景和使用姿势？</h4><p><code>IntentService</code> 是 Android 提供的一种特殊的服务（Service）类，用于处理异步任务和执行后台操作，本质上是 Service + Handler 的封装。<strong>它在后台线程中逐个处理传递给它的每个 Intent 请求，并且在处理完最后一个请求后自动停止。</strong></p>
<p><code>IntentService</code> 的应用场景和使用姿势如下：</p>
<ul>
<li>异步任务处理：<code>IntentService</code> 适用于需要在后台执行异步任务的场景。比如，下载文件、上传数据、执行网络请求等任务可以放在 <code>IntentService</code> 中处理，而不会阻塞主线程；</li>
<li>顺序执行：<code>IntentService</code> 会按照请求的顺序逐个处理 Intent。这对于需要保证任务有序执行的场景非常有用；</li>
<li>自动停止：<code>IntentService</code> 在处理完最后一个 Intent 请求后会自动停止，无需手动调用 <code>stopSelf()</code> 或 <code>stopService()</code> 停止服务。这样可以避免因为忘记停止服务而导致的资源浪费；</li>
</ul>
<p>使用 <code>IntentService</code> 的方式如下：</p>
<ol>
<li>创建自定义的 <code>IntentService</code> 子类，并实现 <code>onHandleIntent()</code> 方法。在 <code>onHandleIntent()</code> 方法中处理传递给 <code>IntentService</code> 的每个 Intent 请求；</li>
<li>在需要使用 <code>IntentService</code> 的地方，创建一个新的 Intent 并调用 <code>startService()</code> 方法来启动 <code>IntentService</code>。可以通过 Intent 的附加数据传递参数给 <code>IntentService</code>；</li>
<li><code>IntentService</code> 会在后台线程中逐个处理传递给它的每个 Intent 请求。在 <code>onHandleIntent()</code> 方法中执行具体的后台操作，如网络请求、文件操作等；</li>
<li>在 <code>onHandleIntent()</code> 方法中处理完最后一个请求后，<code>IntentService</code> 会自动停止服务，无需手动调用停止服务的方法；</li>
</ol>
<p>总之，<code>IntentService</code> 适用于需要在后台执行异步任务、保证任务有序执行，并且自动停止服务的场景。它简化了后台任务的处理和服务的管理，提供了方便的异步操作机制。</p>
<h4 id="⭐️-Service-如何进行保活？"><a href="#⭐️-Service-如何进行保活？" class="headerlink" title="⭐️ Service 如何进行保活？"></a>⭐️ Service 如何进行保活？</h4><p>在 Android 中，Service 的保活是指在特定条件下，确保 Service 在后台持续运行，以便执行某些任务或提供某些功能。以下是一些常见的方法来实现 Service 的保活：</p>
<ul>
<li>前台服务（Foreground Service）：将 Service 设置为前台服务，通过调用 <code>startForeground()</code> 方法将其置于前台状态。前台服务会显示一个可见的通知，告知用户当前有一个正在运行的服务，从而提高服务的优先级，减少被系统杀死的概率；</li>
<li>使用 <code>START_STICKY</code>：在启动 Service 时，通过返回 <code>START_STICKY</code> 标志位告诉系统，如果 Service 被异常终止，系统会尝试重新启动它。这样可以保证 Service 在一定程度上持续运行。需要注意的是，当系统内存不足时，系统可能会终止 Service；</li>
<li>使用系统广播：注册一些系统广播，例如 <code>BOOT_COMPLETED</code>（开机完成）、<code>CONNECTIVITY_CHANGE</code>（网络连接变化）等，当接收到这些广播时，启动你的 Service。这样可以在特定事件发生时重新启动 Service；</li>
<li>使用 <code>AlarmManager</code>：通过 <code>AlarmManager</code> 在指定时间间隔触发一个 <code>PendingIntent</code>，启动 Service。这样可以定期唤醒 Service，确保其持续运行；</li>
<li>双进程守护：创建一个独立的进程，与主进程相互守护。当主进程被杀死时，独立进程会重新启动主进程，并重新启动 Service。</li>
</ul>
<p><strong>需要注意的是，Android 系统对于后台运行的应用有一些限制和策略，如后台应用限制、电池优化等。在实现 Service 的保活时，需要遵循系统的规则，并合理利用系统提供的机制，以避免过度耗电或影响用户体验。</strong></p>
<p>另外，需要根据具体的业务需求和应用场景来选择适合的保活方法，并进行充分的测试和优化，以确保 Service 的稳定运行。</p>
<h4 id="⭐️-说下切换横竖屏时-Activity-的生命周期"><a href="#⭐️-说下切换横竖屏时-Activity-的生命周期" class="headerlink" title="⭐️ 说下切换横竖屏时 Activity 的生命周期?"></a>⭐️ 说下切换横竖屏时 Activity 的生命周期?</h4><p>参考：<a href="https://qianyuebits.github.io/2014/05/25/Android-Activity-Lifecycle/">Android Handler</a></p>
<h4 id="⭐️-简单介绍下-ContentProvider-是如何实现数据共享的？说说-ContentProvider、ContentResolver、ContentObserver-之间的关系？"><a href="#⭐️-简单介绍下-ContentProvider-是如何实现数据共享的？说说-ContentProvider、ContentResolver、ContentObserver-之间的关系？" class="headerlink" title="⭐️ 简单介绍下 ContentProvider 是如何实现数据共享的？说说 ContentProvider、ContentResolver、ContentObserver 之间的关系？"></a>⭐️ 简单介绍下 <code>ContentProvider</code> 是如何实现数据共享的？说说 <code>ContentProvider</code>、<code>ContentResolver</code>、<code>ContentObserver</code> 之间的关系？</h4><p>具体使用例子参考，系统经典应用有”联系人”：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/providers/content-provider-creating?hl=zh-cn">创建 content provider</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/carson_ho/article/details/76101093">Carson带你学Android：关于ContentProvider的知识都在这里了！</a></li>
</ol>
<p><code>ContentProvider</code> 是 Android 中用于实现数据共享的组件。它提供了一种标准化的接口，允许应用程序之间共享数据，包括读取、写入、更新和删除等操作。以下是 <code>ContentProvider</code> 实现数据共享的主要步骤：</p>
<ol>
<li>定义数据模型：首先，需要定义要共享的数据的模型，即确定数据的结构和字段。这可以通过创建一个数据库表或其他数据结构来完成；</li>
<li>创建 <code>ContentProvider</code> 子类：然后，在应用的代码中创建一个继承自 <code>ContentProvider</code> 的子类。该子类负责处理与数据相关的请求和操作；</li>
<li>实现 <code>ContentProvider</code> 方法：在 <code>ContentProvider</code> 的子类中，需要实现一些关键方法，包括 <code>query()</code>、<code>insert()</code>、<code>update()</code>、<code>delete()</code> 等。这些方法用于处理对数据的查询、插入、更新和删除操作；</li>
<li>声明权限和 URI：在清单文件（<code>AndroidManifest.xml</code>）中声明 <code>ContentProvider</code>，并指定相应的权限和 URI。权限用于控制其他应用程序访问 <code>ContentProvider</code> 的权限级别，而 URI 则用于标识和访问特定的数据；</li>
<li>授权数据访问：在 <code>ContentProvider</code> 的子类中，可以通过重写 <code>onCreate()</code> 方法来执行初始化操作，并在其中完成数据源的创建或打开。同时，可以在 <code>ContentProvider</code> 的子类中定义访问数据的权限规则；</li>
<li>处理数据操作：在 <code>ContentProvider</code> 的子类中，根据传入的操作类型和参数，实现相应的数据操作逻辑。例如，在 <code>query()</code> 方法中执行数据查询，然后返回查询结果给调用者。</li>
<li>访问 <code>ContentProvider</code>：其他应用程序可以通过使用 <code>ContentResolver</code> 类来访问 <code>ContentProvider</code> 提供的数据。<code>ContentResolver</code> 提供了一组方法，用于查询、插入、更新和删除数据。</li>
</ol>
<p>通过以上步骤，<code>ContentProvider</code> 实现了数据共享的功能。其他应用程序可以通过 URI 和相应的权限来访问共享的数据，而不需要了解数据的具体实现细节。这种方式实现了应用程序之间的数据共享和解耦，提供了一种统一的数据访问方式。</p>
<p>综上：</p>
<ol>
<li>ContentProvider 用于应用向外提供增删改查功能（一般底层使用 DB）；</li>
<li>ContentResolver 用于其他应用查询 ContentProvider 提供的数据；</li>
<li>ContentObserver 用于监听数据的变化，但需要 ContentProvider 在数据变化时通过 <code>getContext().getContentResolver().notifyChange()</code> 方法主动通知，比如在 <code>delete()</code> 中调用；</li>
</ol>
<h3 id="其他-1"><a href="#其他-1" class="headerlink" title="其他"></a>其他</h3><h4 id="子线程能否更新-UI？为什么？"><a href="#子线程能否更新-UI？为什么？" class="headerlink" title="子线程能否更新 UI？为什么？"></a>子线程能否更新 UI？为什么？</h4><h4 id="IntentFilter-是什么？有哪些使用场景？"><a href="#IntentFilter-是什么？有哪些使用场景？" class="headerlink" title="IntentFilter 是什么？有哪些使用场景？"></a><code>IntentFilter</code> 是什么？有哪些使用场景？</h4><h4 id="Intent-传输数据的大小有限制吗？如何解决？"><a href="#Intent-传输数据的大小有限制吗？如何解决？" class="headerlink" title="Intent 传输数据的大小有限制吗？如何解决？"></a>Intent 传输数据的大小有限制吗？如何解决？</h4><h4 id="AsyncTask-的优点和缺点？"><a href="#AsyncTask-的优点和缺点？" class="headerlink" title="AsyncTask 的优点和缺点？"></a>AsyncTask 的优点和缺点？</h4><h4 id="介绍一下-Android-事件的分发流程-onTouchEvent-、onTouch-、onClick-、onLongClick-的先后顺序"><a href="#介绍一下-Android-事件的分发流程-onTouchEvent-、onTouch-、onClick-、onLongClick-的先后顺序" class="headerlink" title="介绍一下 Android 事件的分发流程(onTouchEvent()、onTouch()、onClick()、onLongClick() 的先后顺序)"></a>介绍一下 Android 事件的分发流程(<code>onTouchEvent()</code>、<code>onTouch()</code>、<code>onClick()</code>、<code>onLongClick()</code> 的先后顺序)</h4><h4 id="View-的绘制流程"><a href="#View-的绘制流程" class="headerlink" title="View 的绘制流程"></a>View 的绘制流程</h4><h4 id="Window-和-DecorView-是什么？DecorView-又是如何和-Window-建立联系的"><a href="#Window-和-DecorView-是什么？DecorView-又是如何和-Window-建立联系的" class="headerlink" title="Window 和 DecorView 是什么？DecorView 又是如何和 Window 建立联系的?"></a>Window 和 <code>DecorView</code> 是什么？<code>DecorView</code> 又是如何和 Window 建立联系的?</h4><h4 id="谈一谈-Activity，View，Window-三者的关系？"><a href="#谈一谈-Activity，View，Window-三者的关系？" class="headerlink" title="谈一谈 Activity，View，Window 三者的关系？"></a>谈一谈 Activity，View，Window 三者的关系？</h4><h4 id="谈谈你对-Window-和-WindowManager-的理解？有了解过-WindowInsets-吗？它有哪些应用？"><a href="#谈谈你对-Window-和-WindowManager-的理解？有了解过-WindowInsets-吗？它有哪些应用？" class="headerlink" title="谈谈你对 Window 和 WindowManager 的理解？有了解过 WindowInsets 吗？它有哪些应用？"></a>谈谈你对 Window 和 <code>WindowManager</code> 的理解？有了解过 <code>WindowInsets</code> 吗？它有哪些应用？</h4><h4 id="简述一下-Android-中-UI-的刷新机制？invalidate-和-postInvalidate-的区别？"><a href="#简述一下-Android-中-UI-的刷新机制？invalidate-和-postInvalidate-的区别？" class="headerlink" title="简述一下 Android 中 UI 的刷新机制？invalidate() 和 postInvalidate() 的区别？"></a>简述一下 Android 中 UI 的刷新机制？<code>invalidate()</code> 和 <code>postInvalidate()</code> 的区别？</h4><p><code>postInvalidate()</code> 最终调用到的是 <code>invalidate()</code>，区别是 <code>postInvalidate()</code> 可以从非主线程调用。</p>
<h4 id="⭐️-Android-中的动画有哪几类，它们的特点和区别是什么"><a href="#⭐️-Android-中的动画有哪几类，它们的特点和区别是什么" class="headerlink" title="⭐️ Android 中的动画有哪几类，它们的特点和区别是什么"></a>⭐️ Android 中的动画有哪几类，它们的特点和区别是什么</h4><p>在 Android 中，常见的动画可以分为以下几类：</p>
<ol>
<li>View 动画（View Animation）：<ul>
<li>特点：View 动画是一种补间动画（Tween Animation），通过对视图的属性进行逐帧动画的变化来实现动画效果。它可以应用于任何视图对象，并支持平移、缩放、旋转和透明度等基本动画效果。</li>
<li>区别：<strong>View 动画只是改变了视图的外观，而不会改变视图的实际位置和大小。</strong>它适用于简单的动画效果，但对于复杂的动画或需要与用户交互的场景可能不够灵活。</li>
</ul>
</li>
<li>属性动画（Property Animation）：<ul>
<li>特点：属性动画是一种更灵活和强大的动画机制，可以对任意对象的属性进行动画操作。它通过改变属性值的方式来实现动画效果，可以实现平移、缩放、旋转、透明度等动画效果，并且可以支持更复杂的动画组合和交互。</li>
<li>区别：属性动画可以直接改变视图对象的属性值，因此在动画过程中可以实时响应布局的改变。与 View 动画相比，属性动画更加灵活、功能更强大，适用于更复杂的动画场景。API level 11（3.0）才支持。</li>
</ul>
</li>
<li>帧动画（Frame Animation）：<ul>
<li>特点：帧动画是一种基于逐帧图像的动画效果，通过连续播放一系列预定义的图像（帧）来实现动画效果。每帧之间的切换由系统自动处理，可以创建逐帧的动画效果。</li>
<li>区别：帧动画适用于不需要复杂交互和过渡效果的简单动画场景。它会将所有帧图像加载到内存中，可能会占用较多的内存资源，因此对于帧数较多或图像较大的动画，需要注意内存的消耗。</li>
</ul>
</li>
<li>转场动画（Transition Animation）：<ul>
<li>特点：转场动画是一种用于在不同视图之间进行过渡的动画效果。它可以实现淡入淡出、滑动、缩放等过渡效果，用于改变应用界面的视觉效果，提供流畅的界面切换体验。</li>
<li>区别：转场动画主要用于界面之间的切换和过渡效果，可以通过 <code>TransitionManager</code> 类和相关的过渡效果类来实现。</li>
</ul>
</li>
</ol>
<p>这些动画类别各有特点和适用场景。在选择使用动画时，需要根据具体的需求和效果来选择合适的动画类型。例如，简单的视图动画可以使用 View 动画，需要更复杂的效果和交互则可以使用属性动画，切换界面时可以考虑转场动画等。</p>
<h4 id="⭐️-Parcelable-和-Serializable-区别"><a href="#⭐️-Parcelable-和-Serializable-区别" class="headerlink" title="⭐️ Parcelable 和 Serializable 区别"></a>⭐️ <code>Parcelable</code> 和 <code>Serializable</code> 区别</h4><p>在 Android 开发中，<code>Parcelable</code> 和 <code>Serializable</code> 是两种用于实现对象序列化的机制。它们在实现和性能方面有以下区别：</p>
<ol>
<li>实现方式：</li>
</ol>
<ul>
<li><code>Serializable</code>：<code>Serializable</code> 是 Java 平台提供的标准序列化机制。要使一个类可序列化，只需实现 <code>Serializable</code> 接口，然后框架会自动进行序列化和反序列化；</li>
<li><code>Parcelable</code>：<code>Parcelable</code> 是 Android 特定的接口，需要手动实现序列化和反序列化的逻辑。要使用 <code>Parcelable</code>，必须实现 <code>Parcelable</code> 接口并实现 <code>writeToParcel()</code> 和 <code>createFromParcel()</code> 方法；</li>
</ul>
<ol start="2">
<li>性能：</li>
</ol>
<ul>
<li><code>Parcelable</code> 通常比 <code>Serializable</code> 具有更高的性能（有测试文章表明 10x 的差距）。<code>Parcelable</code> 在序列化和反序列化过程中的开销较小，因为它是手动在内存操作的，不需要通过反射和字节码分析；</li>
<li><code>Serializable</code> 需要通过 Java 的反射机制，产生很多临时对象，这可能会导致一些性能损耗；</li>
</ul>
<p>总结来说：</p>
<ol>
<li>在 Android 上如果可以使用 <code>Parcelable</code> 还是使用 <code>Parcelable</code> 为好；如果偷懒，在对象大小较小的情况下，也可以使用 <code>Serializable</code>；</li>
<li>网络传输和保存至磁盘的时候用 <code>Serializable</code>，相对而言，它更通用；</li>
</ol>
<h4 id="⭐️-include、merge、ViewStub-的作用"><a href="#⭐️-include、merge、ViewStub-的作用" class="headerlink" title="⭐️ include、merge、ViewStub 的作用"></a>⭐️ <code>include</code>、<code>merge</code>、<code>ViewStub</code> 的作用</h4><ul>
<li><code>include</code> 布局文件复用</li>
<li><code>merge</code> include 布局文件时可以减少布局层级</li>
<li><code>ViewStub</code> 与 <code>include</code> 类似，但是按需加载，需要手动调用 <code>inflate()</code> 方法，注意，此时引用的文件不能使用 <code>merge</code> 标签；</li>
</ul>
<h4 id="⭐️-px、dp、sp-的区别"><a href="#⭐️-px、dp、sp-的区别" class="headerlink" title="⭐️ px、dp、sp 的区别"></a>⭐️ px、dp、sp 的区别</h4><ul>
<li><code>px</code> 即像素，1px 代表屏幕上一个物理的像素点；</li>
<li><code>dp</code> device independent pixels（设备独立像素），px &#x3D; dp * (dpi&#x2F;160)，其中 dpi 即像素密度，定义这个单位的目的是为了使得不同的像素密度的设备上显示的 View 有相同的物理尺寸；</li>
<li><code>sp</code> 与缩放无关的抽象像素（Scale-independent Pixel），支持自提大小调整；</li>
</ul>
<h4 id="⭐️-使用-Fragment-有什么好处？有没有使用过嵌套-Fragment？"><a href="#⭐️-使用-Fragment-有什么好处？有没有使用过嵌套-Fragment？" class="headerlink" title="⭐️ 使用 Fragment 有什么好处？有没有使用过嵌套 Fragment？"></a>⭐️ 使用 Fragment 有什么好处？有没有使用过嵌套 Fragment？</h4><p>Fragment 表示应用界面中可重复使用的一部分。Fragment 定义和管理自己的布局，具有自己的生命周期，并且可以处理自己的输入事件。Fragment 不能独立存在，而是必须由 Activity 或另一个 Fragment 托管。Fragment 的视图层次结构会成为宿主的视图层次结构的一部分，或附加到宿主的视图层次结构。</p>
<p><strong>Fragment 允许您将界面划分为离散的区块，从而将模块化和可重用性引入 Activity 的界面。Activity 是围绕应用的界面放置全局元素（如抽屉式导航栏）的理想位置。相反，Fragment 更适合定义和管理单个屏幕或部分屏幕的界面。</strong></p>
<h4 id="⭐️-进程优先级"><a href="#⭐️-进程优先级" class="headerlink" title="⭐️ 进程优先级"></a>⭐️ 进程优先级</h4><p>在 Android 中，进程的优先级可以分为以下几个级别，按优先级从高到低排列：</p>
<ol>
<li><strong>前台进程（Foreground Process）</strong> 前台进程是指当前对用户可见并与用户正在交互的应用进程。例如，正在展示前台界面、正在播放音乐或执行前台服务的进程都属于前台进程。前台进程拥有最高的优先级，系统会尽可能保持其运行，并在内存不足时尽量不回收前台进程。</li>
<li><strong>可见进程（Visible Process）</strong> 可见进程是指虽然没有在前台展示界面，但对用户可见的应用进程。例如，一个 Activity 被另一个 Activity 部分遮挡时，被遮挡的 Activity 所在的进程就是可见进程。可见进程的优先级较高，但低于前台进程，当系统内存不足时可能会被回收。</li>
<li><strong>服务进程（Service Process）</strong> 服务进程是指正在执行后台服务的应用进程。后台服务在没有与用户直接交互的情况下执行一些长时间运行的任务。服务进程的优先级低于前台和可见进程，但高于后台进程。当系统内存不足时，服务进程可能会被回收。</li>
<li><strong>后台进程（Background Process）</strong> 后台进程是指没有对用户可见且没有正在执行前台服务的应用进程。这些进程处于后台运行，不直接与用户交互，且对系统性能影响较小。后台进程的优先级较低，当系统内存不足时容易被系统回收。</li>
<li><strong>空进程（Empty Process）</strong> 空进程是指没有任何活动组件（如 Activity、Service）的应用进程。这些进程被系统保留，以缩短后续创建组件的时间。空进程的优先级最低，当系统需要更多内存时，空进程会被优先回收。</li>
</ol>
<p>需要注意的是，Android 系统会根据当前的内存使用情况和进程的活动状态动态调整进程的优先级，并根据需要进行回收。此外，应用可以通过设置进程的优先级、使用前台服务等方式来影响进程的优先级和保活能力，但也需要注意平衡系统资源和用户体验的关系。</p>
<h4 id="⭐️-什么是-ANR-如何避免它？"><a href="#⭐️-什么是-ANR-如何避免它？" class="headerlink" title="⭐️ 什么是 ANR 如何避免它？"></a>⭐️ 什么是 ANR 如何避免它？</h4><p>ANR（Application Not Responding）是指应用程序未响应，Android 系统对于一些事件需要在一定时间范围内完成，如果超过预定时间未能得到有效响应或者响应时间过长，都会造成 ANR。具体场景：</p>
<ol>
<li>点击事件（按键和触摸事件）5s 内没被处理；</li>
<li>Service：前台 Service 20s，后台 Service 200s 未完成启动；</li>
<li>BroadcastReceiver：前台广播 10s，后台广播 60s，<code>onReceive()</code> 在规定时间内没处理完；</li>
<li>ContentProvider：publish 在 10s 内没处理完；<br>避免办法：不要在主线程做耗时操作。</li>
</ol>
<h4 id="⭐️-assets-目录与-res-目录的区别？"><a href="#⭐️-assets-目录与-res-目录的区别？" class="headerlink" title="⭐️ assets 目录与 res 目录的区别？"></a>⭐️ assets 目录与 res 目录的区别？</h4><p>在 Android 项目中，assets 目录和 res 目录是用于存放不同类型资源的两个不同目录，它们有以下区别：</p>
<ul>
<li>存放位置：<ul>
<li>assets 目录位于 Android 项目的根目录下，与 src、res 目录同级。</li>
<li>res 目录位于 app 模块的 src 目录下，通常是 app&#x2F;src&#x2F;main&#x2F;res。</li>
</ul>
</li>
<li>访问方式：<ul>
<li>assets 目录中的资源通过 <code>AssetManager</code> 类进行访问。可以使用 <code>AssetManager</code> 的 <code>open()</code> 方法打开文件流来读取 assets 目录下的资源文件。</li>
<li>res 目录中的资源通过自动生成的 R 类进行访问。可以通过 R 类的相应字段获取资源的 ID，然后使用 Context 的方法（如 <code>getResources()</code>）来获取资源的实际值。</li>
</ul>
</li>
<li>资源类型：<ul>
<li>assets 目录可以存放任意类型的文件，如文本文件、音频文件、视频文件等。在编译打包过程中，assets 目录下的文件会被原封不动地复制到 APK 包中。</li>
<li>res 目录用于存放特定类型的资源文件，如布局文件、字符串资源、图像资源、颜色资源等。这些资源文件会在编译过程中经过处理和优化，并生成相应的二进制资源文件，最终打包到 APK 中。</li>
</ul>
</li>
<li>资源访问和国际化：<ul>
<li>assets 目录下的资源文件没有经过 Android 资源管理系统的处理，无法直接进行国际化、主题切换等功能。访问时需要自行处理资源的加载和适配。</li>
<li>res 目录下的资源文件可以通过资源的不同配置（如语言、屏幕密度、主题等）自动适配，并由 Android 系统根据设备的配置自动选择最佳匹配的资源。</li>
</ul>
</li>
</ul>
<p>综上所述，assets 目录适合存放一些非特定类型的资源文件，如自定义数据文件、原始媒体文件等。而 res 目录则用于存放经过处理和优化的特定类型资源文件，可以通过资源管理系统进行访问、适配和国际化。</p>
<h4 id="Bitmap-使用时候注意什么？如何计算一个-Bitmap-占用内存的大小，怎么保证加载-Bitmap-不产生内存溢出？"><a href="#Bitmap-使用时候注意什么？如何计算一个-Bitmap-占用内存的大小，怎么保证加载-Bitmap-不产生内存溢出？" class="headerlink" title="Bitmap 使用时候注意什么？如何计算一个 Bitmap 占用内存的大小，怎么保证加载 Bitmap 不产生内存溢出？"></a>Bitmap 使用时候注意什么？如何计算一个 Bitmap 占用内存的大小，怎么保证加载 Bitmap 不产生内存溢出？</h4><h4 id="说说-WorkManager"><a href="#说说-WorkManager" class="headerlink" title="说说 WorkManager"></a>说说 <code>WorkManager</code></h4><h4 id="什么是-RemoteViews？使用场景有哪些？"><a href="#什么是-RemoteViews？使用场景有哪些？" class="headerlink" title="什么是 RemoteViews？使用场景有哪些？"></a>什么是 <code>RemoteViews</code>？使用场景有哪些？</h4><h4 id="谈一谈-SurfaceView-与-TextureView-的使用场景和用法？"><a href="#谈一谈-SurfaceView-与-TextureView-的使用场景和用法？" class="headerlink" title="谈一谈 SurfaceView 与 TextureView 的使用场景和用法？"></a>谈一谈 <code>SurfaceView</code> 与 <code>TextureView</code> 的使用场景和用法？</h4><h4 id="SharedPreferences-是线程安全的吗？它的-commit-和-apply-方法有什么区别？"><a href="#SharedPreferences-是线程安全的吗？它的-commit-和-apply-方法有什么区别？" class="headerlink" title="SharedPreferences 是线程安全的吗？它的 commit 和 apply 方法有什么区别？"></a><code>SharedPreferences</code> 是线程安全的吗？它的 commit 和 apply 方法有什么区别？</h4><h4 id="PathClassLoader-和-DexClassLoader-有何区别？"><a href="#PathClassLoader-和-DexClassLoader-有何区别？" class="headerlink" title="PathClassLoader 和 DexClassLoader 有何区别？"></a><code>PathClassLoader</code> 和 <code>DexClassLoader</code> 有何区别？</h4><h4 id="为什么推荐用-SparseArray-代替-HashMap？"><a href="#为什么推荐用-SparseArray-代替-HashMap？" class="headerlink" title="为什么推荐用 SparseArray 代替 HashMap？"></a>为什么推荐用 <code>SparseArray</code> 代替 HashMap？</h4><h4 id="什么是-Lifecycle？请分析其内部原理和使用场景？"><a href="#什么是-Lifecycle？请分析其内部原理和使用场景？" class="headerlink" title="什么是 Lifecycle？请分析其内部原理和使用场景？"></a>什么是 <code>Lifecycle</code>？请分析其内部原理和使用场景？</h4><h4 id="ViewModel-的出现是为了解决什么问题？并简要说说它的内部原理？"><a href="#ViewModel-的出现是为了解决什么问题？并简要说说它的内部原理？" class="headerlink" title="ViewModel 的出现是为了解决什么问题？并简要说说它的内部原理？"></a><code>ViewModel</code> 的出现是为了解决什么问题？并简要说说它的内部原理？</h4><h4 id="Java-与-JS-代码如何互调？有做过相关优化吗？"><a href="#Java-与-JS-代码如何互调？有做过相关优化吗？" class="headerlink" title="Java 与 JS 代码如何互调？有做过相关优化吗？"></a>Java 与 JS 代码如何互调？有做过相关优化吗？</h4><h4 id="什么是-JNI？具体说说如何实现-Java-与-C-的互调？"><a href="#什么是-JNI？具体说说如何实现-Java-与-C-的互调？" class="headerlink" title="什么是 JNI？具体说说如何实现 Java 与 C++ 的互调？"></a>什么是 JNI？具体说说如何实现 Java 与 C++ 的互调？</h4><h4 id="有没有看过-AsyncTask-的源码？（似乎还挺常见的）"><a href="#有没有看过-AsyncTask-的源码？（似乎还挺常见的）" class="headerlink" title="有没有看过 AsyncTask 的源码？（似乎还挺常见的）"></a>有没有看过 <code>AsyncTask</code> 的源码？（似乎还挺常见的）</h4><h4 id="是否可以加载任意目录下的-so-文件，so-文件有几种加载方式？加载so时如何考虑-32-位和-64-位的不同，如何考虑不同的-arm-平台？"><a href="#是否可以加载任意目录下的-so-文件，so-文件有几种加载方式？加载so时如何考虑-32-位和-64-位的不同，如何考虑不同的-arm-平台？" class="headerlink" title="是否可以加载任意目录下的 so 文件，so 文件有几种加载方式？加载so时如何考虑 32 位和 64 位的不同，如何考虑不同的 arm 平台？"></a>是否可以加载任意目录下的 so 文件，so 文件有几种加载方式？加载so时如何考虑 32 位和 64 位的不同，如何考虑不同的 arm 平台？</h4><h2 id="Framework"><a href="#Framework" class="headerlink" title="Framework"></a>Framework</h2><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><h4 id="Android-进程间的通信方式"><a href="#Android-进程间的通信方式" class="headerlink" title="Android 进程间的通信方式"></a>Android 进程间的通信方式</h4><h4 id="Binder-机制是如何跨进程的"><a href="#Binder-机制是如何跨进程的" class="headerlink" title="Binder 机制是如何跨进程的"></a>Binder 机制是如何跨进程的</h4><h4 id="Binder-是如何做到一次拷贝的？mmap-的内存映射原理了解吗"><a href="#Binder-是如何做到一次拷贝的？mmap-的内存映射原理了解吗" class="headerlink" title="Binder 是如何做到一次拷贝的？mmap 的内存映射原理了解吗"></a>Binder 是如何做到一次拷贝的？<code>mmap</code> 的内存映射原理了解吗</h4><h4 id="谈一谈屏幕刷新机制？"><a href="#谈一谈屏幕刷新机制？" class="headerlink" title="谈一谈屏幕刷新机制？"></a>谈一谈屏幕刷新机制？</h4><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><h4 id="App-启动流程（Activity-的冷启动流程）"><a href="#App-启动流程（Activity-的冷启动流程）" class="headerlink" title="App 启动流程（Activity 的冷启动流程）"></a>App 启动流程（Activity 的冷启动流程）</h4><h4 id="大体说清一个应用程序安装到手机上时发生了什么？"><a href="#大体说清一个应用程序安装到手机上时发生了什么？" class="headerlink" title="大体说清一个应用程序安装到手机上时发生了什么？"></a>大体说清一个应用程序安装到手机上时发生了什么？</h4><h3 id="系统-Service"><a href="#系统-Service" class="headerlink" title="系统 Service"></a>系统 Service</h3><h4 id="ActivityManagerService-是什么？什么时候初始化的？有什么作用？"><a href="#ActivityManagerService-是什么？什么时候初始化的？有什么作用？" class="headerlink" title="ActivityManagerService 是什么？什么时候初始化的？有什么作用？"></a><code>ActivityManagerService</code> 是什么？什么时候初始化的？有什么作用？</h4><h4 id="AMS-是如何管理-Activity-的？"><a href="#AMS-是如何管理-Activity-的？" class="headerlink" title="AMS 是如何管理 Activity 的？"></a>AMS 是如何管理 Activity 的？</h4><h3 id="其他-2"><a href="#其他-2" class="headerlink" title="其他"></a>其他</h3><h4 id="说说四大组件的通信机制"><a href="#说说四大组件的通信机制" class="headerlink" title="说说四大组件的通信机制"></a>说说四大组件的通信机制</h4><h4 id="为什么-Intent-不能传递大数据"><a href="#为什么-Intent-不能传递大数据" class="headerlink" title="为什么 Intent 不能传递大数据"></a>为什么 Intent 不能传递大数据</h4><h4 id="ActivityThread-是什么？ApplicationThread-是什么？"><a href="#ActivityThread-是什么？ApplicationThread-是什么？" class="headerlink" title="ActivityThread 是什么？ApplicationThread 是什么？"></a><code>ActivityThread</code> 是什么？<code>ApplicationThread</code> 是什么？</h4><h4 id="Instrumentation-是什么？和-ActivityThread-是什么关系？"><a href="#Instrumentation-是什么？和-ActivityThread-是什么关系？" class="headerlink" title="Instrumentation 是什么？和 ActivityThread 是什么关系？"></a><code>Instrumentation</code> 是什么？和 <code>ActivityThread</code> 是什么关系？</h4><h4 id="ActivityManagerService-和-zygote-进程通信是如何实现的"><a href="#ActivityManagerService-和-zygote-进程通信是如何实现的" class="headerlink" title="ActivityManagerService 和 zygote 进程通信是如何实现的"></a><code>ActivityManagerService</code> 和 zygote 进程通信是如何实现的</h4><h4 id="JVM、ART、Dalvik-的区别和联系"><a href="#JVM、ART、Dalvik-的区别和联系" class="headerlink" title="JVM、ART、Dalvik 的区别和联系"></a>JVM、ART、Dalvik 的区别和联系</h4><h4 id="简述-Activity、Window、WindowManager、WindowManagerImpl、View、ViewRootImpl-的作用和相互之间的关系"><a href="#简述-Activity、Window、WindowManager、WindowManagerImpl、View、ViewRootImpl-的作用和相互之间的关系" class="headerlink" title="简述 Activity、Window、WindowManager、WindowManagerImpl、View、ViewRootImpl 的作用和相互之间的关系"></a>简述 Activity、Window、WindowManager、WindowManagerImpl、View、ViewRootImpl 的作用和相互之间的关系</h4><h4 id="数据库如何短时间高效批量插入数据？（SQLite）"><a href="#数据库如何短时间高效批量插入数据？（SQLite）" class="headerlink" title="数据库如何短时间高效批量插入数据？（SQLite）"></a>数据库如何短时间高效批量插入数据？（SQLite）</h4><h4 id="如何理解-Context？ApplicationContext-和-ActivityContext-的区别"><a href="#如何理解-Context？ApplicationContext-和-ActivityContext-的区别" class="headerlink" title="如何理解 Context？ApplicationContext 和 ActivityContext 的区别"></a>如何理解 Context？<code>ApplicationContext</code> 和 <code>ActivityContext</code> 的区别</h4><h4 id="是否了解硬件加速？"><a href="#是否了解硬件加速？" class="headerlink" title="是否了解硬件加速？"></a>是否了解硬件加速？</h4><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h4 id="如何对-APK-瘦身？请提出不少于-5-个方案"><a href="#如何对-APK-瘦身？请提出不少于-5-个方案" class="headerlink" title="如何对 APK 瘦身？请提出不少于 5 个方案"></a>如何对 APK 瘦身？请提出不少于 5 个方案</h4><h4 id="列表卡顿怎么优化？（可以提解决问题的思路）"><a href="#列表卡顿怎么优化？（可以提解决问题的思路）" class="headerlink" title="列表卡顿怎么优化？（可以提解决问题的思路）"></a>列表卡顿怎么优化？（可以提解决问题的思路）</h4><h4 id="你们做了哪些稳定性方面的优化？"><a href="#你们做了哪些稳定性方面的优化？" class="headerlink" title="你们做了哪些稳定性方面的优化？"></a>你们做了哪些稳定性方面的优化？</h4><h4 id="App-启动速度优化"><a href="#App-启动速度优化" class="headerlink" title="App 启动速度优化"></a>App 启动速度优化</h4><h4 id="谈谈你对-Android-性能优化方面的了解？"><a href="#谈谈你对-Android-性能优化方面的了解？" class="headerlink" title="谈谈你对 Android 性能优化方面的了解？"></a>谈谈你对 Android 性能优化方面的了解？</h4><h4 id="一般什么情况下会导致内存泄漏问题？"><a href="#一般什么情况下会导致内存泄漏问题？" class="headerlink" title="一般什么情况下会导致内存泄漏问题？"></a>一般什么情况下会导致内存泄漏问题？</h4><h4 id="自定义-Handler-时如何有效地避免内存泄漏问题？"><a href="#自定义-Handler-时如何有效地避免内存泄漏问题？" class="headerlink" title="自定义 Handler 时如何有效地避免内存泄漏问题？"></a>自定义 Handler 时如何有效地避免内存泄漏问题？</h4><h4 id="哪些情况下会导致-OOM-问题？"><a href="#哪些情况下会导致-OOM-问题？" class="headerlink" title="哪些情况下会导致 OOM 问题？"></a>哪些情况下会导致 OOM 问题？</h4><h4 id="ANR-出现的场景以及解决方案？"><a href="#ANR-出现的场景以及解决方案？" class="headerlink" title="ANR 出现的场景以及解决方案？"></a>ANR 出现的场景以及解决方案？</h4><h4 id="谈谈-Android-中内存优化的方式？"><a href="#谈谈-Android-中内存优化的方式？" class="headerlink" title="谈谈 Android 中内存优化的方式？"></a>谈谈 Android 中内存优化的方式？</h4><h4 id="谈谈布局优化的技巧？"><a href="#谈谈布局优化的技巧？" class="headerlink" title="谈谈布局优化的技巧？"></a>谈谈布局优化的技巧？</h4><h4 id="Android-中的图片优化方案？"><a href="#Android-中的图片优化方案？" class="headerlink" title="Android 中的图片优化方案？"></a>Android 中的图片优化方案？</h4><h4 id="Android-Native-Crash-问题如何分析定位？"><a href="#Android-Native-Crash-问题如何分析定位？" class="headerlink" title="Android Native Crash 问题如何分析定位？"></a>Android Native Crash 问题如何分析定位？</h4><h4 id="谈谈代码混淆的步骤？"><a href="#谈谈代码混淆的步骤？" class="headerlink" title="谈谈代码混淆的步骤？"></a>谈谈代码混淆的步骤？</h4><h4 id="谈谈-App-的电量优化？"><a href="#谈谈-App-的电量优化？" class="headerlink" title="谈谈 App 的电量优化？"></a>谈谈 App 的电量优化？</h4><h4 id="谈谈如何对-WebView-进行优化？"><a href="#谈谈如何对-WebView-进行优化？" class="headerlink" title="谈谈如何对 WebView 进行优化？"></a>谈谈如何对 WebView 进行优化？</h4><h4 id="如何处理大图的加载？"><a href="#如何处理大图的加载？" class="headerlink" title="如何处理大图的加载？"></a>如何处理大图的加载？</h4><h4 id="谈谈如何对网络请求进行优化？"><a href="#谈谈如何对网络请求进行优化？" class="headerlink" title="谈谈如何对网络请求进行优化？"></a>谈谈如何对网络请求进行优化？</h4><h4 id="请谈谈如何加载-Bitmap-并防止内存溢出？"><a href="#请谈谈如何加载-Bitmap-并防止内存溢出？" class="headerlink" title="请谈谈如何加载 Bitmap 并防止内存溢出？"></a>请谈谈如何加载 Bitmap 并防止内存溢出？</h4><h4 id="针对-RecyclerView-你做了哪些优化？"><a href="#针对-RecyclerView-你做了哪些优化？" class="headerlink" title="针对 RecyclerView 你做了哪些优化？"></a>针对 RecyclerView 你做了哪些优化？</h4><h2 id="开源框架"><a href="#开源框架" class="headerlink" title="开源框架"></a>开源框架</h2><h4 id="LeakCanary-原理"><a href="#LeakCanary-原理" class="headerlink" title="LeakCanary 原理"></a>LeakCanary 原理</h4><h4 id="用到的一些开源框架，介绍一个看过源码的，内部实现过程"><a href="#用到的一些开源框架，介绍一个看过源码的，内部实现过程" class="headerlink" title="用到的一些开源框架，介绍一个看过源码的，内部实现过程"></a>用到的一些开源框架，介绍一个看过源码的，内部实现过程</h4><h4 id="App-路由设计"><a href="#App-路由设计" class="headerlink" title="App 路由设计"></a>App 路由设计</h4><h4 id="介绍下-okhttp-中的设计模式-x2F-拦截器-x2F-连接池"><a href="#介绍下-okhttp-中的设计模式-x2F-拦截器-x2F-连接池" class="headerlink" title="介绍下 okhttp 中的设计模式&#x2F;拦截器&#x2F;连接池"></a>介绍下 okhttp 中的设计模式&#x2F;拦截器&#x2F;连接池</h4><h4 id="请说说依赖注入框架-ButterKnife-的实现原理？"><a href="#请说说依赖注入框架-ButterKnife-的实现原理？" class="headerlink" title="请说说依赖注入框架 ButterKnife 的实现原理？"></a>请说说依赖注入框架 <code>ButterKnife</code> 的实现原理？</h4><h4 id="谈一谈-EventBus-的原理？"><a href="#谈一谈-EventBus-的原理？" class="headerlink" title="谈一谈 EventBus 的原理？"></a>谈一谈 EventBus 的原理？</h4><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><h4 id="请谈谈你对-MVC-和-MVP-的理解？"><a href="#请谈谈你对-MVC-和-MVP-的理解？" class="headerlink" title="请谈谈你对 MVC 和 MVP 的理解？"></a>请谈谈你对 MVC 和 MVP 的理解？</h4><h4 id="请简要谈一谈单例模式？"><a href="#请简要谈一谈单例模式？" class="headerlink" title="请简要谈一谈单例模式？"></a>请简要谈一谈单例模式？</h4><h4 id="对于面向对象的六大基本原则了解多少？"><a href="#对于面向对象的六大基本原则了解多少？" class="headerlink" title="对于面向对象的六大基本原则了解多少？"></a>对于面向对象的六大基本原则了解多少？</h4><h4 id="请列出几种常见的工厂模式并说明它们的用法？"><a href="#请列出几种常见的工厂模式并说明它们的用法？" class="headerlink" title="请列出几种常见的工厂模式并说明它们的用法？"></a>请列出几种常见的工厂模式并说明它们的用法？</h4><h4 id="说说项目中用到的设计模式和使用场景？"><a href="#说说项目中用到的设计模式和使用场景？" class="headerlink" title="说说项目中用到的设计模式和使用场景？"></a>说说项目中用到的设计模式和使用场景？</h4><h4 id="什么是代理模式？如何使用？Android源码中的代理模式？"><a href="#什么是代理模式？如何使用？Android源码中的代理模式？" class="headerlink" title="什么是代理模式？如何使用？Android源码中的代理模式？"></a>什么是代理模式？如何使用？Android源码中的代理模式？</h4><h4 id="谈一谈单例模式，建造者模式，工厂模式的使用场景？如何合理选择？"><a href="#谈一谈单例模式，建造者模式，工厂模式的使用场景？如何合理选择？" class="headerlink" title="谈一谈单例模式，建造者模式，工厂模式的使用场景？如何合理选择？"></a>谈一谈单例模式，建造者模式，工厂模式的使用场景？如何合理选择？</h4><h4 id="请谈谈策略模式原理及其应用场景？"><a href="#请谈谈策略模式原理及其应用场景？" class="headerlink" title="请谈谈策略模式原理及其应用场景？"></a>请谈谈策略模式原理及其应用场景？</h4><h4 id="静态代理和动态代理的区别，什么场景使用？"><a href="#静态代理和动态代理的区别，什么场景使用？" class="headerlink" title="静态代理和动态代理的区别，什么场景使用？"></a>静态代理和动态代理的区别，什么场景使用？</h4><h4 id="谈一谈责任链模式的使用场景？"><a href="#谈一谈责任链模式的使用场景？" class="headerlink" title="谈一谈责任链模式的使用场景？"></a>谈一谈责任链模式的使用场景？</h4><h1 id="工程"><a href="#工程" class="headerlink" title="工程"></a>工程</h1><h4 id="谈一谈-Android-的签名机制？"><a href="#谈一谈-Android-的签名机制？" class="headerlink" title="谈一谈 Android 的签名机制？"></a>谈一谈 Android 的签名机制？</h4><h4 id="安卓的-app-加固如何做"><a href="#安卓的-app-加固如何做" class="headerlink" title="安卓的 app 加固如何做"></a>安卓的 app 加固如何做</h4><h4 id="安卓的混淆原理是什么？"><a href="#安卓的混淆原理是什么？" class="headerlink" title="安卓的混淆原理是什么？"></a>安卓的混淆原理是什么？</h4><h4 id="插件化-组件化-热修复"><a href="#插件化-组件化-热修复" class="headerlink" title="插件化+组件化+热修复"></a>插件化+组件化+热修复</h4><h4 id="业务稳定性如何保障？如果发生了异常情况，怎么快速止损？"><a href="#业务稳定性如何保障？如果发生了异常情况，怎么快速止损？" class="headerlink" title="业务稳定性如何保障？如果发生了异常情况，怎么快速止损？"></a>业务稳定性如何保障？如果发生了异常情况，怎么快速止损？</h4><h4 id="Android的打包流程？如何实现多渠道打包？"><a href="#Android的打包流程？如何实现多渠道打包？" class="headerlink" title="Android的打包流程？如何实现多渠道打包？"></a>Android的打包流程？如何实现多渠道打包？</h4><h4 id="Android-中-App-是如何沙箱化的为何要这么做？"><a href="#Android-中-App-是如何沙箱化的为何要这么做？" class="headerlink" title="Android 中 App 是如何沙箱化的为何要这么做？"></a>Android 中 App 是如何沙箱化的为何要这么做？</h4><h4 id="请简述-Apk-的安装过程？"><a href="#请简述-Apk-的安装过程？" class="headerlink" title="请简述 Apk 的安装过程？"></a>请简述 Apk 的安装过程？</h4><h4 id="谈谈如何适配更多机型的？"><a href="#谈谈如何适配更多机型的？" class="headerlink" title="谈谈如何适配更多机型的？"></a>谈谈如何适配更多机型的？</h4><h4 id="有没有遇到-64k-问题，应该如何解决？"><a href="#有没有遇到-64k-问题，应该如何解决？" class="headerlink" title="有没有遇到 64k 问题，应该如何解决？"></a>有没有遇到 64k 问题，应该如何解决？</h4><h4 id="如何优化-Gradle-的构建速度？"><a href="#如何优化-Gradle-的构建速度？" class="headerlink" title="如何优化 Gradle 的构建速度？"></a>如何优化 Gradle 的构建速度？</h4><h4 id="如何获取-Android-设备唯一ID？"><a href="#如何获取-Android-设备唯一ID？" class="headerlink" title="如何获取 Android 设备唯一ID？"></a>如何获取 Android 设备唯一ID？</h4><h4 id="什么是-AOP？在-Android-中它有哪些应用场景？"><a href="#什么是-AOP？在-Android-中它有哪些应用场景？" class="headerlink" title="什么是 AOP？在 Android 中它有哪些应用场景？"></a>什么是 AOP？在 Android 中它有哪些应用场景？</h4><h4 id="请谈谈你是如何实现数据埋点的？"><a href="#请谈谈你是如何实现数据埋点的？" class="headerlink" title="请谈谈你是如何实现数据埋点的？"></a>请谈谈你是如何实现数据埋点的？</h4><h4 id="假如让你实现断点上传功能，你认为应该怎样去做？"><a href="#假如让你实现断点上传功能，你认为应该怎样去做？" class="headerlink" title="假如让你实现断点上传功能，你认为应该怎样去做？"></a>假如让你实现断点上传功能，你认为应该怎样去做？</h4><h4 id="webp-和-svg-格式的图片各自有什么特点？应该如何在-Android-中使用？"><a href="#webp-和-svg-格式的图片各自有什么特点？应该如何在-Android-中使用？" class="headerlink" title="webp 和 svg 格式的图片各自有什么特点？应该如何在 Android 中使用？"></a>webp 和 svg 格式的图片各自有什么特点？应该如何在 Android 中使用？</h4><h4 id="对于-GIF-图片加载有什么思路和建议？"><a href="#对于-GIF-图片加载有什么思路和建议？" class="headerlink" title="对于 GIF 图片加载有什么思路和建议？"></a>对于 GIF 图片加载有什么思路和建议？</h4><h4 id="为什么要将项目迁移到AndroidX？如何进行迁移？"><a href="#为什么要将项目迁移到AndroidX？如何进行迁移？" class="headerlink" title="为什么要将项目迁移到AndroidX？如何进行迁移？"></a>为什么要将项目迁移到AndroidX？如何进行迁移？</h4>
        </div>

        
            <section class="post-copyright">
                
                    <p class="copyright-item">
                        <span>Author:</span>
                        <span>千越</span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>Permalink:</span>
                        <span><a href="https://qianyuebits.github.io/2024/01/18/Android-Interview/">https://qianyuebits.github.io/2024/01/18/Android-Interview/</a></span>
                    </p>
                
                
                    <p class="copyright-item">
                        <span>License:</span>
                        <span>Copyright (c) 2019 <a target="_blank" rel="noopener" href="http://creativecommons.org/licenses/by-nc/4.0/">CC-BY-NC-4.0</a> LICENSE</span>
                    </p>
                
                

            </section>
        
        <section class="post-tags">
            <div>
                <span>Tag(s):</span>
                <span class="tag">
                    
                    
                        <a href="/tag/%E9%9D%A2%E8%AF%95/"># 面试</a>
                    
                        
                </span>
            </div>
            <div>
                <a href="javascript:window.history.back();">back</a>
                <span>· </span>
                <a href="/">home</a>
            </div>
        </section>
        <section class="post-nav">
            
            
            <a class="next" rel="next" href="/2024/01/18/Android-Activity-Lifecycle/">Android Activity Lifecycle</a>
            
        </section>


    </article>
</div>

            </div>
            <footer id="footer" class="footer">
    <div class="copyright">
        <span>© 千越 | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>

</html>